<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>The Luchabrarian v2.0 â€” Phase 1</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: linear-gradient(135deg, #0a0a14 0%, #1a1a2a 50%, #0a0a14 100%);
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    user-select: none;
  }
  #wrap {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    box-shadow: inset 0 0 100px rgba(0,0,0,0.5);
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  #wrap::after {
    content:'';
    position:absolute; inset:0; pointer-events:none;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.05) 2px, rgba(0,0,0,0.05) 4px);
    z-index:10;
  }
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THE LUCHABRARIAN v2.0 â€” PHASE 1
// Power-ups, Difficulty Selection, Enhanced Visual Effects
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let W = window.innerWidth, H = window.innerHeight;
const TILE = 32;

// Make canvas responsive
function resizeCanvas() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const BOOK_TYPES = ['ROMANCE','SCIENCE','HORROR','SCIFI','TABLETS','FORBIDDEN','MANGA','TRASH','MYSTERY'];
const BOOK_LABELS = {
  ROMANCE:'Romance', SCIENCE:'Science', HORROR:'Horror', SCIFI:'Sci-Fi',
  TABLETS:'Tablets', FORBIDDEN:'Forbidden', MANGA:'Manga', TRASH:'Trash', MYSTERY:'Mystery'
};
const BOOK_COLORS = {
  ROMANCE:'#e84a8a', SCIENCE:'#2ea05c', HORROR:'#7a2ec0', SCIFI:'#2e5cc0',
  TABLETS:'#00bfff', FORBIDDEN:'#222222', MANGA:'#d4a82e', TRASH:'#f0e840', MYSTERY:'#8a8a9a'
};
const SHELF_GLOW = {
  ROMANCE:'#ff6aaa', SCIENCE:'#2aaa5c', HORROR:'#aa4aff', SCIFI:'#4a8cff',
  TABLETS:'#40ddff', FORBIDDEN:'#666666', MANGA:'#f0c840', TRASH:'#ffff00', MYSTERY:'#aaaacc'
};

// â”€â”€ Difficulty Settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DIFFICULTIES = {
  EASY: {
    label: 'Easy',
    gameTime: 120,
    playerSpeed: 288, // Increased from 180 (1.6x - old speed boost is now default!)
    ghostSpeed: 45,
    ghostFirst: 12000,
    ghostInterval: 15000,
    carryLimit: 5, // Increased from 4 - carry more books!
    healthRegen: 2 // hp per second when no ghosts nearby
  },
  MEDIUM: {
    label: 'Medium',
    gameTime: 90,
    playerSpeed: 256, // Increased from 160 (1.6x)
    ghostSpeed: 55,
    ghostFirst: 8000,
    ghostInterval: 12000,
    carryLimit: 5, // Increased from 3 - carry more books!
    healthRegen: 1
  },
  HARD: {
    label: 'Hard',
    gameTime: 60,
    playerSpeed: 224, // Increased from 140 (1.6x)
    ghostSpeed: 70,
    ghostFirst: 5000,
    ghostInterval: 8000,
    carryLimit: 5, // Increased from 3 - carry more books!
    healthRegen: 0
  },
  ENDLESS: {
    label: 'Endless',
    gameTime: Infinity,
    playerSpeed: 256, // Increased from 160 (1.6x)
    ghostSpeed: 55,
    ghostFirst: 8000,
    ghostInterval: 12000,
    carryLimit: 5, // Increased from 3 - carry more books!
    healthRegen: 0.5,
    waveMultiplier: 1.15
  }
};

// â”€â”€ Power-up Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const POWERUP_TYPES = {
  SPEED: {
    label: 'Speed Boost',
    duration: 8000,
    icon: 'âš¡',
    color: '#f0e840'
  },
  MULTICARRY: {
    label: 'Multi-Carry',
    duration: 12000,
    icon: 'ğŸ“š',
    color: '#4a8cff'
  },
  REPEL: {
    label: 'Ghost Repel',
    duration: 6000,
    icon: 'ğŸ›¡ï¸',
    color: '#2aaa5c'
  },
  TIMEFREEZE: {
    label: 'Time Freeze',
    duration: 5000,
    icon: 'â¸ï¸',
    color: '#40ddff'
  },
  AUTOSORT: {
    label: 'Auto-Sort',
    duration: 10000,
    icon: 'ğŸ¯',
    color: '#aa4aff'
  },
  DOUBLEPOINTS: {
    label: 'Double Points',
    duration: 15000,
    icon: 'ğŸ’°',
    color: '#c8a84a'
  },
  HEALTH: {
    label: 'Health Restore',
    duration: 0, // Instant effect, no duration
    icon: '+',
    color: '#ff4444',
    healAmount: 40 // Heals 40 HP (partial recovery)
  }
};

// Shelves hold every type EXCEPT Trash. Trash has its own can.
// Shelves - will be positioned dynamically based on screen size
const SHELF_TYPES = ['ROMANCE', 'SCIENCE', 'HORROR', 'SCIFI', 'TABLETS', 'FORBIDDEN', 'MANGA', 'MYSTERY'];

const DASH_SPEED = 340, DASH_DUR = 220, DASH_CD = 600;
const COMBO_TIMEOUT = 3500, SCORE_BASE = 100, COMBO_MULT = 1.5;
const ESCALATION_MS = 20000;
const GHOST_DAMAGE = 20;

// Ghost types with different behaviors
const GHOST_TYPES = {
  NORMAL: {
    color: '#e8e8f0',
    speed: 1,
    health: 1,
    size: 12,
    behavior: 'chase'
  },
  FAST: {
    color: '#f0f0ff',
    speed: 1.5,
    health: 1,
    size: 10,
    behavior: 'chase'
  },
  TANK: {
    color: '#c8c8d8',
    speed: 0.7,
    health: 2,
    size: 16,
    behavior: 'chase'
  },
  TELEPORTER: {
    color: '#d0d0ff',
    speed: 0.8,
    health: 1,
    size: 12,
    behavior: 'teleport'
  },
  BOSS: {
    color: '#a0a0c0',
    speed: 0.6,
    health: 3,
    size: 20,
    behavior: 'boss'
  },
  
  // â•â•â• NEW ENEMY TYPES â•â•â•
  
  SWARM: {
    color: '#b8b8e8',
    speed: 0.9,
    health: 2,
    size: 14,
    behavior: 'chase',
    splitCount: 3, // Splits into 3 mini-ghosts on death
    miniGhostHealth: 1,
    miniGhostSize: 8,
    miniGhostSpeed: 1.2
  },
  
  RANGED: {
    color: '#e8c8ff',
    speed: 0.5,
    health: 1,
    size: 12,
    behavior: 'ranged',
    shootCooldown: 2500, // Shoots every 2.5 seconds
    shootRange: 350,
    projectileSpeed: 200,
    projectileDamage: 15,
    keepDistance: 220 // Tries to stay this far from player
  },
  
  BOMBER: {
    color: '#ffaa88',
    speed: 1.3,
    health: 1,
    size: 11,
    behavior: 'chase',
    explosionRadius: 90,
    explosionDamage: 25,
    fuseDuration: 1500, // Starts flashing 1.5s before contact
    suicideRush: true // Speeds up when close
  },
  
  MIMIC: {
    color: '#f0ebd6', // Book-colored when disguised
    speed: 0,
    health: 1,
    size: 8,
    behavior: 'mimic',
    revealDistance: 60,
    chaseSpeed: 1.6,
    disguisedAsBook: true,
    possibleBookTypes: ['FICTION', 'HISTORY', 'SCIENCE', 'ART', 'PHILOSOPHY', 'BIOGRAPHY', 'POETRY', 'RELIGION']
  },
  
  POSSESSOR: {
    color: '#aa44aa',
    speed: 0.8,
    health: 2,
    size: 13,
    behavior: 'possessor',
    possessionTime: 8000, // Possesses shelf for 8 seconds
    possessionRange: 70,
    possessionCooldown: 3000,
    phaseSpeed: 0.05 // Ethereal floating effect
  },
  
  SHIELD: {
    color: '#8888cc',
    speed: 0.7,
    health: 3,
    size: 14,
    behavior: 'shield',
    shieldArc: Math.PI * 0.55, // 100 degree shield coverage
    shieldRotationSpeed: 0.015,
    shieldHealth: 1, // Shield can be broken
    shieldRegenTime: 5000 // Shield regenerates after 5s
  },
  
  CHAIN: {
    color: '#cc88ff',
    speed: 0.85,
    health: 2,
    size: 12,
    behavior: 'chain',
    chainDistance: 140,
    chainStrength: 0.3, // Pull strength toward partner
    sharedDamage: 0.5 // Partner takes 50% of damage too
  }
};

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys = {};
const keyDown = {}, keyUp = {};
window.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  keys[k] = true;
  keyDown[k] = true;
  if(['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) e.preventDefault();
});
window.addEventListener('keyup', e => {
  const k = e.key.toLowerCase();
  keys[k] = false;
  keyUp[k] = true;
});

// â”€â”€ Math helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }
function norm(x,y){ const l=Math.sqrt(x*x+y*y); return l?[x/l,y/l]:[0,0]; }
function lerp(a,b,t){ return a+(b-a)*t; }
function rnd(min,max){ return min+Math.random()*(max-min); }
function rint(min,max){ return Math.floor(rnd(min,max+1)); }
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let state = 'menu'; // menu | difficulty | play | paused | gameover
let menuSelection = 0;
let difficultySelection = 'MEDIUM';
let currentDifficulty = DIFFICULTIES.MEDIUM;

let score, timeLeft, combo, comboTimer, escalationTimer, ghostTimer, escalLevel, wave;
let player, books, shelves, trashCan, ghosts, particles, flashAlpha, feedbacks, powerups;
let escWas = false;
let screenShake = 0;
let timeFrozen = false;
let scoreMultiplier = 1;
let activePowerup = null;
let booksFiledThisGame = 0;

// â•â•â• CONTINUOUS SPAWN TIMERS â•â•â•
let bookSpawnTimer = 0;
let powerupSpawnTimer = 0;
const BOOK_SPAWN_MIN = 3000;   // Minimum 3 seconds between book spawns
const BOOK_SPAWN_MAX = 8000;   // Maximum 8 seconds between book spawns
const POWERUP_SPAWN_MIN = 15000; // Minimum 15 seconds between powerup spawns
const POWERUP_SPAWN_MAX = 30000; // Maximum 30 seconds between powerup spawns
let nextBookSpawnTime = 0;
let nextPowerupSpawnTime = 0;

// Environmental decorations
let lamps = [];
let plants = [];
let windows = [];
let ambientParticles = [];
let timeOfDay = 0; // 0-1 value for day/night cycle

// UI/HUD state
let scoreDisplay = 0; // Animated score counter
let comboMeterFill = 0; // 0-1 fill for combo meter
let achievementQueue = []; // Queue of achievement notifications
let miniMapVisible = true;

// Camera and screen effects
let cameraX = 0;
let cameraY = 0;
let targetCameraX = 0;
let targetCameraY = 0;
let cameraShakeX = 0;
let cameraShakeY = 0;
let cameraZoom = 1;
let targetZoom = 1;
let chromaticAberration = 0;
let vignetteIntensity = 0;
let motionBlurAlpha = 0;

// Combat system
let thrownBooks = []; // Books in flight
let chargeAttack = null; // {x, y, progress, radius}
let dashKills = 0; // Track for achievements
let parryWindow = 0; // Frame-perfect parry timing

// New ghost systems
let ghostProjectiles = []; // Projectiles from ranged ghosts
let miniGhosts = []; // Mini-ghosts from swarm splits (tracked separately for cleanup)
let possessedShelves = new Set(); // Track which shelves are possessed

// Menu animations
let menuTransitionAlpha = 0; // For fade in/out
let menuItemAnimations = []; // Per-item entrance animations
let menuStars = []; // Background star particles
let menuInitialized = false;

// â”€â”€ Initialize Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initMenu() {
  menuTransitionAlpha = 0;
  menuItemAnimations = [
    { y: -50, alpha: 0 }, // Title
    { y: -30, alpha: 0 }, // Start Game
    { y: -30, alpha: 0 }  // Endless Mode
  ];
  
  // Create starfield background
  menuStars = [];
  for (let i = 0; i < 50; i++) {
    menuStars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: Math.random() * 2 + 1,
      speed: Math.random() * 0.5 + 0.2,
      twinkle: Math.random() * Math.PI * 2
    });
  }
  
  menuInitialized = true;
}

// â”€â”€ Update Menu Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateMenuAnimations(dt) {
  if (!menuInitialized) initMenu();
  
  // Fade in
  if (menuTransitionAlpha < 1) {
    menuTransitionAlpha = Math.min(1, menuTransitionAlpha + dt * 0.002);
  }
  
  // Animate menu items sliding in
  for (let i = 0; i < menuItemAnimations.length; i++) {
    const anim = menuItemAnimations[i];
    if (anim.y < 0) {
      anim.y = Math.min(0, anim.y + dt * 0.15);
    }
    if (anim.alpha < 1) {
      anim.alpha = Math.min(1, anim.alpha + dt * 0.003);
    }
  }
  
  // Animate stars
  for (const star of menuStars) {
    star.y += star.speed * dt * 0.05;
    if (star.y > H) {
      star.y = -10;
      star.x = Math.random() * W;
    }
    star.twinkle += dt * 0.003;
  }
}

function initGame(difficulty = 'MEDIUM') {
  state = 'play';
  currentDifficulty = DIFFICULTIES[difficulty];
  difficultySelection = difficulty;
  
  score = 0;
  timeLeft = currentDifficulty.gameTime;
  combo = 0;
  comboTimer = 0;
  escalationTimer = ESCALATION_MS;
  ghostTimer = currentDifficulty.ghostFirst;
  escalLevel = 0;
  wave = 1;
  flashAlpha = 0;
  screenShake = 0;
  timeFrozen = false;
  scoreMultiplier = 1;
  activePowerup = null;
  booksFiledThisGame = 0;
  
  feedbacks = [];
  particles = [];
  powerups = [];

  // Player starts in center
  player = {
    x: W/2, y: H/2,
    dir: 0,
    carrying: [],
    dashing: false,
    dashCd: 0,
    bobPhase: 0,
    vx: 0,
    vy: 0,
    health: 100,
    maxHealth: 100,
    speedMultiplier: 1,
    carryBonus: 0,
    invincible: false,
    repel: false,
    autoSort: false,
    // Animation state
    walkFrame: 0,
    walkTimer: 0,
    idleTimer: 0,
    dashTrail: [] // For dash motion blur
  };

  // Dynamic shelf positioning based on screen size
  // Calculate playable area (accounting for HUD at top and controls at bottom)
  const hudHeight = 28;
  const controlsHeight = 25;
  const playAreaTop = hudHeight + 60;
  const playAreaBottom = H - controlsHeight - 60;
  const playAreaLeft = 100;
  const playAreaRight = W - 100;
  const playAreaWidth = playAreaRight - playAreaLeft;
  const playAreaHeight = playAreaBottom - playAreaTop;

  // Arrange shelves in a grid pattern that fills the space
  shelves = [];
  const cols = 4;
  const rows = 2;
  const colWidth = playAreaWidth / cols;
  const rowHeight = playAreaHeight / rows;
  
  let shelfIndex = 0;
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      if (shelfIndex < SHELF_TYPES.length) {
        const x = playAreaLeft + colWidth * col + colWidth/2;
        const y = playAreaTop + rowHeight * row + rowHeight/2;
        
        shelves.push({
          x: x,
          y: y,
          type: SHELF_TYPES[shelfIndex],
          glowPulse: 0,
          acceptPulse: 0,
          filingAnimation: null, // {book, progress, startX, startY}
          storedBooks: [], // Books visually on the shelf
          capacity: 20, // Maximum books this shelf can hold
          filedCount: 0, // How many books filed
          completionState: 0, // 0-1 completion animation
          isComplete: false, // Shelf full flag
          completionCelebration: 0, // Celebration timer
          lastFiledTime: 0, // For animation timing
          
          // â•â•â• NINTENDO: SHELF-SPECIFIC BONUS SYSTEMS â•â•â•
          bonusState: {
            // FICTION - Page Turner
            pageCount: 0,           // Counts to 5
            pageTurnerReady: false, // Visual indicator
            
            // ROMANCE - Love Connection
            lastRomanceTime: 0,     // Timestamp of last file
            romanceChain: 0,        // Books filed in quick succession
            
            // HORROR - Jump Scare
            nextJumpScare: null,    // Which slot will be 3x
            
            // SCIENCE - Experiment
            lastScienceColor: null, // Track filing order
            scienceChain: 0,        // Correct order streak
            
            // SCI-FI - Warp Speed
            scifiSpeed: 0,          // Books filed quickly
            scifiSpeedTimer: 0,     // Time window
            
            // MYSTERY - Clue Collector
            cluesFound: 0,          // Number of clues collected
            mysteryMultiplier: 1,   // Hidden multiplier
            
            // TABLETS - Ancient Wisdom
            wisdomCount: 0,         // Knowledge accumulated
            
            // MANGA - Combo Attack
            mangaExtension: 0       // Combo time extension bonus
          }
        });
        shelfIndex++;
      }
    }
  }

  // Trash can in center of play area
  trashCan = {
    x: W/2,
    y: playAreaTop + playAreaHeight/2,
    glowPulse: 0,
    acceptPulse: 0
  };

  // Books scattered throughout play area
  books = [];
  for (let i = 0; i < 8; i++) spawnBook();

  ghosts = [];
  
  // â•â•â• INITIALIZE CONTINUOUS SPAWN TIMERS â•â•â•
  bookSpawnTimer = 0;
  powerupSpawnTimer = 0;
  // Set first spawn times to random intervals
  nextBookSpawnTime = rnd(BOOK_SPAWN_MIN, BOOK_SPAWN_MAX);
  nextPowerupSpawnTime = rnd(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
  
  // Initialize combat system
  thrownBooks = [];
  chargeAttack = null;
  dashKills = 0;
  parryWindow = 0;
  
  // Initialize new ghost systems
  ghostProjectiles = [];
  miniGhosts = [];
  possessedShelves.clear();
  
  // Initialize UI state
  scoreDisplay = 0;
  comboMeterFill = 0;
  achievementQueue = [];
  
  // Initialize camera
  cameraX = W / 2;
  cameraY = H / 2;
  cameraTargetX = W / 2;
  cameraTargetY = H / 2;
  zoomLevel = 1;
  targetZoom = 1;
  chromaticAberration = 0;
  vignetteIntensity = 0;
  
  // Initialize environmental decorations
  initEnvironment();
}

// â”€â”€ Initialize Environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initEnvironment() {
  const hudHeight = 28;
  const controlsHeight = 25;
  const playAreaTop = hudHeight + 60;
  const playAreaBottom = H - controlsHeight - 60;
  const playAreaLeft = 100;
  const playAreaRight = W - 100;
  
  // Reading lamps on walls
  lamps = [
    { x: 50, y: playAreaTop + 50, flickerPhase: Math.random() * Math.PI * 2 },
    { x: W - 50, y: playAreaTop + 50, flickerPhase: Math.random() * Math.PI * 2 },
    { x: 50, y: playAreaBottom - 50, flickerPhase: Math.random() * Math.PI * 2 },
    { x: W - 50, y: playAreaBottom - 50, flickerPhase: Math.random() * Math.PI * 2 }
  ];
  
  // Potted plants in corners
  plants = [
    { x: 60, y: playAreaTop + 30, sway: 0 },
    { x: W - 60, y: playAreaTop + 30, sway: Math.PI },
    { x: 60, y: playAreaBottom - 30, sway: Math.PI / 2 },
    { x: W - 60, y: playAreaBottom - 30, sway: Math.PI * 1.5 }
  ];
  
  // Windows showing outside
  windows = [
    { x: W / 4, y: playAreaTop - 20, width: 80, height: 40 },
    { x: W * 3 / 4, y: playAreaTop - 20, width: 80, height: 40 }
  ];
  
  // Ambient dust motes
  ambientParticles = [];
  for (let i = 0; i < 30; i++) {
    ambientParticles.push({
      x: rnd(playAreaLeft, playAreaRight),
      y: rnd(playAreaTop, playAreaBottom),
      vx: rnd(-5, 5),
      vy: rnd(-10, -5),
      size: rnd(1, 2),
      phase: Math.random() * Math.PI * 2,
      baseX: rnd(playAreaLeft, playAreaRight)
    });
  }
  
  timeOfDay = 0;
}

// â”€â”€ Update UI Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI(dt) {
  // Smooth score counter (counts up to actual score)
  if (scoreDisplay < score) {
    const diff = score - scoreDisplay;
    scoreDisplay += Math.max(1, Math.ceil(diff * 0.1));
  }
  
  // Combo meter fill (0-1 based on combo)
  const targetFill = Math.min(1, combo / 15); // 15x combo = full meter
  comboMeterFill = lerp(comboMeterFill, targetFill, 0.1);
  
  // Update achievement notifications
  for (let i = achievementQueue.length - 1; i >= 0; i--) {
    achievementQueue[i].life -= dt;
    if (achievementQueue[i].life <= 0) {
      achievementQueue.splice(i, 1);
    }
  }
}

// â”€â”€ Update Camera â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCamera(dt) {
  // Camera stays centered - no follow movement
  cameraX = W / 2;
  cameraY = H / 2;
  targetCameraX = W / 2;
  targetCameraY = H / 2;
  
  // Camera shake from screenShake variable
  if (screenShake > 0) {
    cameraShakeX = (Math.random() - 0.5) * screenShake * 12;
    cameraShakeY = (Math.random() - 0.5) * screenShake * 12;
  } else {
    cameraShakeX = 0;
    cameraShakeY = 0;
  }
  
  // Dynamic zoom effects
  if (combo >= 10) {
    targetZoom = 0.98; // Zoom out slightly at high combo
  } else {
    targetZoom = 1;
  }
  
  // Smooth zoom transition
  cameraZoom = lerp(cameraZoom, targetZoom, 0.12);
  
  // Chromatic aberration on heavy hits
  if (flashAlpha > 0.15) {
    chromaticAberration = Math.min(8, flashAlpha * 10);
  } else {
    chromaticAberration = Math.max(0, chromaticAberration - dt * 0.015);
  }
  
  // Vignette intensity based on health
  const healthPct = player.health / player.maxHealth;
  if (healthPct < 0.3) {
    vignetteIntensity = (0.3 - healthPct) * 2.5; // 0 to 0.75
  } else {
    vignetteIntensity = Math.max(0, vignetteIntensity - dt * 0.001);
  }
  
  // Motion blur disabled
  motionBlurAlpha = 0;
}


// â”€â”€ Add Achievement Notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showAchievementNotification(title, description) {
  achievementQueue.push({
    title,
    description,
    life: 4000,
    maxLife: 4000
  });
}

// Update environmental elements
function updateEnvironment(dt) {
  // Update time of day (full cycle in 2 minutes)
  timeOfDay += dt / 120000;
  if (timeOfDay > 1) timeOfDay = 0;
  
  // Update lamp flicker
  for (const lamp of lamps) {
    lamp.flickerPhase += dt * 0.01;
  }
  
  // Update plant sway
  for (const plant of plants) {
    plant.sway += dt * 0.001;
  }
  
  // Update ambient particles (floating dust)
  for (const p of ambientParticles) {
    p.x += p.vx * dt / 1000;
    p.y += p.vy * dt / 1000;
    p.phase += dt * 0.002;
    
    // Drift side to side
    p.x = p.baseX + Math.sin(p.phase) * 20;
    
    // Wrap around
    const hudHeight = 28;
    const controlsHeight = 25;
    const playAreaTop = hudHeight + 60;
    const playAreaBottom = H - controlsHeight - 60;
    const playAreaLeft = 100;
    const playAreaRight = W - 100;
    
    if (p.y < playAreaTop) p.y = playAreaBottom;
    if (p.y > playAreaBottom) p.y = playAreaTop;
    if (p.x < playAreaLeft) p.x = playAreaRight;
    if (p.x > playAreaRight) p.x = playAreaLeft;
  }
}

// â”€â”€ Handle Ghost Death â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleGhostDeath(ghost, killedBy = 'normal') {
  const gx = ghost.x;
  const gy = ghost.y;
  const gType = ghost.type;
  const gColor = ghost.typeData.color;
  
  // Special death behaviors
  if (gType === 'SWARM') {
    // SWARM GHOST SPLIT MECHANIC
    const splitCount = ghost.typeData.splitCount;
    
    for (let k = 0; k < splitCount; k++) {
      const angle = (k / splitCount) * Math.PI * 2;
      const spawnDist = 30;
      const miniSpeed = currentDifficulty.ghostSpeed * ghost.typeData.miniGhostSpeed;
      
      ghosts.push({
        x: gx + Math.cos(angle) * spawnDist,
        y: gy + Math.sin(angle) * spawnDist,
        phase: Math.random() * Math.PI * 2,
        alive: true,
        speed: miniSpeed,
        type: 'NORMAL',
        typeData: GHOST_TYPES.NORMAL,
        health: ghost.typeData.miniGhostHealth,
        maxHealth: ghost.typeData.miniGhostHealth,
        attackCooldown: 0,
        attackTelegraph: 0,
        teleportCooldown: 0,
        spawnAnimation: 1,
        isMiniGhost: true, // Flag for smaller rendering
        miniGhostSize: 8   // Smaller than normal
      });
    }
    
    // Epic split explosion
    PARTICLE_TYPES.SHOCKWAVE(gx, gy, gColor, 70);
    for (let j = 0; j < 20; j++) {
      PARTICLE_TYPES.SPARKLE(gx, gy, gColor, 700);
    }
    addFeedback(gx, gy - 30, 'SPLIT!', gColor, 14);
    screenShake = 0.8;
    
    return; // Don't do normal death particles
  }
  
  // BOMBER GHOST EXPLOSION (will add in next phase)
  if (gType === 'BOMBER') {
    const explosionRadius = ghost.typeData.explosionRadius;
    const explosionDamage = ghost.typeData.explosionDamage;
    const ghostDamage = ghost.typeData.explosionDamageGhost;
    
    // Damage player if in range
    const distToPlayer = dist(gx, gy, player.x, player.y);
    if (distToPlayer < explosionRadius && !player.invincible) {
      player.health -= explosionDamage;
      screenShake = 1.5;
      flashAlpha = 0.3;
      addFeedback(player.x, player.y - 30, `-${explosionDamage}`, '#ff2222', 14);
      
      // Check death
      if (player.health <= 0) {
        endGame('health');
        return;
      }
    }
    
    // Damage nearby ghosts
    for (let j = ghosts.length - 1; j >= 0; j--) {
      const other = ghosts[j];
      if (!other || other === ghost) continue;
      
      const distToOther = dist(gx, gy, other.x, other.y);
      if (distToOther < explosionRadius) {
        other.health -= ghostDamage;
        addFeedback(other.x, other.y - 20, `-${ghostDamage}`, '#ffaa88', 10);
        
        if (other.health <= 0) {
          // Chain explosion! (but don't recurse infinitely)
          if (other.type !== 'BOMBER') {
            handleGhostDeath(other, killedBy);
            ghosts.splice(j, 1);
          }
        } else {
          other.damageFlash = 200;
        }
      }
    }
    
    // Massive explosion visuals
    PARTICLE_TYPES.FIREWORK(gx, gy, '#ffaa88', 1000);
    PARTICLE_TYPES.SHOCKWAVE(gx, gy, '#ff6666', explosionRadius);
    for (let j = 0; j < 25; j++) {
      PARTICLE_TYPES.SPARKLE(gx, gy, '#ffaa88', 800);
    }
    addFeedback(gx, gy - 30, 'BOOM!', '#ff6666', 16);
    screenShake = Math.max(screenShake, 1.2);
    
    return; // Don't do normal death particles
  }
  
  // Normal death particles
  const particleCount = gType === 'BOSS' ? 30 : 12;
  for (let j = 0; j < particleCount; j++) {
    PARTICLE_TYPES.SPARKLE(gx, gy, gColor, 600);
  }
  PARTICLE_TYPES.SHOCKWAVE(gx, gy, gColor, gType === 'BOSS' ? 60 : 30);
  
  // Boss defeat message
  if (gType === 'BOSS') {
    addFeedback(gx, gy - 30, 'BOSS DEFEATED!', '#f0e840', 14);
  }
  
  // Special kill type messages
  if (killedBy === 'dash') {
    addFeedback(gx, gy - 30, 'DASH KILL!', '#4a8cff', 12);
  } else if (killedBy === 'throw') {
    addFeedback(gx, gy - 30, 'BOOK KILL!', '#ff6aaa', 12);
  } else if (killedBy === 'charge') {
    addFeedback(gx, gy - 30, 'CHARGE KILL!', '#f0e840', 14);
  } else if (killedBy === 'parry') {
    addFeedback(gx, gy - 30, 'COUNTER KILL!', '#f0e840', 14);
  } else if (killedBy === 'reflect') {
    addFeedback(gx, gy - 30, 'REFLECTED KILL!', '#f0e840', 14);
  }
}

// â”€â”€ Ghost Projectile System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Shoot a projectile from ghost toward target
function shootProjectile(ghost, targetX, targetY) {
  const angle = Math.atan2(targetY - ghost.y, targetX - ghost.x);
  const speed = ghost.typeData.projectileSpeed;
  
  ghostProjectiles.push({
    x: ghost.x,
    y: ghost.y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    damage: ghost.typeData.projectileDamage,
    size: 6,
    color: ghost.typeData.color,
    lifetime: 3000, // Auto-remove after 3 seconds
    fromGhost: ghost,
    trail: []
  });
  
  // Visual feedback
  for (let i = 0; i < 3; i++) {
    PARTICLE_TYPES.SPARKLE(ghost.x, ghost.y, ghost.typeData.color, 300);
  }
}

// Update all ghost projectiles
function updateGhostProjectiles(dt) {
  for (let i = ghostProjectiles.length - 1; i >= 0; i--) {
    const proj = ghostProjectiles[i];
    
    // Move projectile
    proj.x += proj.vx * dt / 1000;
    proj.y += proj.vy * dt / 1000;
    
    // Add trail
    proj.trail.push({ x: proj.x, y: proj.y, alpha: 1 });
    if (proj.trail.length > 6) proj.trail.shift();
    
    // Fade trail
    for (const t of proj.trail) {
      t.alpha -= dt * 0.004;
    }
    
    // Decrease lifetime
    proj.lifetime -= dt;
    if (proj.lifetime <= 0) {
      ghostProjectiles.splice(i, 1);
      continue;
    }
    
    // Check collision with player
    if (!player.invincible && dist(proj.x, proj.y, player.x, player.y) < 20) {
      // Hit player!
      player.health -= proj.damage;
      flashAlpha = 0.2;
      screenShake = 0.6;
      
      // Visual feedback
      addFeedback(player.x, player.y - 30, `-${proj.damage}`, '#ff2222', 12);
      PARTICLE_TYPES.SHOCKWAVE(proj.x, proj.y, proj.color, 30);
      for (let j = 0; j < 8; j++) {
        PARTICLE_TYPES.SPARKLE(proj.x, proj.y, proj.color, 400);
      }
      
      // Remove projectile
      ghostProjectiles.splice(i, 1);
      
      // Check death
      if (player.health <= 0) {
        endGame('health');
        return;
      }
      continue;
    }
    
    // Check if player can parry projectiles with dash
    if (parryWindow > 0 && dist(proj.x, proj.y, player.x, player.y) < 35) {
      // PARRIED! Reflect projectile back
      const reflectAngle = Math.atan2(proj.fromGhost.y - proj.y, proj.fromGhost.x - proj.x);
      proj.vx = Math.cos(reflectAngle) * proj.vx * 1.5; // Faster on return
      proj.vy = Math.sin(reflectAngle) * proj.vy * 1.5;
      proj.damage *= 2; // Double damage when reflected
      proj.reflected = true; // Flag to damage ghosts instead
      proj.color = '#f0e840'; // Golden when reflected
      
      addFeedback(player.x, player.y - 30, 'REFLECT!', '#f0e840', 14);
      PARTICLE_TYPES.SHOCKWAVE(proj.x, proj.y, '#f0e840', 40);
      parryWindow = 0; // Consume parry
      
      continue;
    }
    
    // If reflected, check collision with ghosts
    if (proj.reflected) {
      for (let j = ghosts.length - 1; j >= 0; j--) {
        const g = ghosts[j];
        if (!g) continue;
        
        if (dist(proj.x, proj.y, g.x, g.y) < (g.typeData.size + proj.size)) {
          // Hit ghost with reflected projectile!
          g.health -= proj.damage;
          
          addFeedback(g.x, g.y - 20, `-${proj.damage}`, '#f0e840', 12);
          screenShake = 0.4;
          
          for (let k = 0; k < 10; k++) {
            PARTICLE_TYPES.SPARKLE(g.x, g.y, '#f0e840', 500);
          }
          
          if (g.health <= 0) {
            // Handle special ghost death behaviors
            handleGhostDeath(g, 'reflect');
            
            // Remove ghost
            ghosts.splice(j, 1);
          } else {
            g.damageFlash = 200;
          }
          
          ghostProjectiles.splice(i, 1);
          break;
        }
      }
    }
    
    // Remove if off-screen
    if (proj.x < -50 || proj.x > W + 50 || proj.y < -50 || proj.y > H + 50) {
      ghostProjectiles.splice(i, 1);
    }
  }
}

// â”€â”€ Combat System Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Throw a book at ghosts
function throwBook() {
  if (player.carrying.length === 0) return;
  
  const book = player.carrying.pop(); // Remove from carrying
  const throwPower = 200 + player.throwCharge * 300; // 200-500 speed based on charge
  
  // Calculate throw direction (toward mouse would be ideal, but we'll use player direction)
  let throwAngle = 0;
  switch(player.dir) {
    case 0: throwAngle = Math.PI / 2; break; // Down
    case 1: throwAngle = 0; break; // Right
    case 2: throwAngle = -Math.PI / 2; break; // Up
    case 3: throwAngle = Math.PI; break; // Left
  }
  
  thrownBooks.push({
    x: player.x,
    y: player.y,
    vx: Math.cos(throwAngle) * throwPower,
    vy: Math.sin(throwAngle) * throwPower,
    type: book.type,
    color: BOOK_COLORS[book.type],
    damage: 5 + Math.floor(player.throwCharge * 15), // 5-20 damage
    size: 8 + player.throwCharge * 4, // Bigger when charged
    rot: 0,
    rotSpeed: player.throwCharge > 0.5 ? 0.3 : 0.15,
    lifetime: 2000,
    trail: []
  });
  
  // Visual/audio feedback
  addFeedback(player.x, player.y - 20, player.throwCharge > 0.7 ? 'POWER THROW!' : 'Throw!', '#ff6aaa', 10);
  for (let i = 0; i < 5; i++) {
    PARTICLE_TYPES.SPARKLE(player.x, player.y, book.color, 300);
  }
}

// Update thrown books in flight
function updateThrownBooks(dt) {
  for (let i = thrownBooks.length - 1; i >= 0; i--) {
    const book = thrownBooks[i];
    
    // Move
    book.x += book.vx * dt / 1000;
    book.y += book.vy * dt / 1000;
    book.rot += book.rotSpeed;
    
    // Add trail
    book.trail.push({ x: book.x, y: book.y, alpha: 1 });
    if (book.trail.length > 8) book.trail.shift();
    
    // Fade trail
    for (const t of book.trail) {
      t.alpha -= dt * 0.003;
    }
    
    // Friction
    book.vx *= 0.98;
    book.vy *= 0.98;
    
    // Lifetime
    book.lifetime -= dt;
    if (book.lifetime <= 0) {
      thrownBooks.splice(i, 1);
      continue;
    }
    
    // Check collision with ghosts
    for (let j = ghosts.length - 1; j >= 0; j--) {
      const g = ghosts[j];
      if (!g) continue;
      
      if (dist(book.x, book.y, g.x, g.y) < (g.typeData.size + book.size)) {
        // Hit!
        g.health -= book.damage;
        
        // Visual feedback
        addFeedback(g.x, g.y - 20, `-${book.damage}`, '#ff6aaa', 10);
        screenShake = 0.3;
        
        for (let k = 0; k < 10; k++) {
          PARTICLE_TYPES.SPARKLE(g.x, g.y, book.color, 400);
        }
        PARTICLE_TYPES.PAGE(g.x, g.y);
        
        // Knockback
        const [kbx, kby] = norm(book.vx, book.vy);
        g.x += kbx * 50;
        g.y += kby * 50;
        
        if (g.health <= 0) {
          // Handle special ghost death behaviors
          handleGhostDeath(g, 'throw');
          
          // Remove ghost
          ghosts.splice(j, 1);
        } else {
          g.damageFlash = 200;
        }
        
        // Remove thrown book
        thrownBooks.splice(i, 1);
        break;
      }
    }
    
    // Check if off-screen
    if (book.x < -50 || book.x > W + 50 || book.y < -50 || book.y > H + 50) {
      thrownBooks.splice(i, 1);
    }
  }
}

// Activate charged radial attack
function activateChargeAttack() {
  if (player.carrying.length < 3) return;
  
  const power = player.chargeProgress;
  const radius = 80 + power * 70; // 80-150 radius
  const damage = Math.floor(10 + power * 25); // 10-35 damage
  
  // Remove 3 books from carrying
  for (let i = 0; i < 3; i++) {
    player.carrying.pop();
  }
  
  chargeAttack = {
    x: player.x,
    y: player.y,
    radius: 0,
    maxRadius: radius,
    damage: damage,
    lifetime: 500
  };
  
  // Massive visual feedback
  addFeedback(player.x, player.y - 40, 'BOOK SLAM!', '#f0e840', 16);
  screenShake = 1.2;
  flashAlpha = 0.15;
  
  // Initial burst
  for (let i = 0; i < 30; i++) {
    PARTICLE_TYPES.SPARKLE(player.x, player.y, '#f0e840', 800);
  }
  PARTICLE_TYPES.SHOCKWAVE(player.x, player.y, '#f0e840', radius);
}

// Update charge attack
function updateChargeAttack(dt) {
  if (!chargeAttack) return;
  
  chargeAttack.lifetime -= dt;
  chargeAttack.radius = Math.min(chargeAttack.maxRadius, chargeAttack.radius + dt * 0.5);
  
  // Continuous particles
  if (Math.random() < 0.5) {
    const angle = Math.random() * Math.PI * 2;
    PARTICLE_TYPES.SPARKLE(
      chargeAttack.x + Math.cos(angle) * chargeAttack.radius,
      chargeAttack.y + Math.sin(angle) * chargeAttack.radius,
      '#f0e840',
      400
    );
  }
  
  // Damage ghosts in radius
  for (let i = ghosts.length - 1; i >= 0; i--) {
    const g = ghosts[i];
    if (!g || g.hitByCharge) continue;
    
    const d = dist(chargeAttack.x, chargeAttack.y, g.x, g.y);
    if (d < chargeAttack.radius) {
      g.health -= chargeAttack.damage;
      g.hitByCharge = true; // Only hit once per charge attack
      
      // Knockback
      const [kbx, kby] = norm(g.x - chargeAttack.x, g.y - chargeAttack.y);
      g.x += kbx * 150;
      g.y += kby * 150;
      
      // Visual feedback
      addFeedback(g.x, g.y - 20, `-${chargeAttack.damage}`, '#f0e840', 12);
      for (let j = 0; j < 12; j++) {
        PARTICLE_TYPES.SPARKLE(g.x, g.y, '#f0e840', 500);
      }
      
      if (g.health <= 0) {
        // Handle special ghost death behaviors
        handleGhostDeath(g, 'charge');
        
        // Remove ghost
        ghosts.splice(i, 1);
      } else {
        g.damageFlash = 300;
      }
    }
  }
  
  // Remove when done
  if (chargeAttack.lifetime <= 0) {
    // Clear hitByCharge flags
    for (const g of ghosts) {
      if (g) g.hitByCharge = false;
    }
    chargeAttack = null;
  }
}

// â”€â”€ Spawn Book â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnBook() {
  const type = BOOK_TYPES[rint(0, BOOK_TYPES.length-1)];
  
  // Define safe spawn area (avoid HUD and controls)
  const hudHeight = 28;
  const controlsHeight = 25;
  const marginTop = hudHeight + 80;
  const marginBottom = controlsHeight + 80;
  const marginSide = 80;
  
  let bx, by;
  for (let t = 0; t < 60; t++) {
    bx = rnd(marginSide, W - marginSide);
    by = rnd(marginTop, H - marginBottom);
    let ok = true;
    
    // Check distance from shelves
    for (const s of shelves) {
      if (dist(bx, by, s.x, s.y) < 100) {
        ok = false;
        break;
      }
    }
    
    // Check distance from trash can
    if (ok && dist(bx, by, trashCan.x, trashCan.y) < 80) ok = false;
    
    // Check distance from player
    if (ok && dist(bx, by, player.x, player.y) > 80) break;
  }
  
  books.push({
    x: bx,
    y: by,
    type,
    state: 'floor',
    rot: rnd(-0.4, 0.4),
    bobPhase: Math.random() * Math.PI * 2,
    pickupCd: 0
  });
}

// â”€â”€ Spawn Ghost â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnGhost() {
  const edge = rint(0, 3);
  const hudHeight = 28;
  const controlsHeight = 25;
  let gx, gy;
  
  if (edge === 0) { // Top
    gx = rnd(100, W - 100);
    gy = hudHeight + 40;
  } else if (edge === 1) { // Bottom
    gx = rnd(100, W - 100);
    gy = H - controlsHeight - 40;
  } else if (edge === 2) { // Left
    gx = 40;
    gy = rnd(hudHeight + 60, H - controlsHeight - 60);
  } else { // Right
    gx = W - 40;
    gy = rnd(hudHeight + 60, H - controlsHeight - 60);
  }
  
  // Determine ghost type based on wave
  let ghostType = 'NORMAL';
  
  // Boss every 5th wave
  if (wave % 5 === 0 && Math.random() < 0.3) {
    ghostType = 'BOSS';
  } else {
    // Random type selection weighted by wave escalation
    const rand = Math.random();
    
    // Wave 7+ (escalLevel 6+): All enemy types available
    if (escalLevel >= 6) {
      if (rand < 0.08) ghostType = 'MIMIC';
      else if (rand < 0.16) ghostType = 'POSSESSOR';
      else if (rand < 0.24) ghostType = 'SHIELD';
      else if (rand < 0.32) ghostType = 'CHAIN';
      else if (rand < 0.42) ghostType = 'SWARM';
      else if (rand < 0.52) ghostType = 'RANGED';
      else if (rand < 0.62) ghostType = 'BOMBER';
      else if (rand < 0.72) ghostType = 'TELEPORTER';
      else if (rand < 0.82) ghostType = 'TANK';
      else ghostType = 'FAST';
    }
    // Wave 5+ (escalLevel 4+): Add Swarm, Ranged, Bomber
    else if (escalLevel >= 4) {
      if (rand < 0.12) ghostType = 'SWARM';
      else if (rand < 0.24) ghostType = 'RANGED';
      else if (rand < 0.36) ghostType = 'BOMBER';
      else if (rand < 0.50) ghostType = 'TELEPORTER';
      else if (rand < 0.65) ghostType = 'TANK';
      else if (rand < 0.80) ghostType = 'FAST';
      else ghostType = 'NORMAL';
    }
    // Wave 3+ (escalLevel 2+): Original types + variety
    else if (escalLevel >= 2) {
      if (rand < 0.15) ghostType = 'TELEPORTER';
      else if (rand < 0.35) ghostType = 'TANK';
      else if (rand < 0.60) ghostType = 'FAST';
      else ghostType = 'NORMAL';
    }
    // Early waves: Just Fast ghosts
    else if (escalLevel >= 1) {
      if (rand < 0.5) ghostType = 'FAST';
      else ghostType = 'NORMAL';
    }
  }
  
  const type = GHOST_TYPES[ghostType];
  const baseSpeed = currentDifficulty.ghostSpeed * (1 + escalLevel * 0.2);
  
  const newGhost = {
    x: gx,
    y: gy,
    phase: Math.random() * Math.PI * 2,
    alive: true,
    speed: baseSpeed * type.speed,
    type: ghostType,
    typeData: type,
    health: type.health,
    maxHealth: type.health,
    attackCooldown: 0,
    attackTelegraph: 0,
    teleportCooldown: 0,
    spawnAnimation: 1
  };
  
  // Special initialization for specific ghost types
  if (ghostType === 'MIMIC') {
    newGhost.disguised = true;
    newGhost.disguiseType = BOOK_TYPES[rint(0, BOOK_TYPES.length - 1)];
  } else if (ghostType === 'POSSESSOR') {
    newGhost.possessing = false;
    newGhost.possessedShelf = null;
    newGhost.possessionTimer = 0;
  } else if (ghostType === 'SHIELD') {
    newGhost.shieldRotation = Math.random() * Math.PI * 2;
    newGhost.shieldActive = true;
  } else if (ghostType === 'RANGED') {
    newGhost.shootCooldown = type.shootCooldown;
  } else if (ghostType === 'CHAIN') {
    // Chain ghosts spawn in pairs - spawn partner
    spawnChainPair(newGhost, gx, gy);
  }
  
  ghosts.push(newGhost);
}

// â”€â”€ Spawn Chain Ghost Pair â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnChainPair(ghost1, baseX, baseY) {
  const type = GHOST_TYPES.CHAIN;
  const baseSpeed = currentDifficulty.ghostSpeed * (1 + escalLevel * 0.2);
  
  // Spawn partner at offset position
  const angle = Math.random() * Math.PI * 2;
  const ghost2 = {
    x: baseX + Math.cos(angle) * 100,
    y: baseY + Math.sin(angle) * 100,
    phase: Math.random() * Math.PI * 2,
    alive: true,
    speed: baseSpeed * type.speed,
    type: 'CHAIN',
    typeData: type,
    health: type.health,
    maxHealth: type.health,
    attackCooldown: 0,
    attackTelegraph: 0,
    teleportCooldown: 0,
    spawnAnimation: 1,
    chainPartner: ghost1
  };
  
  // Link them together
  ghost1.chainPartner = ghost2;
  
  ghosts.push(ghost2);
}

// â”€â”€ Spawn Power-up â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnPowerup() {
  const types = Object.keys(POWERUP_TYPES);
  const type = types[rint(0, types.length - 1)];
  
  const hudHeight = 28;
  const controlsHeight = 25;
  const marginTop = hudHeight + 100;
  const marginBottom = controlsHeight + 100;
  const marginSide = 100;
  
  let px, py;
  for (let t = 0; t < 60; t++) {
    px = rnd(marginSide, W - marginSide);
    py = rnd(marginTop, H - marginBottom);
    let ok = true;
    
    for (const s of shelves) {
      if (dist(px, py, s.x, s.y) < 100) {
        ok = false;
        break;
      }
    }
    if (ok && dist(px, py, trashCan.x, trashCan.y) < 80) ok = false;
    if (ok) break;
  }
  
  powerups.push({
    x: px,
    y: py,
    type,
    bobPhase: Math.random() * Math.PI * 2,
    pulsePhase: 0
  });
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function burst(x,y,count,color,life,speed=80) {
  for (let i=0; i<count; i++) {
    particles.push({
      x, y,
      vx: rnd(-speed,speed),
      vy: rnd(-speed,speed),
      life,
      maxLife: life,
      color,
      size: rnd(1.5,3.5),
      type: 'square',
      rotation: rnd(0, Math.PI * 2),
      rotationSpeed: rnd(-0.1, 0.1)
    });
  }
}

// Particle type definitions
const PARTICLE_TYPES = {
  SPARKLE: (x, y, color, life = 800) => {
    particles.push({
      x, y,
      vx: rnd(-40, 40),
      vy: rnd(-60, -20),
      life,
      maxLife: life,
      color,
      size: rnd(2, 4),
      type: 'star',
      rotation: rnd(0, Math.PI * 2),
      rotationSpeed: rnd(0.1, 0.3),
      gravity: 0.2
    });
  },
  
  PAGE: (x, y, life = 1200) => {
    particles.push({
      x, y,
      vx: rnd(-80, 80),
      vy: rnd(-100, -40),
      life,
      maxLife: life,
      color: '#f0ebd6',
      size: rnd(3, 6),
      type: 'page',
      rotation: rnd(0, Math.PI * 2),
      rotationSpeed: rnd(-0.2, 0.2),
      gravity: 0.15,
      flutter: Math.random() * Math.PI * 2
    });
  },
  
  DUST: (x, y, direction, life = 600) => {
    const angle = direction * Math.PI / 2;
    particles.push({
      x, y,
      vx: Math.cos(angle + Math.PI) * rnd(80, 120) + rnd(-20, 20),
      vy: Math.sin(angle + Math.PI) * rnd(80, 120) + rnd(-20, 20),
      life,
      maxLife: life,
      color: '#d4c8b0',
      size: rnd(2, 5),
      type: 'circle',
      rotation: 0,
      rotationSpeed: 0,
      friction: 0.92
    });
  },
  
  SHOCKWAVE: (x, y, color, size = 50) => {
    particles.push({
      x, y,
      vx: 0,
      vy: 0,
      life: 400,
      maxLife: 400,
      color,
      size,
      type: 'ring',
      rotation: 0,
      rotationSpeed: 0,
      expandRate: 3
    });
  },
  
  FIREWORK: (x, y, color, life = 1000) => {
    const count = 20;
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      const speed = rnd(100, 150);
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        maxLife: life,
        color,
        size: rnd(2, 4),
        type: 'star',
        rotation: angle,
        rotationSpeed: 0.2,
        gravity: 0.1,
        trail: true
      });
    }
  },
  
  AURA: (x, y, color, radius = 20) => {
    particles.push({
      x: x + rnd(-radius, radius),
      y: y + rnd(-radius, radius),
      vx: rnd(-10, 10),
      vy: rnd(-30, -10),
      life: 800,
      maxLife: 800,
      color,
      size: rnd(1, 3),
      type: 'glow',
      rotation: 0,
      rotationSpeed: 0,
      fadeIn: true
    });
  }
};

// Enhanced special bursts
function specialBurst(x, y, type) {
  switch(type) {
    case 'FILE':
      // Sparkles + pages
      for (let i = 0; i < 12; i++) PARTICLE_TYPES.SPARKLE(x, y, '#f0e840');
      for (let i = 0; i < 8; i++) PARTICLE_TYPES.PAGE(x, y);
      PARTICLE_TYPES.SHOCKWAVE(x, y, '#f0e840', 40);
      break;
      
    case 'COMBO':
      // Firework explosion
      PARTICLE_TYPES.FIREWORK(x, y, '#ff6aaa', 1200);
      PARTICLE_TYPES.SHOCKWAVE(x, y, '#ff6aaa', 60);
      // Extra sparkles for high combos
      for (let i = 0; i < 15; i++) PARTICLE_TYPES.SPARKLE(x, y, '#ffffff');
      break;
      
    case 'POWERUP':
      // Magical burst
      PARTICLE_TYPES.SHOCKWAVE(x, y, '#aa4aff', 50);
      for (let i = 0; i < 20; i++) PARTICLE_TYPES.SPARKLE(x, y, '#aa4aff');
      for (let i = 0; i < 10; i++) PARTICLE_TYPES.SPARKLE(x, y, '#ffffff', 1000);
      break;
      
    case 'WAVE':
      // Celebration explosion
      PARTICLE_TYPES.FIREWORK(x, y, '#2aaa5c', 1500);
      PARTICLE_TYPES.FIREWORK(x + 30, y - 20, '#c8a84a', 1500);
      PARTICLE_TYPES.FIREWORK(x - 30, y - 20, '#4a8cff', 1500);
      PARTICLE_TYPES.SHOCKWAVE(x, y, '#f0e840', 100);
      for (let i = 0; i < 30; i++) PARTICLE_TYPES.SPARKLE(x, y, '#ffffff', 1200);
      break;
  }
}

// â”€â”€ Feedback Label â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addFeedback(x,y,txt,color,size=10) {
  feedbacks.push({ x, y, txt, color, size, life:1200, maxLife:1200 });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UPDATE LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function update(dt) {
  try {
    if (state === 'menu') {
      updateMenu(dt);
      // Clear per-frame input edges
      for (const k in keyDown) keyDown[k]=false;
      for (const k in keyUp) keyUp[k]=false;
      return;
    }
    
    if (state === 'difficulty') {
      updateDifficultySelect(dt);
      // Clear per-frame input edges
      for (const k in keyDown) keyDown[k]=false;
      for (const k in keyUp) keyUp[k]=false;
      return;
    }
    
    if (state === 'paused') {
      updatePaused(dt);
      // Clear per-frame input edges
      for (const k in keyDown) keyDown[k]=false;
      for (const k in keyUp) keyUp[k]=false;
      return;
    }
    
    if (state === 'gameover') {
      updateGameOver(dt);
      // Clear per-frame input edges
      for (const k in keyDown) keyDown[k]=false;
      for (const k in keyUp) keyUp[k]=false;
      return;
    }
    
    // PLAYING state
    if (state === 'play') {
      updatePlaying(dt);
    }
    
    // Clear per-frame input edges at the end
    for (const k in keyDown) keyDown[k]=false;
    for (const k in keyUp) keyUp[k]=false;
  } catch (error) {
    console.error('Error in update loop:', error);
    console.error('State:', state);
    console.error('Particles count:', particles.length);
    console.error('Books count:', books.length);
    console.error('Powerups count:', powerups.length);
    console.error('Ghosts count:', ghosts.length);
    // Don't crash - just log
  }
}

function updateMenu(dt) {
  // Update animations
  updateMenuAnimations(dt);
  
  // Menu navigation
  if (keyDown.arrowup || keyDown.w) {
    menuSelection = Math.max(0, menuSelection - 1);
  }
  if (keyDown.arrowdown || keyDown.s) {
    menuSelection = Math.min(1, menuSelection + 1);
  }
  
  if (keyDown.enter || keyDown[' ']) {
    if (menuSelection === 0) {
      state = 'difficulty';
      menuInitialized = false; // Reset for difficulty screen
    } else if (menuSelection === 1) {
      initGame('ENDLESS');
    }
  }
}

function updateDifficultySelect(dt) {
  const difficulties = ['EASY', 'MEDIUM', 'HARD'];
  let idx = difficulties.indexOf(difficultySelection);
  
  if (keyDown.arrowleft || keyDown.a) {
    idx = Math.max(0, idx - 1);
    difficultySelection = difficulties[idx];
  }
  if (keyDown.arrowright || keyDown.d) {
    idx = Math.min(2, idx + 1);
    difficultySelection = difficulties[idx];
  }
  
  if (keyDown.enter || keyDown[' ']) {
    initGame(difficultySelection);
  }
  
  if (keyDown.escape) {
    state = 'menu';
  }
}

function updatePaused(dt) {
  // ESC to resume
  if (keys.escape && !escWas) {
    state = 'play';
  }
  escWas = keys.escape;
  
  // Enter to quit
  if (keyDown.enter || keyDown[' ']) {
    state = 'menu';
    menuSelection = 0;
  }
}

function updateGameOver(dt) {
  if (keyDown.escape || keyDown.enter || keyDown[' ']) {
    state = 'menu';
    menuSelection = 0;
  }
}

function updatePlaying(dt) {
  // ESC to pause
  if (keys.escape && !escWas) {
    state = 'paused';
  }
  escWas = keys.escape;
  
  // M to toggle mini-map
  if (keyDown.m) {
    miniMapVisible = !miniMapVisible;
  }
  
  // Update screen shake
  if (screenShake > 0) screenShake = Math.max(0, screenShake - dt * 5);
  
  // Time (unless frozen)
  if (!timeFrozen && currentDifficulty.gameTime !== Infinity) {
    timeLeft -= dt / 1000;
    if (timeLeft <= 0) {
      endGame('time');
      return;
    }
  }
  
  // Health regeneration (when no ghosts nearby)
  if (currentDifficulty.healthRegen > 0 && ghosts.length === 0) {
    player.health = Math.min(player.maxHealth, player.health + currentDifficulty.healthRegen * dt / 1000);
  }
  
  // Update environment
  updateEnvironment(dt);
  
  // Update player
  updatePlayer(dt);
  
  // Update books
  for (const book of books) {
    book.bobPhase += dt * 0.003;
    if (book.pickupCd > 0) book.pickupCd -= dt;
    
    // Handle dropping books (tumble physics)
    if (book.state === 'dropping') {
      book.x += book.dropVx * dt / 1000;
      book.y += book.dropVy * dt / 1000;
      book.rot += book.dropSpin;
      
      // Friction
      book.dropVx *= 0.95;
      book.dropVy *= 0.95;
      
      // Stop when slow enough
      if (Math.abs(book.dropVx) < 10 && Math.abs(book.dropVy) < 10) {
        book.state = 'floor';
        book.dropVx = 0;
        book.dropVy = 0;
      }
    }
  }
  
  // Update thrown books
  updateThrownBooks(dt);
  
  // Update ghost projectiles
  updateGhostProjectiles(dt);
  
  // Update charge attack
  updateChargeAttack(dt);
  
  // Update parry window
  if (parryWindow > 0) parryWindow -= dt;
  
  // Update shelves
  for (const shelf of shelves) {
    shelf.glowPulse += dt * 0.005;
    if (shelf.acceptPulse > 0) shelf.acceptPulse -= dt * 0.002;
    if (shelf.possessionWarningCooldown > 0) shelf.possessionWarningCooldown -= dt;
    
    // Completion celebration countdown
    if (shelf.completionCelebration > 0) {
      shelf.completionCelebration -= dt;
    }
    
    // Combo effect decay
    if (shelf.comboPulse > 0) shelf.comboPulse -= dt * 0.003;
    if (shelf.comboBounce > 0) shelf.comboBounce -= dt * 0.003;
    if (shelf.comboDance > 0) shelf.comboDance -= dt;
    if (shelf.comboCelebration > 0) shelf.comboCelebration -= dt;
  }
  
  // Global combo effect decay
  if (window.progressBarGlow > 0) window.progressBarGlow -= dt * 0.002;
  if (window.bookSparkle > 0) window.bookSparkle -= dt;
  if (window.goldenScreen > 0) window.goldenScreen -= dt;
  
  trashCan.glowPulse += dt * 0.005;
  if (trashCan.acceptPulse > 0) trashCan.acceptPulse -= dt * 0.002;
  
  // Update ghosts
  updateGhosts(dt);
  
  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    
    // Safety check - skip null/undefined particles
    if (!p) {
      particles.splice(i, 1);
      continue;
    }
    
    // Apply velocity
    p.x += p.vx * dt / 1000;
    p.y += p.vy * dt / 1000;
    
    // Apply gravity if present
    if (p.gravity) {
      p.vy += p.gravity * dt * 0.1;
    }
    
    // Apply friction if present
    if (p.friction) {
      p.vx *= p.friction;
      p.vy *= p.friction;
    }
    
    // Update rotation
    if (p.rotationSpeed) {
      p.rotation += p.rotationSpeed * dt * 0.01;
    }
    
    // Update flutter for pages
    if (p.flutter !== undefined) {
      p.flutter += dt * 0.01;
    }
    
    // Expand rings
    if (p.expandRate) {
      p.size += p.expandRate * dt * 0.1;
    }
    
    // Decay life
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  // Update feedbacks
  for (let i = feedbacks.length - 1; i >= 0; i--) {
    const f = feedbacks[i];
    f.y -= dt * 0.03;
    f.life -= dt;
    if (f.life <= 0) feedbacks.splice(i, 1);
  }
  
  // Update powerups
  for (const p of powerups) {
    p.bobPhase += dt * 0.003;
    p.pulsePhase += dt * 0.01;
  }
  
  // Combo timer
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
  }
  
  // Flash fade
  if (flashAlpha > 0) flashAlpha = Math.max(0, flashAlpha - dt * 0.003);
  
  // Update UI animations
  updateUI(dt);
  
  // Update camera
  updateCamera(dt);
  
  // Ghost spawning (unless time frozen)
  if (!timeFrozen) {
    ghostTimer -= dt;
    if (ghostTimer <= 0) {
      spawnGhost();
      ghostTimer = currentDifficulty.ghostInterval / (1 + escalLevel * 0.3);
    }
    
    // Escalation
    escalationTimer -= dt;
    if (escalationTimer <= 0) {
      escalLevel++;
      wave++;
      escalationTimer = ESCALATION_MS;
      addFeedback(W/2, H/2 - 50, `WAVE ${wave}`, '#c8a84a', 16);
      specialBurst(W/2, H/2, 'WAVE');
    }
  }
  
  // Active powerup timer
  if (activePowerup && activePowerup.type) {
    activePowerup.remaining -= dt;
    if (activePowerup.remaining <= 0) {
      deactivatePowerup();
    } else {
      // Continuous aura effect for active power-up (only if still active)
      const powerup = POWERUP_TYPES[activePowerup.type];
      if (powerup && Math.random() < 0.15) {
        PARTICLE_TYPES.AURA(player.x, player.y, powerup.color, 25);
      }
      
      // Warning flash when about to expire
      if (activePowerup.remaining < 2000 && Math.floor(activePowerup.remaining / 200) % 2 === 0) {
        PARTICLE_TYPES.SPARKLE(player.x + rnd(-15, 15), player.y + rnd(-15, 15), powerup.color, 300);
      }
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTINUOUS BOOK SPAWNING (Random intervals & types)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (!timeFrozen) {
    bookSpawnTimer += dt;
    if (bookSpawnTimer >= nextBookSpawnTime) {
      spawnBook(); // Already picks random type in function
      bookSpawnTimer = 0;
      // Set next spawn time to random interval
      nextBookSpawnTime = rnd(BOOK_SPAWN_MIN, BOOK_SPAWN_MAX);
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTINUOUS POWERUP SPAWNING (Random intervals & types)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (!timeFrozen) {
    powerupSpawnTimer += dt;
    if (powerupSpawnTimer >= nextPowerupSpawnTime && powerups.length < 3) {
      spawnPowerup(); // Already picks random type in function
      powerupSpawnTimer = 0;
      // Set next spawn time to random interval
      nextPowerupSpawnTime = rnd(POWERUP_SPAWN_MIN, POWERUP_SPAWN_MAX);
    }
  }
}

function updatePlayer(dt) {
  // Input
  let inputX = 0, inputY = 0;
  if (keys.a || keys.arrowleft) inputX -= 1;
  if (keys.d || keys.arrowright) inputX += 1;
  if (keys.w || keys.arrowup) inputY -= 1;
  if (keys.s || keys.arrowdown) inputY += 1;
  
  // Normalize diagonal
  if (inputX !== 0 || inputY !== 0) {
    const [nx, ny] = norm(inputX, inputY);
    inputX = nx;
    inputY = ny;
    
    // Update direction
    if (Math.abs(inputX) > Math.abs(inputY)) {
      player.dir = inputX > 0 ? 1 : 3;
    } else {
      player.dir = inputY > 0 ? 0 : 2;
    }
    
    // Walking animation (4 frames, cycle every 120ms)
    player.walkTimer += dt;
    if (player.walkTimer > 120) {
      player.walkTimer = 0;
      player.walkFrame = (player.walkFrame + 1) % 4;
    }
    player.idleTimer = 0;
  } else {
    // Idle animation
    player.idleTimer += dt;
    player.walkFrame = 0;
  }
  
  // Dash
  if ((keys[' '] || keyDown[' ']) && !player.dashing && player.dashCd <= 0) {
    player.dashing = true;
    player.dashCd = DASH_CD;
    player.dashTimer = DASH_DUR;
    player.dashTrail = []; // Clear trail
    
    // Activate parry window (150ms frame-perfect timing)
    parryWindow = 150;
    
    // Dust cloud on dash start
    for (let i = 0; i < 5; i++) {
      PARTICLE_TYPES.DUST(player.x, player.y + 10, player.dir);
    }
  }
  
  if (player.dashing) {
    player.dashTimer -= dt;
    if (player.dashTimer <= 0) player.dashing = false;
    
    // Add trail positions during dash
    player.dashTrail.push({
      x: player.x,
      y: player.y,
      alpha: 1,
      dir: player.dir
    });
    // Keep only last 8 trail positions
    if (player.dashTrail.length > 8) player.dashTrail.shift();
    
    // Continuous dust trail while dashing
    if (Math.random() < 0.3) {
      PARTICLE_TYPES.DUST(player.x, player.y + 10, player.dir);
    }
  }
  
  // Fade out dash trail
  if (!player.dashing && player.dashTrail.length > 0) {
    for (let i = player.dashTrail.length - 1; i >= 0; i--) {
      player.dashTrail[i].alpha -= dt * 0.008;
      if (player.dashTrail[i].alpha <= 0) {
        player.dashTrail.splice(i, 1);
      }
    }
  }
  
  if (player.dashCd > 0) player.dashCd -= dt;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BOOK THROWING - ENTER Key: Throw at Nearest Ghost
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (keyDown.enter && player.carrying.length > 0) {
    // Find nearest ghost
    let nearestGhost = null;
    let nearestDist = Infinity;
    
    for (const ghost of ghosts) {
      if (ghost && ghost.x && ghost.y) {
        const d = dist(player.x, player.y, ghost.x, ghost.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearestGhost = ghost;
        }
      }
    }
    
    // Throw book at nearest ghost if one exists
    if (nearestGhost) {
      const book = player.carrying.pop(); // Remove from carrying
      
      // Safety check
      if (!book || !book.type) {
        keyDown.enter = false;
        return;
      }
      
      // Calculate direction to ghost
      const dx = nearestGhost.x - player.x;
      const dy = nearestGhost.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const dirX = distance > 0 ? dx / distance : 0;
      const dirY = distance > 0 ? dy / distance : 0;
      
      // Create thrown book
      const throwSpeed = 400; // Pixels per second
      thrownBooks.push({
        x: player.x,
        y: player.y,
        vx: dirX * throwSpeed,
        vy: dirY * throwSpeed,
        type: book.type,
        color: BOOK_COLORS[book.type] || '#ffffff',
        damage: 15, // Good damage for auto-throw
        size: 10,
        rot: 0,
        rotSpeed: 0.2,
        lifetime: 3000, // 3 second lifetime
        trail: []
      });
      
      // Visual feedback
      const bookColor = BOOK_COLORS[book.type] || '#ffffff';
      addFeedback(player.x, player.y - 40, 'THROW!', bookColor, 12);
      
      // Throw particles
      for (let i = 0; i < 8; i++) {
        PARTICLE_TYPES.SPARKLE(player.x, player.y, bookColor, 400);
      }
      
      // Sound effect (visual feedback with screen shake)
      screenShake = 0.3;
    }
    
    keyDown.enter = false; // Prevent repeat
  }
  
  // Book Throwing - Hold Q to throw a book
  if (keys.q && player.carrying.length > 0 && !chargeAttack) {
    if (!player.throwingBook) {
      player.throwingBook = true;
      player.throwCharge = 0;
    }
    player.throwCharge = Math.min(1, player.throwCharge + dt * 0.002); // 500ms for full charge
  } else if (player.throwingBook && !keys.q) {
    // Release - throw the book!
    throwBook();
    player.throwingBook = false;
    player.throwCharge = 0;
  }
  
  // Charged Attack - Hold E to charge radial attack
  if (keys.e && player.carrying.length >= 3 && !chargeAttack && !player.throwingBook) {
    if (!player.chargingAttack) {
      player.chargingAttack = true;
      player.chargeProgress = 0;
    }
    player.chargeProgress = Math.min(1, player.chargeProgress + dt * 0.001); // 1000ms for full charge
    
    // Visual feedback
    if (Math.random() < 0.3) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 30 + player.chargeProgress * 20;
      PARTICLE_TYPES.SPARKLE(
        player.x + Math.cos(angle) * dist,
        player.y + Math.sin(angle) * dist,
        '#f0e840',
        400
      );
    }
  } else if (player.chargingAttack && !keys.e) {
    // Release - activate charge attack!
    if (player.chargeProgress >= 0.5) { // Must charge at least 50%
      activateChargeAttack();
    }
    player.chargingAttack = false;
    player.chargeProgress = 0;
  }
  
  // Calculate speed
  let baseSpeed = currentDifficulty.playerSpeed * player.speedMultiplier;
  const carryLimit = currentDifficulty.carryLimit + player.carryBonus;
  if (player.carrying.length > 0) {
    baseSpeed *= Math.max(0.5, 1 - (player.carrying.length / carryLimit) * 0.3);
  }
  
  const speed = player.dashing ? DASH_SPEED : baseSpeed;
  
  // Movement
  player.vx = inputX * speed;
  player.vy = inputY * speed;
  
  const newX = player.x + player.vx * dt / 1000;
  const newY = player.y + player.vy * dt / 1000;
  
  // Bounds checking with proper margins for HUD and controls
  const hudHeight = 28;
  const controlsHeight = 25;
  const margin = 40;
  
  player.x = clamp(newX, margin, W - margin);
  player.y = clamp(newY, hudHeight + margin, H - controlsHeight - margin);
  
  // Bob
  if (inputX !== 0 || inputY !== 0) {
    player.bobPhase += dt * 0.01;
  }
  
  // Book pickup
  for (const book of books) {
    if (!book || !book.type) continue; // Safety check
    
    if (book.state === 'floor' && book.pickupCd <= 0) {
      // Increased pickup distance - touch any part of book!
      // Book is 32Ã—44, so diagonal is ~53px, use 40px for generous touch
      if (dist(player.x, player.y, book.x, book.y) < 40) {
        const carryLimit = currentDifficulty.carryLimit + player.carryBonus;
        if (player.carrying.length < carryLimit) {
          book.state = 'picking_up';
          book.pickupStartX = book.x;
          book.pickupStartY = book.y;
          book.pickupProgress = 0;
          player.carrying.push(book);
          // Sparkles on pickup
          for (let i = 0; i < 8; i++) {
            PARTICLE_TYPES.SPARKLE(book.x, book.y, BOOK_COLORS[book.type], 400);
          }
        }
      }
    }
    
    // Animate book flying to player
    if (book.state === 'picking_up') {
      book.pickupProgress += dt * 0.006;
      if (book.pickupProgress >= 1) {
        book.state = 'carrying';
      } else {
        // Arc trajectory
        const t = book.pickupProgress;
        const targetX = player.x;
        const targetY = player.y - 20;
        book.x = lerp(book.pickupStartX, targetX, t);
        book.y = lerp(book.pickupStartY, targetY, t) - Math.sin(t * Math.PI) * 30;
        book.rot = t * Math.PI * 2; // Spin while flying
      }
    }
  }
  
  // Powerup pickup - touch any part of the glow!
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    // Powerup has 50px outer glow, use 50px pickup radius
    // Touch any part of the glowing orb to collect it!
    if (dist(player.x, player.y, p.x, p.y) < 50) {
      activatePowerup(p.type);
      powerups.splice(i, 1);
      specialBurst(p.x, p.y, 'POWERUP');
    }
  }
  
  // Auto-sort powerup
  if (player.autoSort && player.carrying.length > 0) {
    autoSortBooks();
  }
  
  // Check filing
  checkFiling();
}

function updateGhosts(dt) {
  if (timeFrozen) return;
  
  for (let i = ghosts.length - 1; i >= 0; i--) {
    const g = ghosts[i];
    if (!g) continue;
    
    g.phase += dt * 0.008;
    
    // Spawn animation
    if (g.spawnAnimation > 0) {
      g.spawnAnimation = Math.max(0, g.spawnAnimation - dt * 0.002);
    }
    
    // Update cooldowns
    if (g.attackCooldown > 0) g.attackCooldown -= dt;
    if (g.teleportCooldown > 0) g.teleportCooldown -= dt;
    
    // Different behaviors based on type
    const distToPlayer = dist(g.x, g.y, player.x, player.y);
    
    switch(g.type) {
      case 'RANGED':
        // Ranged ghost - keeps distance and shoots projectiles
        if (distToPlayer < g.typeData.keepDistance) {
          // Move away from player
          const [dx, dy] = norm(g.x - player.x, g.y - player.y);
          g.x += dx * g.speed * dt / 1000;
          g.y += dy * g.speed * dt / 1000;
        } else if (distToPlayer > g.typeData.keepDistance + 50) {
          // Move toward player if too far
          const [dx, dy] = norm(player.x - g.x, player.y - g.y);
          g.x += dx * g.speed * 0.5 * dt / 1000; // Slower approach
          g.y += dy * g.speed * 0.5 * dt / 1000;
        }
        // else: maintain distance (don't move)
        
        // Shoot projectile at player
        if (distToPlayer < g.typeData.shootRange) {
          if (g.shootCooldown <= 0) {
            shootProjectile(g, player.x, player.y);
            g.shootCooldown = g.typeData.shootCooldown;
          }
        }
        
        // Update cooldown
        if (g.shootCooldown > 0) g.shootCooldown -= dt;
        break;
        
      case 'TELEPORTER':
        // Teleport behavior
        if (distToPlayer > 200 && g.teleportCooldown <= 0) {
          // Teleport closer to player
          const angle = Math.random() * Math.PI * 2;
          const teleportDist = rnd(80, 120);
          g.x = player.x + Math.cos(angle) * teleportDist;
          g.y = player.y + Math.sin(angle) * teleportDist;
          g.teleportCooldown = 3000;
          
          // Teleport effect
          for (let j = 0; j < 10; j++) {
            PARTICLE_TYPES.SPARKLE(g.x, g.y, g.typeData.color, 400);
          }
          PARTICLE_TYPES.SHOCKWAVE(g.x, g.y, g.typeData.color, 30);
        } else {
          // Normal chase
          const [dx, dy] = norm(player.x - g.x, player.y - g.y);
          g.x += dx * g.speed * dt / 1000;
          g.y += dy * g.speed * dt / 1000;
        }
        break;
        
      case 'BOSS':
        // Boss charges up attack
        if (distToPlayer < 150 && g.attackCooldown <= 0) {
          g.attackTelegraph = Math.min(1, g.attackTelegraph + dt * 0.001);
          
          // When fully charged, dash at player
          if (g.attackTelegraph >= 1) {
            const [dx, dy] = norm(player.x - g.x, player.y - g.y);
            g.x += dx * g.speed * 3 * dt / 1000; // 3x speed during charge
            g.y += dy * g.speed * 3 * dt / 1000;
            
            // Reset after 500ms
            if (g.attackTelegraph >= 1.5) {
              g.attackTelegraph = 0;
              g.attackCooldown = 2000;
            } else {
              g.attackTelegraph += dt * 0.001;
            }
          }
        } else {
          // Normal movement
          const [dx, dy] = norm(player.x - g.x, player.y - g.y);
          g.x += dx * g.speed * dt / 1000;
          g.y += dy * g.speed * dt / 1000;
          g.attackTelegraph = 0;
        }
        break;
        
      case 'MIMIC':
        // Mimic ghost - disguised as book until player gets close
        if (g.disguised) {
          // Stationary when disguised
          // Check if player is close enough to reveal
          if (distToPlayer < g.typeData.revealDistance) {
            g.disguised = false;
            g.speed = currentDifficulty.ghostSpeed * g.typeData.chaseSpeed * (1 + escalLevel * 0.2);
            
            // Reveal animation
            PARTICLE_TYPES.SHOCKWAVE(g.x, g.y, '#aa44aa', 40);
            for (let j = 0; j < 8; j++) {
              PARTICLE_TYPES.SPARKLE(g.x, g.y, g.typeData.color, 500);
            }
            addFeedback(g.x, g.y - 20, 'MIMIC!', '#ff2222', 12);
            screenShake = 0.5;
          }
        } else {
          // Chase player aggressively after revealed
          const [dx, dy] = norm(player.x - g.x, player.y - g.y);
          g.x += dx * g.speed * dt / 1000;
          g.y += dy * g.speed * dt / 1000;
        }
        break;
        
      case 'POSSESSOR':
        // Possessor ghost - possesses shelves
        if (g.possessing && g.possessedShelf) {
          // Stay at shelf position
          g.x = g.possessedShelf.x;
          g.y = g.possessedShelf.y;
          
          // Update possession timer
          g.possessionTimer -= dt;
          if (g.possessionTimer <= 0) {
            // Release possession
            g.possessedShelf.possessed = false;
            g.possessedShelf.possessorGhost = null;
            possessedShelves.delete(g.possessedShelf);
            g.possessing = false;
            g.possessedShelf = null;
            
            addFeedback(g.x, g.y - 20, 'RELEASED!', '#aa44aa', 10);
          }
        } else {
          // Look for shelf to possess
          let nearestShelf = null;
          let minDist = Infinity;
          
          for (const shelf of shelves) {
            if (!shelf.possessed) {
              const d = dist(g.x, g.y, shelf.x, shelf.y);
              if (d < g.typeData.possessionRange && d < minDist) {
                minDist = d;
                nearestShelf = shelf;
              }
            }
          }
          
          if (nearestShelf) {
            // Possess it!
            nearestShelf.possessed = true;
            nearestShelf.possessorGhost = g;
            possessedShelves.add(nearestShelf);
            g.possessing = true;
            g.possessedShelf = nearestShelf;
            g.x = nearestShelf.x;
            g.y = nearestShelf.y;
            g.possessionTimer = g.typeData.possessionTime;
            
            // Possession effect
            PARTICLE_TYPES.SHOCKWAVE(g.x, g.y, '#aa44aa', 50);
            for (let j = 0; j < 15; j++) {
              PARTICLE_TYPES.SPARKLE(g.x, g.y, g.typeData.color, 600);
            }
            addFeedback(g.x, g.y - 20, 'POSSESSED!', '#aa44aa', 12);
          } else {
            // Chase player if no shelf to possess
            const [dx, dy] = norm(player.x - g.x, player.y - g.y);
            g.x += dx * g.speed * dt / 1000;
            g.y += dy * g.speed * dt / 1000;
          }
        }
        break;
        
      case 'SHIELD':
        // Shield ghost - rotating shield blocks attacks
        g.shieldRotation += g.typeData.shieldRotationSpeed * dt * 0.01;
        
        // Normal chase
        const [sdx, sdy] = norm(player.x - g.x, player.y - g.y);
        g.x += sdx * g.speed * dt / 1000;
        g.y += sdy * g.speed * dt / 1000;
        break;
        
      case 'CHAIN':
        // Chain ghost - linked to partner
        if (g.chainPartner && g.chainPartner.health > 0) {
          // Normal chase
          const [cdx, cdy] = norm(player.x - g.x, player.y - g.y);
          g.x += cdx * g.speed * dt / 1000;
          g.y += cdy * g.speed * dt / 1000;
          
          // Pull toward partner if too far
          const distToPartner = dist(g.x, g.y, g.chainPartner.x, g.chainPartner.y);
          if (distToPartner > g.typeData.chainDistance) {
            const [pdx, pdy] = norm(g.chainPartner.x - g.x, g.chainPartner.y - g.y);
            g.x += pdx * 50 * dt / 1000;
            g.y += pdy * 50 * dt / 1000;
          }
        } else {
          // Partner dead, act normal
          const [dx, dy] = norm(player.x - g.x, player.y - g.y);
          g.x += dx * g.speed * dt / 1000;
          g.y += dy * g.speed * dt / 1000;
          g.chainPartner = null;
        }
        break;
        
      case 'BOMBER':
        // Bomber ghost - rushes player and explodes
        const [bdx, bdy] = norm(player.x - g.x, player.y - g.y);
        
        // Speed up when close (suicide rush)
        let bomberSpeed = g.speed;
        if (distToPlayer < 150) {
          bomberSpeed *= 1.5; // 50% faster when close
          
          // Start flashing when very close
          if (distToPlayer < 80) {
            g.fuseFlash = (g.fuseFlash || 0) + dt;
          }
        }
        
        g.x += bdx * bomberSpeed * dt / 1000;
        g.y += bdy * bomberSpeed * dt / 1000;
        break;
      
      case 'SWARM':
        // Swarm ghost - normal chase, special death behavior
        const [swdx, swdy] = norm(player.x - g.x, player.y - g.y);
        g.x += swdx * g.speed * dt / 1000;
        g.y += swdy * g.speed * dt / 1000;
        break;
        
      default:
        // Normal chase behavior (NORMAL, FAST, TANK)
        const [dx, dy] = norm(player.x - g.x, player.y - g.y);
        g.x += dx * g.speed * dt / 1000;
        g.y += dy * g.speed * dt / 1000;
        break;
    }
    
    // Repel effect
    if (player.repel && distToPlayer < 80) {
      const [rx, ry] = norm(g.x - player.x, g.y - player.y);
      g.x += rx * 150 * dt / 1000;
      g.y += ry * 150 * dt / 1000;
    }
    
    // Dash Combat - Damage ghosts when dashing through them
    if (player.dashing && distToPlayer < (g.typeData.size + 20)) {
      // Shield ghost blocks from shield direction
      if (g.type === 'SHIELD' && g.shieldActive) {
        const attackAngle = Math.atan2(player.y - g.y, player.x - g.x);
        const shieldAngle = g.shieldRotation;
        let angleDiff = Math.abs(attackAngle - shieldAngle);
        
        // Normalize angle difference
        if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
        
        if (angleDiff < g.typeData.shieldArc / 2) {
          // BLOCKED by shield!
          addFeedback(g.x, g.y - 20, 'BLOCKED!', '#8888cc', 10);
          for (let j = 0; j < 5; j++) {
            PARTICLE_TYPES.SPARKLE(g.x, g.y, '#8888cc', 300);
          }
          screenShake = 0.3;
          continue; // No damage
        }
      }
      
      const dashDamage = 10; // Base dash damage
      g.health -= dashDamage;
      dashKills++; // Track for achievements
      
      // Chain ghost - partner takes shared damage
      if (g.type === 'CHAIN' && g.chainPartner && g.chainPartner.health > 0) {
        const sharedDamage = Math.floor(dashDamage * g.typeData.sharedDamage);
        g.chainPartner.health -= sharedDamage;
        addFeedback(g.chainPartner.x, g.chainPartner.y - 20, `-${sharedDamage}`, '#cc88ff', 8);
        g.chainPartner.damageFlash = 200;
      }
      
      // Knockback
      const [kbx, kby] = norm(g.x - player.x, g.y - player.y);
      g.x += kbx * 100;
      g.y += kby * 100;
      
      // Visual feedback
      addFeedback(g.x, g.y - 20, `-${dashDamage}`, '#4a8cff', 10);
      for (let j = 0; j < 8; j++) {
        PARTICLE_TYPES.SPARKLE(g.x, g.y, '#4a8cff', 400);
      }
      screenShake = 0.4;
      
      if (g.health <= 0) {
        // Handle special ghost death behaviors
        handleGhostDeath(g, 'dash');
        
        // Remove ghost
        ghosts.splice(i, 1);
        continue; // Skip to next ghost
      } else {
        g.damageFlash = 200;
      }
    }
    
    // Parry System - Perfect-timed dash reflects ghost attacks
    if (parryWindow > 0 && distToPlayer < (g.typeData.size + 25)) {
      // Successful parry!
      g.health -= 20; // Double damage on parry
      parryWindow = 0; // Consume parry
      
      // Massive knockback
      const [kbx, kby] = norm(g.x - player.x, g.y - player.y);
      g.x += kbx * 200;
      g.y += kby * 200;
      
      // Epic visual feedback
      addFeedback(player.x, player.y - 30, 'PARRY!', '#f0e840', 14);
      screenShake = 0.8;
      flashAlpha = 0.1;
      chromaticAberration = 5;
      
      for (let j = 0; j < 20; j++) {
        PARTICLE_TYPES.SPARKLE(player.x, player.y, '#f0e840', 600);
      }
      PARTICLE_TYPES.SHOCKWAVE(player.x, player.y, '#f0e840', 60);
      
      if (g.health <= 0) {
        // Handle special ghost death behaviors
        handleGhostDeath(g, 'parry');
        
        // Remove ghost
        ghosts.splice(i, 1);
        continue;
      }
    }
    
    // Collision with player (normal damage)
    if (!player.invincible && distToPlayer < (g.typeData.size + 16)) {
      // Damage based on ghost type
      const damage = g.type === 'BOSS' ? GHOST_DAMAGE * 1.5 : GHOST_DAMAGE;
      player.health -= damage;
      flashAlpha = 0.22;
      screenShake = g.type === 'BOSS' ? 1.5 : 1;
      combo = 0;
      comboTimer = 0;
      
      // Impact shockwave
      PARTICLE_TYPES.SHOCKWAVE(player.x, player.y, '#ff2222', 50);
      
      // Drop books with tumble animation
      for (const book of player.carrying) {
        book.state = 'dropping';
        const angle = Math.random() * Math.PI * 2;
        const force = rnd(80, 150);
        book.dropVx = Math.cos(angle) * force;
        book.dropVy = Math.sin(angle) * force;
        book.dropSpin = rnd(-0.3, 0.3);
        book.x = player.x;
        book.y = player.y;
        book.pickupCd = 500;
        
        // Pages scatter
        for (let j = 0; j < 3; j++) PARTICLE_TYPES.PAGE(book.x, book.y);
      }
      player.carrying = [];
      
      // Damage ghost (reduce health)
      g.health -= 1;
      
      if (g.health <= 0) {
        // Handle special ghost death behaviors
        handleGhostDeath(g, 'collision');
        
        // Remove ghost
        ghosts.splice(i, 1);
      } else {
        // Ghost damaged but not dead (flash)
        g.damageFlash = 200;
      }
      
      // Check player death
      if (player.health <= 0) {
        endGame('health');
        return;
      }
    }
    
    // Update damage flash
    if (g.damageFlash > 0) {
      g.damageFlash -= dt;
    }
    
    // Remove if off-screen
    if (g.x < -50 || g.x > W + 50 || g.y < -50 || g.y > H + 50) {
      ghosts.splice(i, 1);
    }
  }
}

function checkFiling() {
  // Check shelves
  for (const shelf of shelves) {
    if (!shelf || !shelf.type) continue; // Safety check
    
    // Can't file to possessed shelves!
    if (shelf.possessed) {
      // Show feedback if player tries
      // Increased distance - touch any part of shelf!
      // Shelf is 114Ã—72, use 80px for generous touch
      if (dist(player.x, player.y, shelf.x, shelf.y) < 80) {
        if (!shelf.possessionWarningCooldown || shelf.possessionWarningCooldown <= 0) {
          addFeedback(shelf.x, shelf.y - 40, 'POSSESSED!', '#aa44aa', 10);
          shelf.possessionWarningCooldown = 1000;
        }
      }
      continue;
    }
    
    // File books to shelf - touch any part!
    // Shelf is 114Ã—72, use 80px for generous touch
    if (dist(player.x, player.y, shelf.x, shelf.y) < 80) {
      for (let i = player.carrying.length - 1; i >= 0; i--) {
        const book = player.carrying[i];
        if (!book || !book.type) continue; // Safety check
        
        if (book.type === shelf.type) {
          fileBook(book, shelf);
          player.carrying.splice(i, 1);
        }
      }
    }
  }
  
  // Check trash can - touch any part!
  if (dist(player.x, player.y, trashCan.x, trashCan.y) < 60) {
    for (let i = player.carrying.length - 1; i >= 0; i--) {
      const book = player.carrying[i];
      if (!book || !book.type) continue; // Safety check
      
      if (book.type === 'TRASH') {
        fileBook(book, trashCan, true);
        player.carrying.splice(i, 1);
      }
    }
  }
}

function fileBook(book, location, isTrash = false) {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO: SHELF-SPECIFIC BONUS CALCULATIONS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let bonusMultiplier = 1;
  let bonusMessage = null;
  let bonusColor = '#f0e840';
  const currentTime = Date.now();
  
  // Only apply bonuses for non-trash shelves
  if (!isTrash && location.bonusState && location.type) {
    const bonus = location.bonusState;
    
    switch(location.type) {
      case 'FICTION':
        // "Page Turner" - Every 5th book = Double points
        bonus.pageCount = (bonus.pageCount || 0) + 1;
        if (bonus.pageCount >= 5) {
          bonusMultiplier *= 2;
          bonusMessage = 'PAGE TURNER! x2';
          bonusColor = '#ff6aaa';
          bonus.pageCount = 0;
          bonus.pageTurnerReady = false;
          
          // Page flutter particles
          for (let i = 0; i < 8; i++) {
            PARTICLE_TYPES.PAGE(location.x + rnd(-20, 20), location.y + rnd(-20, 20), '#f0ebd6');
          }
        } else if (bonus.pageCount === 4) {
          bonus.pageTurnerReady = true; // Next book gets bonus!
        }
        break;
        
      case 'ROMANCE':
        // "Love Connection" - Filing 2 books within 3 seconds = Combo bonus
        const timeSinceLastRomance = currentTime - (bonus.lastRomanceTime || 0);
        if (timeSinceLastRomance < 3000) {
          bonus.romanceChain = (bonus.romanceChain || 0) + 1;
          bonusMultiplier *= 1.5;
          bonusMessage = 'LOVE CONNECTION! x1.5';
          bonusColor = '#ff6b9d';
          
          // Hearts connect books
          for (let i = 0; i < 5; i++) {
            particles.push({
              x: location.x + rnd(-30, 30),
              y: location.y + rnd(-30, 30),
              vx: 0,
              vy: -40,
              life: 1000,
              maxLife: 1000,
              color: '#ff6b9d',
              size: 5,
              type: 'heart',
              alpha: 1
            });
          }
        } else {
          bonus.romanceChain = 0;
        }
        bonus.lastRomanceTime = currentTime;
        break;
        
      case 'HORROR':
        // "Jump Scare" - Random book gives 3x points
        const slotIndex = location.filedCount % location.capacity;
        
        // Set next jump scare slot if not set
        if (bonus.nextJumpScare === null || bonus.nextJumpScare === slotIndex) {
          if (bonus.nextJumpScare === slotIndex) {
            // JUMP SCARE TRIGGERED!
            bonusMultiplier *= 3;
            bonusMessage = 'JUMP SCARE! x3';
            bonusColor = '#ff4444';
            screenShake = 1.0;
            
            // Skull particles
            for (let i = 0; i < 10; i++) {
              particles.push({
                x: location.x,
                y: location.y,
                vx: rnd(-50, 50),
                vy: rnd(-50, 50),
                life: 800,
                maxLife: 800,
                color: '#d8d8d8',
                size: 6,
                type: 'circle',
                alpha: 0.8
              });
            }
          }
          // Set next random jump scare (3-7 books away)
          bonus.nextJumpScare = slotIndex + rnd(3, 7);
        }
        break;
        
      case 'SCIENCE':
        // "Experiment" - Filing in correct color order = Chain reaction bonus
        const bookColor = BOOK_COLORS[book.type];
        const colorOrder = ['#c24a4a', '#4a8ac2', '#6ac24a', '#c2a44a']; // Red, Blue, Green, Yellow
        const expectedColor = colorOrder[bonus.scienceChain % 4];
        
        if (bookColor === expectedColor || bonus.scienceChain === 0) {
          bonus.scienceChain = (bonus.scienceChain || 0) + 1;
          if (bonus.scienceChain >= 3) {
            bonusMultiplier *= (1 + bonus.scienceChain * 0.2); // Scales with chain
            bonusMessage = `EXPERIMENT! x${(1 + bonus.scienceChain * 0.2).toFixed(1)}`;
            bonusColor = '#4ac28a';
            
            // Bubbling beakers
            for (let i = 0; i < bonus.scienceChain * 2; i++) {
              particles.push({
                x: location.x + rnd(-25, 25),
                y: location.y + 20,
                vx: rnd(-10, 10),
                vy: -30,
                life: 1000,
                maxLife: 1000,
                color: '#4a8ac2',
                size: 4,
                type: 'bubble',
                alpha: 0.6
              });
            }
          }
        } else {
          bonus.scienceChain = 0; // Chain broken!
        }
        bonus.lastScienceColor = bookColor;
        break;
        
      case 'SCIFI':
        // "Warp Speed" - File 3 books fast = Time slowdown power-up
        const timeSinceLastSciFi = currentTime - (bonus.scifiSpeedTimer || 0);
        if (timeSinceLastSciFi < 2000) { // 2 second window
          bonus.scifiSpeed = (bonus.scifiSpeed || 0) + 1;
          if (bonus.scifiSpeed >= 3) {
            bonusMessage = 'WARP SPEED!';
            bonusColor = '#4ac8ff';
            
            // Grant time slowdown power-up
            activePowerup = {
              type: 'FREEZE',
              duration: 5000,
              startTime: Date.now()
            };
            
            // Warp streak particles
            for (let i = 0; i < 20; i++) {
              const angle = (i / 20) * Math.PI * 2;
              particles.push({
                x: location.x,
                y: location.y,
                vx: Math.cos(angle) * 80,
                vy: Math.sin(angle) * 80,
                life: 500,
                maxLife: 500,
                color: '#4ac8ff',
                size: 3,
                type: 'circle',
                alpha: 0.8
              });
            }
            
            bonus.scifiSpeed = 0;
          }
        } else {
          bonus.scifiSpeed = 1;
        }
        bonus.scifiSpeedTimer = currentTime;
        break;
        
      case 'MYSTERY':
        // "Clue Collector" - Filing books reveals hidden point multiplier
        bonus.cluesFound = (bonus.cluesFound || 0) + 1;
        bonus.mysteryMultiplier = 1 + (bonus.cluesFound * 0.1); // +10% per clue
        bonusMultiplier *= bonus.mysteryMultiplier;
        
        if (bonus.cluesFound > 1) {
          bonusMessage = `CLUE #${bonus.cluesFound}! x${bonus.mysteryMultiplier.toFixed(1)}`;
          bonusColor = '#f0e840';
        }
        
        // Fingerprint appears
        particles.push({
          x: location.x + rnd(-20, 20),
          y: location.y + rnd(-20, 20),
          vx: 0,
          vy: -20,
          life: 1500,
          maxLife: 1500,
          color: '#8a9aaa',
          size: 8,
          type: 'circle',
          alpha: 0.5
        });
        break;
        
      case 'TABLETS':
        // "Ancient Wisdom" - Each book = Permanent +1% score multiplier (stacks!)
        bonus.wisdomCount = (bonus.wisdomCount || 0) + 1;
        const wisdomBonus = 1 + (bonus.wisdomCount * 0.01); // +1% per tablet
        scoreMultiplier = wisdomBonus; // Apply globally!
        bonusMultiplier *= wisdomBonus;
        
        if (bonus.wisdomCount > 1) {
          bonusMessage = `ANCIENT WISDOM! x${wisdomBonus.toFixed(2)}`;
          bonusColor = '#c8a84a';
        }
        
        // Ancient hieroglyph symbols cascade
        for (let i = 0; i < 3; i++) {
          particles.push({
            x: location.x + rnd(-20, 20),
            y: location.y - 30,
            vx: 0,
            vy: 20,
            life: 2000,
            maxLife: 2000,
            color: '#8a7a5a',
            size: 8,
            type: 'code',
            alpha: 0.8,
            char: ['âŠ•', 'âŠ—', 'â—Š', 'â—ˆ', 'â—‡', 'â—†'][rint(0, 5)]
          });
        }
        
        // Golden glow (wisdom enlightenment)
        PARTICLE_TYPES.SPARKLE(location.x, location.y - 20, '#c8a84a', 1000);
        break;
        
      case 'MANGA':
        // "Combo Attack" - Every book extends combo timer
        const comboExtension = 1000; // +1 second
        comboTimer += comboExtension;
        bonus.mangaExtension = (bonus.mangaExtension || 0) + comboExtension;
        
        bonusMessage = 'COMBO ATTACK! +1s';
        bonusColor = '#ff6a8a';
        
        // Intensifying speed lines
        for (let i = 0; i < 10; i++) {
          const angle = Math.random() * Math.PI * 2;
          particles.push({
            x: location.x,
            y: location.y,
            vx: Math.cos(angle) * 60,
            vy: Math.sin(angle) * 60,
            life: 400,
            maxLife: 400,
            color: '#4a4a4a',
            size: 2,
            type: 'circle',
            alpha: 0.6
          });
        }
        break;
    }
  }
  
  // Calculate final score with bonuses
  let points = SCORE_BASE;
  if (combo > 0) points *= Math.pow(COMBO_MULT, Math.min(combo, 10));
  points *= scoreMultiplier;
  points *= bonusMultiplier; // Apply shelf bonus!
  points = Math.floor(points);
  
  score += points;
  combo++;
  comboTimer = COMBO_TIMEOUT;
  booksFiledThisGame++;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: COMBO REACTIONS
  // "The world celebrates your skill!"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Track combo state for visual effects
  if (!window.comboState) {
    window.comboState = {
      frenzyMode: false,
      lastComboLevel: 0,
      rainbowPhase: 0
    };
  }
  
  // 3x COMBO - First milestone
  if (combo === 3) {
    // All shelves pulse once
    for (const shelf of shelves) {
      shelf.comboPulse = 1.0; // Will decay in update
    }
    
    // Book shimmer particles
    for (const shelf of shelves) {
      for (let i = 0; i < 3; i++) {
        PARTICLE_TYPES.SPARKLE(
          shelf.x + rnd(-30, 30),
          shelf.y + rnd(-30, 30),
          '#f0e840',
          500
        );
      }
    }
  }
  
  // 5x COMBO - Getting good!
  if (combo === 5) {
    // Shelves bounce excited
    for (const shelf of shelves) {
      shelf.comboBounce = 1.0;
    }
    
    // Progress bars glow (handled in render)
    window.progressBarGlow = 1.0;
    
    // "NICE!" feedback
    addFeedback(W/2, H/2 - 100, 'NICE!', '#4a8cff', 20);
    
    // Sparkle burst
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      PARTICLE_TYPES.SPARKLE(
        W/2 + Math.cos(angle) * 60,
        H/2 - 100 + Math.sin(angle) * 60,
        '#4a8cff',
        800
      );
    }
  }
  
  // 10x COMBO - Impressive!
  if (combo === 10) {
    // Shelves dance (sway handled in render)
    for (const shelf of shelves) {
      shelf.comboDance = 2000; // 2 second dance
    }
    
    // Books sparkle continuously (handled in render)
    window.bookSparkle = 3000; // 3 seconds
    
    // Screen shake
    screenShake = 0.8;
    
    // "AMAZING!" feedback with glow
    addFeedback(W/2, H/2 - 100, 'AMAZING!', '#ff6aaa', 24);
    
    // Firework celebration
    for (let i = 0; i < 6; i++) {
      setTimeout(() => {
        const x = rnd(W * 0.2, W * 0.8);
        const y = rnd(H * 0.2, H * 0.6);
        PARTICLE_TYPES.FIREWORK(x, y, ['#ff6aaa', '#4a8cff', '#f0e840'][i % 3]);
      }, i * 100);
    }
    
    // Golden flash
    flashAlpha = 0.15;
  }
  
  // 15x COMBO - Master level!
  if (combo === 15) {
    // ALL shelves celebrate
    for (const shelf of shelves) {
      shelf.comboCelebration = 3000; // 3 second celebration
      
      // Fireworks from each shelf
      setTimeout(() => {
        PARTICLE_TYPES.FIREWORK(shelf.x, shelf.y - 40, SHELF_GLOW[shelf.type]);
      }, shelves.indexOf(shelf) * 80);
    }
    
    // Screen goes GOLDEN
    window.goldenScreen = 2000; // 2 seconds
    flashAlpha = 0.25;
    screenShake = 1.2;
    
    // "INCREDIBLE!!!" feedback
    addFeedback(W/2, H/2 - 120, 'INCREDIBLE!!!', '#f0e840', 28);
    
    // Massive confetti burst
    for (let i = 0; i < 50; i++) {
      PARTICLE_TYPES.SPARKLE(
        W/2 + rnd(-100, 100),
        H/2 + rnd(-100, 100),
        ['#ff6aaa', '#4a8cff', '#f0e840', '#2aaa5c'][rint(0, 3)],
        1500
      );
    }
    
    // Triple shockwave
    PARTICLE_TYPES.SHOCKWAVE(W/2, H/2, '#f0e840', 120);
    setTimeout(() => PARTICLE_TYPES.SHOCKWAVE(W/2, H/2, '#ff6aaa', 90), 150);
    setTimeout(() => PARTICLE_TYPES.SHOCKWAVE(W/2, H/2, '#4a8cff', 60), 300);
  }
  
  // 20x+ COMBO - LIBRARY FRENZY MODE!!!
  if (combo >= 20) {
    if (!window.comboState.frenzyMode) {
      // Entering FRENZY MODE for first time!
      window.comboState.frenzyMode = true;
      
      // "GOD MODE!!!" announcement
      addFeedback(W/2, H/2 - 140, 'GOD MODE!!!', '#ffffff', 32);
      
      // Massive screen shake
      screenShake = 2.0;
      flashAlpha = 0.3;
      
      // Rainbow explosion from center
      for (let i = 0; i < 100; i++) {
        const angle = (i / 100) * Math.PI * 2;
        const dist = 50 + Math.random() * 100;
        const rainbowColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
        PARTICLE_TYPES.SPARKLE(
          W/2 + Math.cos(angle) * dist,
          H/2 + Math.sin(angle) * dist,
          rainbowColors[i % 6],
          2000
        );
      }
    }
    
    // Continuous frenzy effects
    window.libraryFrenzy = true;
    window.comboState.rainbowPhase = (window.comboState.rainbowPhase || 0) + 0.1;
    
    // Screen pulse with each file in frenzy mode
    flashAlpha = 0.1;
    
    // Random firework on each file
    const fx = rnd(W * 0.2, W * 0.8);
    const fy = rnd(H * 0.2, H * 0.6);
    const rainbowColor = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'][rint(0, 5)];
    PARTICLE_TYPES.FIREWORK(fx, fy, rainbowColor);
  }
  
  // Exit frenzy mode if combo drops
  if (combo < 20 && window.comboState.frenzyMode) {
    window.comboState.frenzyMode = false;
    window.libraryFrenzy = false;
  }
  
  // Show bonus message if earned
  if (bonusMessage) {
    addFeedback(location.x, location.y - 60, bonusMessage, bonusColor, 14);
  }
  
  // Achievement notifications
  if (booksFiledThisGame === 10) {
    showAchievementNotification('Getting Started!', 'Filed 10 books');
  } else if (booksFiledThisGame === 50) {
    showAchievementNotification('Bookworm!', 'Filed 50 books');
  } else if (booksFiledThisGame === 100) {
    showAchievementNotification('Speed Reader!', 'Filed 100 books in one game');
  }
  
  // Remove book
  books.splice(books.indexOf(book), 1);
  
  // Add book to shelf's visual storage (if not trash)
  if (!isTrash && location.storedBooks) {
    const slotIndex = location.filedCount % location.capacity;
    location.storedBooks.push({
      type: book.type,
      color: BOOK_COLORS[book.type],
      slotIndex: slotIndex,
      spawnTime: Date.now(),
      popIn: 1.0 // Pop-in animation (1 â†’ 0)
    });
    location.filedCount++;
    location.lastFiledTime = Date.now();
    
    // Check for completion
    if (location.filedCount >= location.capacity && !location.isComplete) {
      location.isComplete = true;
      location.completionCelebration = 2000; // 2 second celebration
      
      // MASSIVE COMPLETION CELEBRATION (Nintendo style!)
      screenShake = 1.5;
      flashAlpha = 0.25;
      
      // Firework explosion
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const dist = 60 + Math.random() * 20;
        PARTICLE_TYPES.FIREWORK(
          location.x + Math.cos(angle) * dist,
          location.y + Math.sin(angle) * dist,
          SHELF_GLOW[location.type]
        );
      }
      
      // Confetti burst
      for (let i = 0; i < 30; i++) {
        PARTICLE_TYPES.SPARKLE(
          location.x + rnd(-40, 40),
          location.y + rnd(-40, 40),
          ['#ff6aaa', '#4a8cff', '#f0e840', '#2aaa5c'][rint(0, 3)],
          1000
        );
      }
      
      // Triple shockwave
      PARTICLE_TYPES.SHOCKWAVE(location.x, location.y, SHELF_GLOW[location.type], 80);
      setTimeout(() => PARTICLE_TYPES.SHOCKWAVE(location.x, location.y, SHELF_GLOW[location.type], 60), 100);
      setTimeout(() => PARTICLE_TYPES.SHOCKWAVE(location.x, location.y, SHELF_GLOW[location.type], 40), 200);
      
      // Achievement feedback
      addFeedback(location.x, location.y - 80, 'SHELF COMPLETE!', '#f0e840', 16);
      addFeedback(location.x, location.y - 100, 'â˜… PERFECT â˜…', '#ffffff', 12);
      
      // Bonus points
      const bonusPoints = 1000;
      score += bonusPoints;
      addFeedback(location.x, location.y + 40, `+${bonusPoints} BONUS!`, '#2aaa5c', 14);
    }
  }
  
  // Visual feedback
  location.acceptPulse = 1;
  specialBurst(location.x, location.y, 'FILE');
  
  // Combo milestone celebrations
  if (combo === 5) {
    specialBurst(location.x, location.y - 20, 'COMBO');
    addFeedback(location.x, location.y - 70, '5X COMBO!', '#ff6aaa', 14);
    screenShake = 0.5;
  } else if (combo === 10) {
    specialBurst(location.x, location.y - 20, 'COMBO');
    PARTICLE_TYPES.FIREWORK(location.x - 50, location.y - 40, '#4a8cff');
    PARTICLE_TYPES.FIREWORK(location.x + 50, location.y - 40, '#f0e840');
    addFeedback(location.x, location.y - 70, '10X COMBO!!', '#f0e840', 16);
    screenShake = 0.8;
    flashAlpha = 0.15; // Golden flash
  } else if (combo === 15) {
    specialBurst(location.x, location.y - 20, 'COMBO');
    // Triple fireworks
    for (let i = 0; i < 3; i++) {
      PARTICLE_TYPES.FIREWORK(location.x + (i - 1) * 60, location.y - 60, ['#ff6aaa', '#4a8cff', '#2aaa5c'][i]);
    }
    addFeedback(location.x, location.y - 70, '15X MEGA COMBO!!!', '#ffffff', 18);
    screenShake = 1.2;
    flashAlpha = 0.2;
    // Screen border flash effect (handled in render)
  } else if (combo >= 3) {
    specialBurst(location.x, location.y - 20, 'COMBO');
  }
  
  addFeedback(location.x, location.y - 30, `+${points}`, '#f0e840');
  if (combo > 1) {
    addFeedback(location.x, location.y - 50, `${combo}x COMBO!`, '#ff6aaa', 12);
  }
  
  // Spawn replacement
  spawnBook();
  
  // Chance for powerup
  if (Math.random() < 0.15 && powerups.length < 2) {
    spawnPowerup();
  }
}

function autoSortBooks() {
  // Find nearest correct shelf for each book
  for (let i = player.carrying.length - 1; i >= 0; i--) {
    const book = player.carrying[i];
    if (!book || !book.type) continue; // Safety check
    
    let nearestShelf = null;
    let nearestDist = Infinity;
    
    if (book.type === 'TRASH') {
      nearestShelf = trashCan;
      nearestDist = dist(player.x, player.y, trashCan.x, trashCan.y);
    } else {
      for (const shelf of shelves) {
        if (!shelf || !shelf.type) continue; // Safety check
        
        if (shelf.type === book.type) {
          const d = dist(player.x, player.y, shelf.x, shelf.y);
          if (d < nearestDist) {
            nearestDist = d;
            nearestShelf = shelf;
          }
        }
      }
    }
    
    if (nearestShelf && nearestDist < 60) {
      fileBook(book, nearestShelf, book.type === 'TRASH');
      player.carrying.splice(i, 1);
    }
  }
}

function activatePowerup(type) {
  const powerup = POWERUP_TYPES[type];
  
  // Deactivate previous
  if (activePowerup) deactivatePowerup();
  
  activePowerup = {
    type,
    remaining: powerup.duration
  };
  
  // Apply effect
  if (type === 'SPEED') player.speedMultiplier = 2.0; // Increased from 1.6x - SUPER SPEED!
  else if (type === 'MULTICARRY') player.carryBonus = 3;
  else if (type === 'REPEL') {
    player.invincible = true;
    player.repel = true;
  }
  else if (type === 'TIMEFREEZE') timeFrozen = true;
  else if (type === 'AUTOSORT') player.autoSort = true;
  else if (type === 'DOUBLEPOINTS') scoreMultiplier = 2;
  else if (type === 'HEALTH') {
    // Instant health restore!
    const healAmount = powerup.healAmount || 40;
    const oldHealth = player.health;
    player.health = Math.min(player.maxHealth, player.health + healAmount);
    const actualHealed = player.health - oldHealth;
    
    // Show healing feedback
    addFeedback(player.x, player.y - 40, `+${actualHealed} HP`, '#ff4444', 14);
    
    // Healing particles (green + hearts)
    for (let i = 0; i < 30; i++) {
      const angle = (i / 30) * Math.PI * 2;
      particles.push({
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * 60,
        vy: Math.sin(angle) * 60 - 20, // Rise upward
        life: 1000,
        maxLife: 1000,
        color: i % 2 === 0 ? '#44ff44' : '#ff4444',
        size: 4,
        type: i % 3 === 0 ? 'heart' : 'circle',
        alpha: 0.9
      });
    }
    
    // Flash effect (green = healing)
    flashAlpha = 0.2;
    ctx.fillStyle = 'rgba(68, 255, 68, 0.2)';
    
    // No duration for HEALTH (instant effect)
    activePowerup = null;
    return; // Exit early, don't set up duration
  }
  
  addFeedback(player.x, player.y - 40, powerup.label, powerup.color, 10);
  // Power-up activation particles
  for (let i = 0; i < 20; i++) {
    PARTICLE_TYPES.SPARKLE(player.x, player.y, powerup.color, 800);
  }
  PARTICLE_TYPES.SHOCKWAVE(player.x, player.y, powerup.color, 40);
}

function deactivatePowerup() {
  if (!activePowerup) return;
  
  const type = activePowerup.type;
  
  if (type === 'SPEED') player.speedMultiplier = 1;
  else if (type === 'MULTICARRY') player.carryBonus = 0;
  else if (type === 'REPEL') {
    player.invincible = false;
    player.repel = false;
  }
  else if (type === 'TIMEFREEZE') timeFrozen = false;
  else if (type === 'AUTOSORT') player.autoSort = false;
  else if (type === 'DOUBLEPOINTS') scoreMultiplier = 1;
  
  activePowerup = null;
}

function endGame(cause) {
  state = 'gameover';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENVIRONMENT RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderEnvironment() {
  // Floor pattern (checkered tiles)
  const tileSize = 64;
  ctx.fillStyle = '#e8dfcf';
  ctx.fillRect(0, 0, W, H);
  
  // Alternating darker tiles
  ctx.globalAlpha = 0.05;
  for (let x = 0; x < W; x += tileSize) {
    for (let y = 28; y < H - 25; y += tileSize) {
      if ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) {
        ctx.fillStyle = '#d4c8b0';
        ctx.fillRect(x, y, tileSize, tileSize);
      }
    }
  }
  ctx.globalAlpha = 1;
  
  // Day/night ambient lighting overlay
  const dayColor = 'rgba(255, 250, 220, ';
  const nightColor = 'rgba(40, 50, 80, ';
  const dayNightCycle = Math.sin(timeOfDay * Math.PI * 2);
  const isDay = dayNightCycle > 0;
  const intensity = Math.abs(dayNightCycle) * 0.15;
  ctx.fillStyle = (isDay ? dayColor : nightColor) + intensity + ')';
  ctx.fillRect(0, 28, W, H - 53);
}

function renderWindows() {
  for (const win of windows) {
    // Window frame
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(win.x - 2, win.y - 2, win.width + 4, win.height + 4);
    
    // Sky color based on time of day
    const skyGradient = ctx.createLinearGradient(win.x, win.y, win.x, win.y + win.height);
    const dayNightCycle = Math.sin(timeOfDay * Math.PI * 2);
    
    if (dayNightCycle > 0) {
      // Day
      skyGradient.addColorStop(0, '#87CEEB');
      skyGradient.addColorStop(1, '#B0E0E6');
    } else {
      // Night
      skyGradient.addColorStop(0, '#191970');
      skyGradient.addColorStop(1, '#000080');
    }
    
    ctx.fillStyle = skyGradient;
    ctx.fillRect(win.x, win.y, win.width, win.height);
    
    // Window panes
    ctx.strokeStyle = '#6b5844';
    ctx.lineWidth = 2;
    ctx.strokeRect(win.x, win.y, win.width, win.height);
    ctx.beginPath();
    ctx.moveTo(win.x + win.width / 2, win.y);
    ctx.lineTo(win.x + win.width / 2, win.y + win.height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(win.x, win.y + win.height / 2);
    ctx.lineTo(win.x + win.width, win.y + win.height / 2);
    ctx.stroke();
    
    // Sun or moon
    const celestialX = win.x + win.width / 2 + Math.sin(timeOfDay * Math.PI * 2) * 20;
    const celestialY = win.y + win.height / 2 - Math.abs(Math.sin(timeOfDay * Math.PI * 2)) * 10;
    
    if (dayNightCycle > 0) {
      // Sun
      ctx.fillStyle = '#FFD700';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(celestialX, celestialY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else {
      // Moon
      ctx.fillStyle = '#F0F0F0';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(celestialX, celestialY, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
}

function renderLamps() {
  for (const lamp of lamps) {
    // Lamp post
    ctx.fillStyle = '#6b5844';
    ctx.fillRect(lamp.x - 3, lamp.y, 6, 30);
    
    // Lamp shade
    ctx.fillStyle = '#c8a84a';
    ctx.beginPath();
    ctx.moveTo(lamp.x - 12, lamp.y);
    ctx.lineTo(lamp.x + 12, lamp.y);
    ctx.lineTo(lamp.x + 8, lamp.y - 15);
    ctx.lineTo(lamp.x - 8, lamp.y - 15);
    ctx.closePath();
    ctx.fill();
    
    // Light glow (flickers)
    const flicker = Math.sin(lamp.flickerPhase) * 0.1 + 0.9;
    const glowSize = 60 * flicker;
    
    const gradient = ctx.createRadialGradient(lamp.x, lamp.y, 0, lamp.x, lamp.y, glowSize);
    gradient.addColorStop(0, 'rgba(255, 240, 200, 0.3)');
    gradient.addColorStop(0.5, 'rgba(255, 240, 200, 0.1)');
    gradient.addColorStop(1, 'rgba(255, 240, 200, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(lamp.x, lamp.y, glowSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Light bulb
    ctx.fillStyle = '#FFF8DC';
    ctx.globalAlpha = flicker;
    ctx.beginPath();
    ctx.arc(lamp.x, lamp.y - 5, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function renderPlants() {
  for (const plant of plants) {
    const sway = Math.sin(plant.sway) * 2;
    
    // Pot
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(plant.x - 10, plant.y + 10, 20, 15);
    ctx.fillStyle = '#6b3410';
    ctx.fillRect(plant.x - 8, plant.y + 12, 16, 11);
    
    // Leaves
    ctx.fillStyle = '#2d5016';
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const leafX = plant.x + Math.cos(angle) * (8 + i * 2) + sway;
      const leafY = plant.y + Math.sin(angle) * (8 + i * 2);
      
      ctx.beginPath();
      ctx.ellipse(leafX, leafY, 6, 10, angle, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Center stem
    ctx.fillStyle = '#3d6020';
    ctx.fillRect(plant.x - 2 + sway / 2, plant.y - 5, 4, 15);
  }
}

function renderAmbientParticles() {
  ctx.globalAlpha = 0.3;
  for (const p of ambientParticles) {
    const twinkle = Math.sin(p.phase) * 0.3 + 0.7;
    ctx.globalAlpha = 0.3 * twinkle;
    ctx.fillStyle = '#f0ebd6';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function render() {
  try {
    // Clear
    ctx.fillStyle = '#e8dfcf';
    ctx.fillRect(0, 0, W, H);
    
    // Apply camera transform and effects for gameplay
    if (state === 'play' || state === 'paused' || state === 'gameover') {
      ctx.save();
      
      // Apply zoom from center
      ctx.translate(W / 2, H / 2);
      ctx.scale(cameraZoom, cameraZoom);
      ctx.translate(-W / 2, -H / 2);
      
      // Apply only camera shake (no follow)
      ctx.translate(cameraShakeX, cameraShakeY);
    }
    
    if (state === 'menu') renderMenu();
    else if (state === 'difficulty') renderDifficultySelect();
    else if (state === 'play') {
      renderGame();
      ctx.restore(); // Restore before UI
      applyScreenEffects();
    }
    else if (state === 'paused') {
      renderGame();
      ctx.restore(); // Restore before overlay
      applyScreenEffects();
      renderPauseOverlay();
    }
    else if (state === 'gameover') {
      renderGame();
      ctx.restore(); // Restore before overlay
      applyScreenEffects();
      renderGameOver();
    }
  } catch (error) {
    console.error('Error in render loop:', error);
    console.error('Error stack:', error.stack);
    // Try to recover by clearing the canvas
    ctx.fillStyle = '#0a0a14';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#ff2222';
    ctx.font = '12px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('Error occurred - Press ESC', W/2, H/2);
  }
}

// â”€â”€ Apply Screen Effects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyScreenEffects() {
  // Chromatic aberration (RGB split on heavy hits)
  if (chromaticAberration > 0.5) {
    const imageData = ctx.getImageData(0, 0, W, H);
    const data = imageData.data;
    const offset = Math.floor(chromaticAberration);
    
    // Create a copy for manipulation
    const dataCopy = new Uint8ClampedArray(data);
    
    // Red/Blue channel shift
    for (let i = 0; i < data.length; i += 4) {
      const shiftIndex = i + offset * 4;
      const backIndex = i - offset * 4;
      
      // Shift red channel right
      if (shiftIndex < data.length) {
        data[i] = dataCopy[shiftIndex];
      }
      
      // Shift blue channel left
      if (backIndex >= 0) {
        data[i + 2] = dataCopy[backIndex + 2];
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
  }
  
  // Motion blur overlay when dashing
  if (motionBlurAlpha > 0) {
    ctx.globalAlpha = motionBlurAlpha * 0.4;
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }
  
  // Vignette effect (darkened edges at low health)
  if (vignetteIntensity > 0) {
    const gradient = ctx.createRadialGradient(
      W / 2, H / 2, W * 0.2,
      W / 2, H / 2, Math.max(W, H) * 0.7
    );
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(0.5, `rgba(10, 0, 0, ${vignetteIntensity * 0.3})`);
    gradient.addColorStop(1, `rgba(20, 0, 0, ${vignetteIntensity})`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    // Additional red tint at very low health
    if (vignetteIntensity > 0.5) {
      ctx.fillStyle = `rgba(80, 0, 0, ${(vignetteIntensity - 0.5) * 0.2})`;
      ctx.fillRect(0, 0, W, H);
    }
  }
}



function renderMenu() {
  const time = Date.now() * 0.0005;
  
  // Animated gradient background
  const gradient = ctx.createLinearGradient(0, 0, W, H);
  const colorShift = Math.sin(time * 0.5) * 0.1;
  gradient.addColorStop(0, `rgb(${10 + colorShift * 20}, ${10 + colorShift * 20}, ${20 + colorShift * 40})`);
  gradient.addColorStop(0.5, '#1a1a2a');
  gradient.addColorStop(1, `rgb(${10 + colorShift * 20}, ${10 + colorShift * 20}, ${20 + colorShift * 40})`);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  // Starfield background
  for (const star of menuStars) {
    const twinkle = Math.sin(star.twinkle) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.8})`;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Floating book particles in background
  for (let i = 0; i < 15; i++) {
    const x = (W * 0.1 + (i * W * 0.06 + time * 20) % W) % W;
    const y = (H * 0.2 + Math.sin(time + i) * 40 + i * H * 0.05) % H;
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = Object.values(BOOK_COLORS)[i % 9];
    ctx.fillRect(x - 4, y - 6, 8, 12);
    ctx.globalAlpha = 1;
  }
  
  // Large decorative mask behind title
  const maskY = H * 0.25;
  ctx.globalAlpha = 0.1;
  renderLuchadorMask(W/2, maskY, 200, '#d62a2a', '#ffffff', '#2a8c2a');
  ctx.globalAlpha = 1;
  
  // Title with entrance animation
  const titleAnim = menuItemAnimations[0] || { y: 0, alpha: 1 };
  const titleY = H * 0.28 + titleAnim.y;
  const pulse = Math.sin(time * 2) * 0.2 + 0.8;
  
  ctx.globalAlpha = titleAnim.alpha * menuTransitionAlpha;
  
  // Title glow
  ctx.shadowColor = '#c8a84a';
  ctx.shadowBlur = 30 * pulse;
  ctx.fillStyle = '#c8a84a';
  ctx.font = `bold ${Math.min(48, W * 0.06)}px "Press Start 2P"`;
  ctx.textAlign = 'center';
  ctx.fillText('THE LUCHABRARIAN', W/2, titleY);
  ctx.shadowBlur = 0;
  
  // Subtitle
  ctx.font = `${Math.min(14, W * 0.018)}px "Press Start 2P"`;
  ctx.fillStyle = '#8a8a9a';
  ctx.fillText('Defend the Sacred Archive!', W/2, titleY + Math.min(40, H * 0.05));
  
  // Version badge
  ctx.font = `${Math.min(10, W * 0.012)}px "Press Start 2P"`;
  ctx.fillStyle = 'rgba(138, 138, 154, 0.6)';
  ctx.fillText('v2.0 Enhanced - All Features', W/2, titleY + Math.min(65, H * 0.08));
  
  ctx.globalAlpha = 1;
  
  // Decorative books on sides with float animation
  const bookY = titleY - 20;
  for (let i = 0; i < 3; i++) {
    const offset = i * 30;
    const floatY = Math.sin(time + i) * 10;
    ctx.globalAlpha = titleAnim.alpha * 0.8;
    renderMenuBook(W/2 - 250 - offset, bookY + floatY, BOOK_COLORS.ROMANCE);
    renderMenuBook(W/2 + 250 + offset, bookY + Math.sin(time + i + Math.PI) * 10, BOOK_COLORS.SCIFI);
    ctx.globalAlpha = 1;
  }
  
  // Menu options with enhanced boxes
  const options = ['Start Game', 'Endless Mode'];
  const startY = H * 0.55;
  const spacing = Math.min(80, H * 0.1);
  ctx.font = `${Math.min(20, W * 0.025)}px "Press Start 2P"`;
  
  for (let i = 0; i < options.length; i++) {
    const anim = menuItemAnimations[i + 1] || { y: 0, alpha: 1 };
    const y = startY + i * spacing + anim.y;
    const selected = i === menuSelection;
    const boxW = 450;
    const boxH = 60;
    const boxX = W/2 - boxW/2;
    const boxY = y - 40;
    
    ctx.globalAlpha = anim.alpha * menuTransitionAlpha;
    
    // Box background with gradient
    if (selected) {
      // Pulsing selection
      const selectionPulse = Math.sin(time * 4) * 0.1 + 0.9;
      
      // Outer glow
      ctx.shadowColor = '#c8a84a';
      ctx.shadowBlur = 20 * selectionPulse;
      
      const boxGradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxH);
      boxGradient.addColorStop(0, 'rgba(200, 168, 74, 0.3)');
      boxGradient.addColorStop(1, 'rgba(200, 168, 74, 0.1)');
      ctx.fillStyle = boxGradient;
      ctx.fillRect(boxX, boxY, boxW, boxH);
      
      ctx.shadowBlur = 0;
      
      // Animated border
      ctx.strokeStyle = `rgba(200, 168, 74, ${selectionPulse})`;
      ctx.lineWidth = 3;
      ctx.strokeRect(boxX, boxY, boxW, boxH);
      
      // Corner accents
      const cornerSize = 12;
      ctx.fillStyle = '#f0e840';
      // Top left
      ctx.fillRect(boxX - 2, boxY - 2, cornerSize, 3);
      ctx.fillRect(boxX - 2, boxY - 2, 3, cornerSize);
      // Top right
      ctx.fillRect(boxX + boxW - cornerSize + 2, boxY - 2, cornerSize, 3);
      ctx.fillRect(boxX + boxW - 1, boxY - 2, 3, cornerSize);
      // Bottom left
      ctx.fillRect(boxX - 2, boxY + boxH - 1, cornerSize, 3);
      ctx.fillRect(boxX - 2, boxY + boxH - cornerSize + 2, 3, cornerSize);
      // Bottom right
      ctx.fillRect(boxX + boxW - cornerSize + 2, boxY + boxH - 1, cornerSize, 3);
      ctx.fillRect(boxX + boxW - 1, boxY + boxH - cornerSize + 2, 3, cornerSize);
      
      // Selection arrow with bounce
      const arrowBounce = Math.sin(time * 6) * 3;
      ctx.fillStyle = '#f0e840';
      ctx.font = `${Math.min(20, W * 0.025)}px "Press Start 2P"`;
      ctx.textAlign = 'center';
      ctx.fillText('â–¶', boxX - 40, y + 5 + arrowBounce);
      ctx.fillText('â—€', boxX + boxW + 40, y + 5 - arrowBounce);
    } else {
      // Unselected box
      ctx.fillStyle = 'rgba(42, 42, 74, 0.5)';
      ctx.fillRect(boxX, boxY, boxW, boxH);
      
      ctx.strokeStyle = 'rgba(138, 138, 154, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(boxX, boxY, boxW, boxH);
    }
    
    // Option text
    ctx.font = `${Math.min(20, W * 0.025)}px "Press Start 2P"`;
    ctx.fillStyle = selected ? '#f0e840' : '#8a8a9a';
    ctx.textAlign = 'center';
    ctx.fillText(options[i], W/2, y + 5);
    
    ctx.globalAlpha = 1;
  }
  
  // Hints at bottom
  ctx.globalAlpha = menuTransitionAlpha * 0.7;
  ctx.font = `${Math.min(12, W * 0.015)}px "Press Start 2P"`;
  ctx.fillStyle = '#6a6a8a';
  ctx.textAlign = 'center';
  ctx.fillText('â†‘â†“ or W/S: Navigate  |  ENTER or SPACE: Select', W/2, H - 40);
  ctx.globalAlpha = 1;
  
  // Copyright footer
  ctx.font = `${Math.min(10, W * 0.012)}px "Press Start 2P"`;
  ctx.fillStyle = 'rgba(138, 138, 154, 0.4)';
  ctx.fillText('Created with Claude', W/2, H - 15);
}

// Helper function to render decorative menu book
function renderMenuBook(x, y, color) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(0.2);
  ctx.fillStyle = color;
  ctx.fillRect(-8, -12, 16, 24);
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(-9, -12, 1, 24);
  ctx.fillStyle = '#f0ebd6';
  ctx.fillRect(7, -12, 1, 24);
  ctx.restore();
}

// Helper function to render luchador mask
function renderLuchadorMask(x, y, size, primaryColor, secondaryColor, accentColor) {
  const s = size / 24; // scale factor
  
  ctx.save();
  ctx.translate(x, y);
  
  // Main mask shape
  ctx.fillStyle = primaryColor;
  ctx.fillRect(-12*s, -10*s, 24*s, 18*s);
  
  // Top stripe
  ctx.fillStyle = secondaryColor;
  ctx.fillRect(-12*s, -10*s, 24*s, 4*s);
  
  // Accent stripe
  ctx.fillStyle = accentColor;
  ctx.fillRect(-12*s, -6*s, 24*s, 2*s);
  
  // Eye holes
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(-8*s, -2*s, 5*s, 4*s);
  ctx.fillRect(3*s, -2*s, 5*s, 4*s);
  
  // Chin detail
  ctx.fillStyle = secondaryColor;
  ctx.fillRect(-6*s, 4*s, 12*s, 3*s);
  
  ctx.restore();
}

function renderDifficultySelect() {
  // Background with gradient
  const gradient = ctx.createLinearGradient(0, 0, W, H);
  gradient.addColorStop(0, '#0a0a14');
  gradient.addColorStop(0.5, '#1a1a2a');
  gradient.addColorStop(1, '#0a0a14');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  const time = Date.now() * 0.0005;
  
  // Decorative pattern
  for (let i = 0; i < 20; i++) {
    const x = (i * W * 0.05 + time * 30) % W;
    const y = H * 0.1 + Math.sin(time + i * 0.5) * 30;
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#c8a84a';
    ctx.fillRect(x - 2, y - 2, 4, 4);
    ctx.globalAlpha = 1;
  }
  
  // Title
  const titleY = Math.min(100, H * 0.12);
  ctx.shadowColor = '#c8a84a';
  ctx.shadowBlur = 20;
  ctx.fillStyle = '#c8a84a';
  ctx.font = `bold ${Math.min(36, W * 0.045)}px "Press Start 2P"`;
  ctx.textAlign = 'center';
  ctx.fillText('SELECT DIFFICULTY', W/2, titleY);
  ctx.shadowBlur = 0;
  
  ctx.font = `${Math.min(12, W * 0.015)}px "Press Start 2P"`;
  ctx.fillStyle = '#8a8a9a';
  ctx.fillText('Choose your challenge level', W/2, titleY + Math.min(35, H * 0.04));
  
  const difficulties = ['EASY', 'MEDIUM', 'HARD'];
  const labels = ['EASY', 'MEDIUM', 'HARD'];
  const colors = ['#2aaa5c', '#f0e840', '#ff2222'];
  const icons = ['ğŸŒ±', 'âš”ï¸', 'ğŸ”¥'];
  const descs = [
    ['120 seconds', 'Slower ghosts', 'Health regeneration', '4 book carry limit'],
    ['90 seconds', 'Balanced difficulty', 'Standard gameplay', '3 book carry limit'],
    ['60 seconds', 'Fast ghosts', 'No health regen', 'Maximum challenge']
  ];
  
  const cardWidth = Math.min(280, W * 0.25);
  const cardHeight = Math.min(380, H * 0.5);
  const spacing = Math.min(40, W * 0.04);
  const totalWidth = cardWidth * 3 + spacing * 2;
  const startX = W/2 - totalWidth/2;
  const cardY = Math.min(200, H * 0.28);
  
  ctx.font = `${Math.min(16, W * 0.02)}px "Press Start 2P"`;
  
  for (let i = 0; i < 3; i++) {
    const x = startX + i * (cardWidth + spacing);
    const y = cardY;
    const selected = difficultySelection === difficulties[i];
    
    // Card shadow
    if (selected) {
      ctx.fillStyle = 'rgba(200, 168, 74, 0.3)';
      ctx.fillRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8);
    }
    
    // Card background
    const cardGradient = ctx.createLinearGradient(x, y, x, y + cardHeight);
    if (selected) {
      cardGradient.addColorStop(0, 'rgba(42, 42, 74, 0.9)');
      cardGradient.addColorStop(1, 'rgba(26, 26, 46, 0.95)');
    } else {
      cardGradient.addColorStop(0, 'rgba(26, 26, 46, 0.7)');
      cardGradient.addColorStop(1, 'rgba(20, 20, 36, 0.8)');
    }
    ctx.fillStyle = cardGradient;
    ctx.fillRect(x, y, cardWidth, cardHeight);
    
    // Card border
    ctx.strokeStyle = selected ? colors[i] : '#4a4a6a';
    ctx.lineWidth = selected ? 4 : 2;
    ctx.strokeRect(x, y, cardWidth, cardHeight);
    
    // Difficulty icon banner
    ctx.fillStyle = selected ? colors[i] : 'rgba(74, 74, 106, 0.5)';
    ctx.fillRect(x, y, cardWidth, 60);
    
    // Icon
    ctx.font = `${Math.min(36, W * 0.035)}px "Press Start 2P"`;
    ctx.fillStyle = selected ? '#ffffff' : '#8a8a9a';
    ctx.textAlign = 'center';
    ctx.fillText(icons[i], x + cardWidth/2, y + 45);
    
    // Difficulty label
    ctx.font = `bold ${Math.min(18, W * 0.022)}px "Press Start 2P"`;
    ctx.fillStyle = selected ? colors[i] : '#8a8a9a';
    ctx.fillText(labels[i], x + cardWidth/2, y + 100);
    
    // Decorative mask for selected
    if (selected) {
      const maskSize = 60;
      ctx.globalAlpha = 0.15;
      renderLuchadorMask(x + cardWidth/2, y + 160, maskSize, colors[i], '#ffffff', '#ffffff');
      ctx.globalAlpha = 1;
    }
    
    // Description lines
    ctx.font = `${Math.min(9, W * 0.011)}px "Press Start 2P"`;
    ctx.fillStyle = selected ? '#d4d4e4' : '#6a6a7a';
    ctx.textAlign = 'center';
    for (let j = 0; j < descs[i].length; j++) {
      ctx.fillText(descs[i][j], x + cardWidth/2, y + 220 + j * 22);
    }
    
    // Animated selection indicator
    if (selected) {
      const bounce = Math.sin(time * 6) * 5;
      ctx.fillStyle = colors[i];
      ctx.font = `${Math.min(20, W * 0.025)}px "Press Start 2P"`;
      ctx.fillText('â–¼', x + cardWidth/2, y - 20 + bounce);
      ctx.fillText('â–²', x + cardWidth/2, y + cardHeight + 35 - bounce);
    }
    
    // "SELECTED" badge
    if (selected) {
      const badgeY = y + cardHeight - 40;
      ctx.fillStyle = colors[i];
      ctx.fillRect(x + 20, badgeY, cardWidth - 40, 30);
      ctx.fillStyle = '#1a1a2a';
      ctx.font = `bold ${Math.min(11, W * 0.014)}px "Press Start 2P"`;
      ctx.fillText('< SELECTED >', x + cardWidth/2, badgeY + 20);
    }
  }
  
  // Instructions at bottom
  const instructY = H - Math.min(80, H * 0.1);
  ctx.font = `${Math.min(13, W * 0.016)}px "Press Start 2P"`;
  ctx.fillStyle = '#8a8a9a';
  ctx.textAlign = 'center';
  ctx.fillText('â† / â†’ to select difficulty', W/2, instructY);
  
  const blink = Math.sin(time * 4) > 0;
  ctx.fillStyle = blink ? '#f0e840' : '#6a6a8a';
  ctx.fillText('ENTER to start', W/2, instructY + 25);
  
  ctx.fillStyle = '#6a6a8a';
  ctx.fillText('ESC to go back', W/2, instructY + 50);
  
  // Decorative elements
  ctx.globalAlpha = 0.2;
  renderLuchadorMask(60, 60, 35, '#d62a2a', '#ffffff', '#2a8c2a');
  renderLuchadorMask(W - 60, 60, 35, '#2e5cc0', '#ffffff', '#f0e840');
  ctx.globalAlpha = 1;
}

function renderGame() {
  // Render environment (floor, windows, ambient lighting)
  renderEnvironment();
  
  // Ambient dust particles (in background)
  renderAmbientParticles();
  
  // Windows showing outside
  renderWindows();
  
  // Decorative lamps
  renderLamps();
  
  // Potted plants
  renderPlants();
  
  // Shelves
  for (const shelf of shelves) {
    if (shelf) renderShelf(shelf);
  }
  
  // Trash can
  renderTrashCan(trashCan);
  
  // Books on floor
  for (const book of books) {
    if (book && (book.state === 'floor' || book.state === 'dropping' || book.state === 'picking_up')) {
      renderBook(book);
    }
  }
  
  // Powerups
  for (const p of powerups) {
    if (p) renderPowerup(p);
  }
  
  // Particles
  for (const p of particles) {
    if (p) renderParticle(p);
  }
  
  // Ghosts
  for (const g of ghosts) renderGhost(g);
  
  // Thrown books
  for (const book of thrownBooks) {
    // Trail
    for (const t of book.trail) {
      if (t.alpha > 0) {
        ctx.globalAlpha = t.alpha * 0.3;
        ctx.fillStyle = book.color;
        ctx.fillRect(t.x - 3, t.y - 3, 6, 6);
      }
    }
    ctx.globalAlpha = 1;
    
    // Book
    ctx.save();
    ctx.translate(book.x, book.y);
    ctx.rotate(book.rot);
    ctx.fillStyle = book.color;
    ctx.fillRect(-book.size/2, -book.size/2, book.size, book.size);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-book.size/2, -book.size/2, 1, book.size);
    ctx.restore();
  }
  
  // Ghost projectiles
  for (const proj of ghostProjectiles) {
    // Trail
    for (const t of proj.trail) {
      if (t.alpha > 0) {
        ctx.globalAlpha = t.alpha * 0.4;
        ctx.fillStyle = proj.color;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
    
    // Projectile orb
    ctx.fillStyle = proj.color;
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner glow
    const gradient = ctx.createRadialGradient(
      proj.x - 2, proj.y - 2, 0,
      proj.x, proj.y, proj.size
    );
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Outer glow if reflected
    if (proj.reflected) {
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#f0e840';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, proj.size + 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }
  
  // Charge attack
  if (chargeAttack) {
    // Expanding ring
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = '#f0e840';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(chargeAttack.x, chargeAttack.y, chargeAttack.radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner glow
    const gradient = ctx.createRadialGradient(
      chargeAttack.x, chargeAttack.y, 0,
      chargeAttack.x, chargeAttack.y, chargeAttack.radius
    );
    gradient.addColorStop(0, 'rgba(240, 232, 64, 0.3)');
    gradient.addColorStop(1, 'rgba(240, 232, 64, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(
      chargeAttack.x - chargeAttack.radius,
      chargeAttack.y - chargeAttack.radius,
      chargeAttack.radius * 2,
      chargeAttack.radius * 2
    );
    ctx.globalAlpha = 1;
  }
  
  // Player
  renderPlayer();
  
  // Feedbacks
  for (const f of feedbacks) {
    const alpha = f.life / f.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = f.color;
    ctx.font = `${f.size}px "Press Start 2P"`;
    ctx.textAlign = 'center';
    ctx.fillText(f.txt, f.x, f.y);
    ctx.globalAlpha = 1;
  }
  
  // HUD
  renderHUD();
  
  // Flash
  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(255, 60, 60, ${flashAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: COMBO SCREEN EFFECTS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // 15x COMBO - Golden Screen
  if (window.goldenScreen > 0) {
    const goldenIntensity = window.goldenScreen / 2000;
    ctx.fillStyle = `rgba(240, 232, 64, ${goldenIntensity * 0.3})`;
    ctx.fillRect(0, 0, W, H);
    
    // Golden particles across screen
    const goldenPhase = (2000 - window.goldenScreen) * 0.01;
    for (let i = 0; i < 20; i++) {
      const px = (W / 20) * i + Math.sin(goldenPhase + i) * 30;
      const py = Math.sin(goldenPhase * 2 + i * 0.5) * H * 0.5 + H * 0.5;
      ctx.fillStyle = '#f0e840';
      ctx.globalAlpha = goldenIntensity * 0.6;
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  
  // 10x COMBO - Book Sparkle
  if (window.bookSparkle > 0) {
    // Sparkle particles on all shelves
    if (Math.random() < 0.3) {
      for (const shelf of shelves) {
        if (Math.random() < 0.5) {
          PARTICLE_TYPES.SPARKLE(
            shelf.x + rnd(-30, 30),
            shelf.y + rnd(-30, 30),
            '#f0e840',
            500
          );
        }
      }
    }
  }
  
  // 20x+ FRENZY MODE - Rainbow Screen Pulse
  if (window.libraryFrenzy) {
    const frenzyPulse = Math.sin(Date.now() * 0.025) * 0.5 + 0.5;
    const rainbowHue = (Date.now() * 0.1) % 360;
    ctx.fillStyle = `hsla(${rainbowHue}, 100%, 60%, ${frenzyPulse * 0.15})`;
    ctx.fillRect(0, 0, W, H);
    
    // Rainbow border (thicker in frenzy)
    ctx.strokeStyle = `hsl(${rainbowHue}, 100%, 60%)`;
    ctx.globalAlpha = frenzyPulse;
    ctx.lineWidth = 12;
    ctx.strokeRect(6, 6, W - 12, H - 12);
    ctx.globalAlpha = 1;
  }
  
  // Combo milestone screen border flash (standard combos)
  if (combo >= 10 && combo < 20) {
    const borderPulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.3;
    const borderColor = combo >= 15 ? '#f0e840' : combo >= 10 ? '#ff6aaa' : '#4a8cff';
    ctx.strokeStyle = borderColor;
    ctx.globalAlpha = borderPulse;
    ctx.lineWidth = 8;
    ctx.strokeRect(4, 4, W - 8, H - 8);
    ctx.globalAlpha = 1;
  }
}

function renderShelf(shelf) {
  if (!shelf || !shelf.type) return; // Safety check
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: BREATHING & PERSONALITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const time = Date.now();
  const shelfID = shelves.indexOf(shelf);
  
  // Subtle floating/breathing motion (different phase per shelf)
  const breatheY = Math.sin(time * 0.002 + shelfID * 0.5) * 2;
  const breatheScale = 1 + Math.sin(time * 0.0015 + shelfID * 0.3) * 0.01; // Tiny scale pulse
  
  // Apply breathing to shelf position
  let x = shelf.x;
  let y = shelf.y + breatheY;
  const shelfW = 114;  // Increased from 76 (1.5x)
  const shelfH = 72;   // Increased from 48 (1.5x)
  const depth = 12;    // Increased from 8
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: PROXIMITY REACTIONS
  // "Shelves notice you!"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Calculate distance to player
  const dx = player.x - x;
  const dy = player.y - y;
  const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);
  
  // Proximity thresholds
  const CLOSE_DISTANCE = 80;  // When shelf "notices" player
  const VERY_CLOSE = 50;      // When shelf gets excited
  
  // Proximity factor (0 = far, 1 = very close)
  const proximityFactor = Math.max(0, Math.min(1, (CLOSE_DISTANCE - distanceToPlayer) / CLOSE_DISTANCE));
  
  // Check if carrying matching book
  let shouldGlow = false;
  let carryingMatchingBook = false;
  for (const book of player.carrying) {
    if (book && book.type === shelf.type) {
      shouldGlow = true;
      carryingMatchingBook = true;
      break;
    }
  }
  
  // â•â•â• PROXIMITY EFFECTS â•â•â•
  
  // 1. LEAN FORWARD when player approaches
  const leanAngle = proximityFactor * 0.08; // Up to ~4.5 degrees
  const leanDirection = dx / CLOSE_DISTANCE; // Lean toward player
  
  // 2. BRIGHTNESS increase for books
  const brightnessBoost = 1 + proximityFactor * 0.15; // Up to +15% brightness
  
  // 3. SCALE increase
  const proximityScale = 1 + proximityFactor * 0.05; // Up to +5% size
  
  // 4. PARTICLE INTENSITY increase
  const particleChanceMultiplier = 1 + proximityFactor * 2; // Up to 3x spawn rate
  
  // 5. EXCITED PULSE when carrying matching book
  let excitementScale = 1;
  let pullingMotion = 0;
  if (carryingMatchingBook) {
    const excitementPulse = Math.sin(time * 0.015) * 0.5 + 0.5;
    excitementScale = 1 + excitementPulse * 0.08; // Excited bouncing
    
    // Gentle pulling motion (shelf "reaches" toward player)
    pullingMotion = Math.sin(time * 0.01) * 3 * proximityFactor;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: COMBO REACTION TRANSFORMATIONS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let comboScale = 1;
  let comboDanceOffset = 0;
  let comboPulseGlow = 0;
  
  // 3x COMBO - Pulse
  if (shelf.comboPulse > 0) {
    const pulseAmount = shelf.comboPulse * 0.15;
    comboScale += pulseAmount;
    comboPulseGlow = shelf.comboPulse * 0.3;
  }
  
  // 5x COMBO - Bounce
  if (shelf.comboBounce > 0) {
    const bounceY = Math.sin(shelf.comboBounce * Math.PI * 4) * 8;
    y += bounceY * shelf.comboBounce;
    comboScale += shelf.comboBounce * 0.1;
  }
  
  // 10x COMBO - Dance (sway left-right)
  if (shelf.comboDance > 0) {
    const dancePhase = (2000 - shelf.comboDance) * 0.008;
    comboDanceOffset = Math.sin(dancePhase) * 15;
  }
  
  // 15x COMBO - Celebration
  if (shelf.comboCelebration > 0) {
    const celebPhase = (3000 - shelf.comboCelebration) * 0.01;
    comboDanceOffset += Math.sin(celebPhase) * 20;
    comboScale += Math.sin(celebPhase * 2) * 0.2;
  }
  
  // 20x+ COMBO - FRENZY MODE (rainbow glow)
  let rainbowGlow = null;
  if (window.libraryFrenzy) {
    const rainbowPhase = (window.comboState?.rainbowPhase || 0) + shelves.indexOf(shelf) * 0.5;
    const hue = (rainbowPhase * 60) % 360;
    rainbowGlow = `hsl(${hue}, 100%, 60%)`;
    
    // Frenzy pulse
    const frenzyPulse = Math.sin(time * 0.02) * 0.1 + 0.9;
    comboScale *= frenzyPulse;
  }
  
  // Apply transformations
  ctx.save();
  ctx.translate(x + pullingMotion * leanDirection + comboDanceOffset, y);
  ctx.rotate(leanAngle * leanDirection);
  ctx.scale(proximityScale * excitementScale * comboScale, proximityScale * excitementScale * comboScale);
  ctx.translate(-x, -y);
  
  // â•â•â• COMBO PULSE GLOW â•â•â•
  if (comboPulseGlow > 0) {
    ctx.globalAlpha = comboPulseGlow;
    ctx.fillStyle = SHELF_GLOW[shelf.type];
    ctx.beginPath();
    ctx.arc(x, y, 60, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  // â•â•â• FRENZY MODE RAINBOW GLOW â•â•â•
  if (rainbowGlow) {
    const frenzyPulse = Math.sin(time * 0.015 + shelves.indexOf(shelf)) * 0.3 + 0.7;
    ctx.globalAlpha = frenzyPulse * 0.4;
    ctx.fillStyle = rainbowGlow;
    ctx.fillRect(x - 50, y - 40, 100, 80);
    
    // Rainbow ring
    ctx.strokeStyle = rainbowGlow;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x, y, 55 + frenzyPulse * 5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // â•â•â• PROXIMITY GLOW RING â•â•â•
  if (proximityFactor > 0.3 && !carryingMatchingBook) {
    ctx.globalAlpha = proximityFactor * 0.2;
    ctx.strokeStyle = SHELF_GLOW[shelf.type] || '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 60, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO MAGIC: PROMINENT MATCHING BOOK GLOW
  // "Where does this book go? THE SHELF SHOWS YOU!"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (shouldGlow) {
    const pulse = Math.sin(shelf.glowPulse) * 0.3 + 0.7;
    const strongPulse = Math.sin(shelf.glowPulse * 2) * 0.5 + 0.5;
    const glowColor = SHELF_GLOW[shelf.type];
    
    // LARGE OUTER GLOW (very visible from distance)
    ctx.globalAlpha = 0.4 * pulse;
    ctx.fillStyle = glowColor;
    ctx.fillRect(x - 70, y - 60, 140, 120);
    
    // MEDIUM GLOW LAYER (builds intensity)
    ctx.globalAlpha = 0.6 * pulse;
    ctx.fillStyle = glowColor;
    ctx.fillRect(x - 55, y - 45, 110, 90);
    
    // BRIGHT CORE GLOW (high intensity center)
    const glowIntensity = 0.7 + proximityFactor * 0.3;
    ctx.globalAlpha = glowIntensity * pulse;
    ctx.fillStyle = glowColor;
    ctx.fillRect(x - 45, y - 35, 90, 70);
    
    // PULSING RING 1 (outer)
    ctx.strokeStyle = glowColor;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.7 * strongPulse;
    ctx.beginPath();
    ctx.arc(x, y, 65 + strongPulse * 10, 0, Math.PI * 2);
    ctx.stroke();
    
    // PULSING RING 2 (middle)
    ctx.lineWidth = 5;
    ctx.globalAlpha = 0.8 * pulse;
    ctx.beginPath();
    ctx.arc(x, y, 50 + pulse * 8, 0, Math.PI * 2);
    ctx.stroke();
    
    // PULSING RING 3 (inner - strongest)
    ctx.lineWidth = 6;
    ctx.globalAlpha = 0.9 * strongPulse;
    ctx.beginPath();
    ctx.arc(x, y, 35 + strongPulse * 5, 0, Math.PI * 2);
    ctx.stroke();
    
    // RADIAL GLOW RAYS (dramatic effect)
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 + shelf.glowPulse * 0.5;
      const rayLength = 20 + strongPulse * 10;
      
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.4 * pulse;
      ctx.beginPath();
      ctx.moveTo(x + Math.cos(angle) * 40, y + Math.sin(angle) * 40);
      ctx.lineTo(x + Math.cos(angle) * (40 + rayLength), y + Math.sin(angle) * (40 + rayLength));
      ctx.stroke();
    }
    
    // SPARKLE PARTICLES (constantly spawning when carrying book)
    if (Math.random() < 0.15) { // 15% chance per frame
      const sparkleAngle = Math.random() * Math.PI * 2;
      const sparkleDistance = 40 + Math.random() * 20;
      PARTICLE_TYPES.SPARKLE(
        x + Math.cos(sparkleAngle) * sparkleDistance,
        y + Math.sin(sparkleAngle) * sparkleDistance,
        glowColor,
        800
      );
    }
    
    // Extra excited glow when close
    if (proximityFactor > 0.5) {
      // MASSIVE PROXIMITY RING
      ctx.globalAlpha = proximityFactor * 0.5 * pulse;
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.arc(x, y, 70 + pulse * 10, 0, Math.PI * 2);
      ctx.stroke();
      
      // BRIGHT FLASH when very close
      ctx.globalAlpha = (proximityFactor - 0.5) * 2 * strongPulse * 0.3;
      ctx.fillStyle = glowColor;
      ctx.fillRect(x - 60, y - 50, 120, 100);
    }
    
    ctx.globalAlpha = 1;
  }
  
  // â•â•â• BEAM OF LIGHT when carrying matching book and close â•â•â•
  if (carryingMatchingBook && proximityFactor > 0.3) {
    const beamAlpha = proximityFactor * 0.5; // Increased from 0.4
    const gradient = ctx.createLinearGradient(x, y, player.x, player.y);
    gradient.addColorStop(0, SHELF_GLOW[shelf.type] + 'AA'); // Brighter start
    gradient.addColorStop(0.5, SHELF_GLOW[shelf.type] + '60'); // Brighter middle
    gradient.addColorStop(1, SHELF_GLOW[shelf.type] + '00');
    
    ctx.globalAlpha = beamAlpha * Math.sin(time * 0.01) * 0.5 + 0.5;
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(player.x, player.y);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Possessed shelf - purple pulsing danger indicator
  if (shelf.possessed) {
    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
    ctx.globalAlpha = pulse * 0.6;
    ctx.fillStyle = '#aa44aa';
    ctx.fillRect(x - 50, y - 40, 100, 80);
    
    // Warning ring
    ctx.strokeStyle = '#ff44aa';
    ctx.lineWidth = 3;
    ctx.globalAlpha = pulse * 0.8;
    ctx.beginPath();
    ctx.arc(x, y, 45, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Acceptance pulse
  if (shelf.acceptPulse > 0) {
    ctx.globalAlpha = shelf.acceptPulse * 0.6;
    ctx.fillStyle = SHELF_GLOW[shelf.type];
    const r = 40 + (1 - shelf.acceptPulse) * 40;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.globalAlpha = shelf.acceptPulse * 0.3;
    ctx.beginPath();
    ctx.arc(x, y, r + 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  // Shadow (all shelves)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
  ctx.fillRect(x - shelfW/2 + 2, y - shelfH/2 + 50, shelfW, 6);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER UNIQUE SHELF BASED ON TYPE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  switch(shelf.type) {
    
    // â”€â”€â”€ FICTION: Elegant Library Shelf â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'FICTION':
      // Polished oak wood
      ctx.fillStyle = '#c8945a';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Gold trim border
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 2;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Elegant shelves
      ctx.fillStyle = '#a8743a';
      ctx.fillRect(x - shelfW/2 + 2, y - shelfH/2 + 14, shelfW - 4, 2);
      ctx.fillRect(x - shelfW/2 + 2, y, shelfW - 4, 2);
      ctx.fillRect(x - shelfW/2 + 2, y + shelfH/2 - 16, shelfW - 4, 2);
      
      // Decorative carved pattern
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const py = y - shelfH/2 + 7 + i * 14;
        ctx.beginPath();
        ctx.moveTo(x - 10, py);
        ctx.quadraticCurveTo(x, py - 3, x + 10, py);
        ctx.stroke();
      }
      
      // Varied fiction books
      const fictionBooks = [
        {x: -30, w: 5, h: 10, color: '#c24a4a'},
        {x: -20, w: 4, h: 12, color: '#4a8ac2'},
        {x: -14, w: 6, h: 9, color: '#6ac24a'},
        {x: -5, w: 5, h: 11, color: '#c2a44a'},
        {x: 5, w: 4, h: 8, color: '#9a4ac2'},
        {x: 12, w: 7, h: 10, color: '#c24a8a'},
        {x: 22, w: 5, h: 13, color: '#4ac2a4'}
      ];
      
      for (const book of fictionBooks) {
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.5;
        ctx.fillRect(x + book.x, y + shelfH/2 - 16 - book.h, book.w, book.h);
        // Book spine
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x + book.x, y + shelfH/2 - 16 - book.h, 1, book.h);
      }
      ctx.globalAlpha = 1;
      
      // Small decorative quill
      ctx.strokeStyle = '#8a6a3a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 30, y - 20);
      ctx.lineTo(x + 32, y - 10);
      ctx.stroke();
      break;
      
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROMANCE SHELF - ULTIMATE ROMANTIC ENHANCEMENT V2
    // Every detail screams LOVE - Nintendo AAA+ Quality
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'ROMANCE':
      // Soft pink/rose wood background with texture
      ctx.fillStyle = '#f4d8e8';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Wood grain texture (subtle)
      ctx.strokeStyle = '#e8c8d8';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 8; i++) {
        const grainY = y - shelfH/2 + i * 9;
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, grainY);
        ctx.lineTo(x + shelfW/2, grainY);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Decorative gradient overlay (radial from center)
      const romanceRadialGrad = ctx.createRadialGradient(x, y, 0, x, y, shelfW/2);
      romanceRadialGrad.addColorStop(0, 'rgba(255, 240, 250, 0.6)');
      romanceRadialGrad.addColorStop(0.7, 'rgba(255, 220, 240, 0.3)');
      romanceRadialGrad.addColorStop(1, 'rgba(200, 150, 180, 0.4)');
      ctx.fillStyle = romanceRadialGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Lace doily pattern background (delicate)
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.15;
      // Center doily
      for (let r = 0; r < 4; r++) {
        ctx.beginPath();
        ctx.arc(x, y, 15 + r * 8, 0, Math.PI * 2);
        ctx.stroke();
      }
      // Doily spokes
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 35, y + Math.sin(angle) * 35);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Subtle sparkle overlay pattern
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      for (let i = 0; i < 12; i++) {
        const sparkleX = x - shelfW/2 + 10 + (i % 4) * 28;
        const sparkleY = y - shelfH/2 + 10 + Math.floor(i / 4) * 20;
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, 1.2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Rose gold ornate border (triple layer)
      ctx.strokeStyle = '#e8a8b8';
      ctx.lineWidth = 5;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      ctx.strokeStyle = '#ff8aaa';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.6;
      ctx.strokeRect(x - shelfW/2 + 2, y - shelfH/2 + 2, shelfW - 4, shelfH - 4);
      
      ctx.strokeStyle = '#ff6b9d';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      ctx.strokeRect(x - shelfW/2 + 5, y - shelfH/2 + 5, shelfW - 10, shelfH - 10);
      ctx.globalAlpha = 1;
      
      // Decorative corner flourishes (ornate)
      const corners = [
        {x: x - shelfW/2 + 10, y: y - shelfH/2 + 10, angle: 0},
        {x: x + shelfW/2 - 10, y: y - shelfH/2 + 10, angle: Math.PI/2},
        {x: x - shelfW/2 + 10, y: y + shelfH/2 - 10, angle: -Math.PI/2},
        {x: x + shelfW/2 - 10, y: y + shelfH/2 - 10, angle: Math.PI}
      ];
      for (const corner of corners) {
        ctx.save();
        ctx.translate(corner.x, corner.y);
        ctx.rotate(corner.angle);
        
        // Ornate swirl
        ctx.strokeStyle = '#ff6b9d';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI);
        ctx.stroke();
        
        // Corner heart
        ctx.fillStyle = '#ff6b9d';
        ctx.beginPath();
        ctx.moveTo(0, -2);
        ctx.arc(-1, -3, 1, 0, Math.PI, true);
        ctx.arc(1, -3, 1, 0, Math.PI, true);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• TOP: Hearts Garland with Ribbon â•â•â•
      ctx.fillStyle = '#ff6b9d';
      ctx.globalAlpha = 0.7;
      for (let i = 0; i < 8; i++) {
        const hx = x - shelfW/2 + 10 + i * 14;
        const hy = y - shelfH/2 + 10;
        const heartPulse = 0.9 + Math.sin(time * 0.005 + i * 0.5) * 0.15;
        
        // Heart shape with pulse
        ctx.save();
        ctx.translate(hx, hy);
        ctx.scale(heartPulse, heartPulse);
        ctx.fillStyle = i % 2 === 0 ? '#ff6b9d' : '#ff8aaa';
        ctx.beginPath();
        ctx.moveTo(0, 3);
        ctx.arc(-2.5, 0, 2.5, 0, Math.PI, true);
        ctx.arc(2.5, 0, 2.5, 0, Math.PI, true);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Connecting ribbon/string (curved)
        if (i < 7) {
          ctx.strokeStyle = '#ff8aaa';
          ctx.lineWidth = 1.5;
          ctx.globalAlpha = 0.4;
          ctx.beginPath();
          ctx.moveTo(hx + 2, hy + 2);
          ctx.quadraticCurveTo(hx + 7, hy + 6, hx + 12, hy + 2);
          ctx.stroke();
          ctx.globalAlpha = 0.7;
        }
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• LEFT SIDE: Elaborate Rose Garden â•â•â•
      // Main vine (thicker, more pronounced)
      ctx.strokeStyle = '#d88aaa';
      ctx.lineWidth = 3.5;
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.moveTo(x - shelfW/2 + 5, y - shelfH/2 + 15);
      ctx.bezierCurveTo(x - shelfW/2 + 25, y - 18, x - shelfW/2 + 12, y - 8, x - shelfW/2 + 20, y + 2);
      ctx.bezierCurveTo(x - shelfW/2 + 28, y + 12, x - shelfW/2 + 10, y + 16, x - shelfW/2 + 15, y + 26);
      ctx.stroke();
      
      // Secondary vine (intertwined)
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(x - shelfW/2 + 8, y - shelfH/2 + 18);
      ctx.quadraticCurveTo(x - shelfW/2 + 18, y - 5, x - shelfW/2 + 12, y + 8);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Rose leaves (more realistic)
      ctx.fillStyle = '#8ac88a';
      const leafPositions = [
        {x: x - shelfW/2 + 17, y: y - 14, angle: -0.6, size: 1.2},
        {x: x - shelfW/2 + 13, y: y - 6, angle: 0.4, size: 1},
        {x: x - shelfW/2 + 18, y: y + 2, angle: -0.4, size: 1.1},
        {x: x - shelfW/2 + 12, y: y + 10, angle: 0.6, size: 1},
        {x: x - shelfW/2 + 16, y: y + 18, angle: -0.3, size: 1.2},
        {x: x - shelfW/2 + 11, y: y + 24, angle: 0.5, size: 0.9}
      ];
      for (const leaf of leafPositions) {
        ctx.save();
        ctx.translate(leaf.x, leaf.y);
        ctx.rotate(leaf.angle);
        ctx.scale(leaf.size, leaf.size);
        
        // Leaf shape (pointed)
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(0, -5);
        ctx.quadraticCurveTo(3, -2, 2, 2);
        ctx.quadraticCurveTo(0, 4, 0, 5);
        ctx.quadraticCurveTo(0, 4, -2, 2);
        ctx.quadraticCurveTo(-3, -2, 0, -5);
        ctx.fill();
        
        // Leaf vein
        ctx.strokeStyle = '#6aa86a';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(0, -4);
        ctx.lineTo(0, 4);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // Rose blooms (ultra detailed - multiple petal layers)
      const rosePositions = [
        {x: x - shelfW/2 + 16, y: y - 15, size: 6, bloom: 0.8},
        {x: x - shelfW/2 + 18, y: y - 4, size: 7, bloom: 1},
        {x: x - shelfW/2 + 13, y: y + 6, size: 5.5, bloom: 0.7},
        {x: x - shelfW/2 + 17, y: y + 16, size: 6.5, bloom: 0.9}
      ];
      for (const rose of rosePositions) {
        // Outer petals (4 layers for depth)
        const petalColors = ['#ff9aaa', '#ff8aaa', '#ff6b9d', '#ff5a8d'];
        for (let layer = 0; layer < 4; layer++) {
          ctx.fillStyle = petalColors[layer];
          ctx.globalAlpha = 0.75 - layer * 0.08;
          ctx.beginPath();
          ctx.arc(rose.x, rose.y, (rose.size * rose.bloom) - layer * 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Inner stamen (dark center)
        ctx.fillStyle = '#d84a7d';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(rose.x, rose.y, 1.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Pollen dots
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2;
          ctx.fillStyle = '#f0d060';
          ctx.beginPath();
          ctx.arc(rose.x + Math.cos(angle) * 1.2, rose.y + Math.sin(angle) * 1.2, 0.4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Sparkle highlight
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(rose.x - 1.5, rose.y - 1.5, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• RIGHT SIDE: Winged Heart & Cupid Elements â•â•â•
      const heartCenterX = x + shelfW/2 - 22;
      const heartCenterY = y - 12;
      
      // Angel wings (detailed feathers)
      ctx.globalAlpha = 0.5;
      // Left wing
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.ellipse(heartCenterX - 8 - i * 3, heartCenterY - i, 8 - i * 2, 10 - i * 2, -0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      // Right wing
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.ellipse(heartCenterX + 8 + i * 3, heartCenterY - i, 8 - i * 2, 10 - i * 2, 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // Large ornate heart centerpiece
      ctx.fillStyle = '#ff6b9d';
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.moveTo(heartCenterX, heartCenterY + 8);
      ctx.arc(heartCenterX - 6, heartCenterY, 6, 0, Math.PI, true);
      ctx.arc(heartCenterX + 6, heartCenterY, 6, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      
      // Heart outline (decorative)
      ctx.strokeStyle = '#ff8aaa';
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.9;
      ctx.stroke();
      
      // Inner heart glow
      ctx.fillStyle = '#ff8aaa';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(heartCenterX, heartCenterY + 5);
      ctx.arc(heartCenterX - 4, heartCenterY + 1, 4, 0, Math.PI, true);
      ctx.arc(heartCenterX + 4, heartCenterY + 1, 4, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Cupid's arrow (golden)
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(heartCenterX - 12, heartCenterY - 8);
      ctx.lineTo(heartCenterX + 10, heartCenterY + 6);
      ctx.stroke();
      
      // Arrow tip (detailed)
      ctx.fillStyle = '#d4af37';
      ctx.beginPath();
      ctx.moveTo(heartCenterX + 10, heartCenterY + 6);
      ctx.lineTo(heartCenterX + 6, heartCenterY + 4);
      ctx.lineTo(heartCenterX + 8, heartCenterY + 8);
      ctx.closePath();
      ctx.fill();
      
      // Arrow feathers
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(heartCenterX - 12, heartCenterY - 8);
      ctx.lineTo(heartCenterX - 14, heartCenterY - 10);
      ctx.moveTo(heartCenterX - 12, heartCenterY - 8);
      ctx.lineTo(heartCenterX - 14, heartCenterY - 6);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM LEFT: Perfume Bottle â•â•â•
      const perfumeX = x - shelfW/2 + 20;
      const perfumeY = y + shelfH/2 - 16;
      
      // Bottle body (glass effect)
      ctx.fillStyle = '#ffd8e8';
      ctx.globalAlpha = 0.7;
      ctx.fillRect(perfumeX - 4, perfumeY, 8, 10);
      
      // Bottle neck
      ctx.fillRect(perfumeX - 2, perfumeY - 4, 4, 4);
      
      // Cap (gold)
      ctx.fillStyle = '#d4af37';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(perfumeX - 3, perfumeY - 6, 6, 2);
      ctx.fillRect(perfumeX - 2, perfumeY - 8, 4, 2);
      
      // Liquid inside (pink)
      ctx.fillStyle = '#ff8aaa';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(perfumeX - 3, perfumeY + 3, 6, 6);
      
      // Glass shine
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.5;
      ctx.fillRect(perfumeX - 3, perfumeY + 1, 2, 4);
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM CENTER: Engagement Ring Box â•â•â•
      const ringBoxX = x;
      const ringBoxY = y + shelfH/2 - 14;
      
      // Box base (velvet red)
      ctx.fillStyle = '#c84a6a';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(ringBoxX - 5, ringBoxY, 10, 8);
      
      // Box lid (open)
      ctx.fillRect(ringBoxX - 5, ringBoxY - 6, 10, 2);
      ctx.beginPath();
      ctx.moveTo(ringBoxX - 5, ringBoxY - 6);
      ctx.lineTo(ringBoxX - 4, ringBoxY - 10);
      ctx.lineTo(ringBoxX + 4, ringBoxY - 10);
      ctx.lineTo(ringBoxX + 5, ringBoxY - 6);
      ctx.closePath();
      ctx.fill();
      
      // Ring inside (gold band with diamond)
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(ringBoxX, ringBoxY + 3, 2.5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Diamond (sparkle)
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(ringBoxX, ringBoxY);
      ctx.lineTo(ringBoxX - 1.5, ringBoxY + 2);
      ctx.lineTo(ringBoxX + 1.5, ringBoxY + 2);
      ctx.closePath();
      ctx.fill();
      
      // Diamond sparkle
      ctx.strokeStyle = '#ffffdd';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(ringBoxX - 3, ringBoxY + 1);
      ctx.lineTo(ringBoxX + 3, ringBoxY + 1);
      ctx.moveTo(ringBoxX, ringBoxY - 2);
      ctx.lineTo(ringBoxX, ringBoxY + 4);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM RIGHT: Love Letter (Sealed) â•â•â•
      const letterX = x + shelfW/2 - 20;
      const letterY = y + shelfH/2 - 18;
      
      // Envelope (cream paper)
      ctx.fillStyle = '#fff5f8';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(letterX - 7, letterY, 14, 12);
      
      // Envelope flap
      ctx.fillStyle = '#ffe8ee';
      ctx.beginPath();
      ctx.moveTo(letterX - 7, letterY);
      ctx.lineTo(letterX, letterY - 5);
      ctx.lineTo(letterX + 7, letterY);
      ctx.closePath();
      ctx.fill();
      
      // Envelope border
      ctx.strokeStyle = '#ff6b9d';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      ctx.strokeRect(letterX - 7, letterY, 14, 12);
      
      // Heart wax seal (detailed)
      ctx.fillStyle = '#c8344a';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(letterX, letterY + 4);
      ctx.arc(letterX - 2, letterY + 1, 2.5, 0, Math.PI, true);
      ctx.arc(letterX + 2, letterY + 1, 2.5, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      
      // Seal texture
      ctx.fillStyle = '#a82a3a';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(letterX, letterY + 2, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• FLYING ELEMENTS: Butterflies â•â•â•
      // Animated butterflies (2-3 fluttering around)
      const butterflyPositions = [
        {baseX: x - 25, baseY: y - 18, phase: 0},
        {baseX: x + 30, baseY: y + 8, phase: Math.PI}
      ];
      
      for (let b = 0; b < butterflyPositions.length; b++) {
        const butterfly = butterflyPositions[b];
        const bx = butterfly.baseX + Math.sin(time * 0.002 + butterfly.phase) * 10;
        const by = butterfly.baseY + Math.sin(time * 0.003 + butterfly.phase) * 8;
        const wingFlap = Math.abs(Math.sin(time * 0.015 + butterfly.phase));
        
        ctx.save();
        ctx.translate(bx, by);
        ctx.globalAlpha = 0.7;
        
        // Left wing
        ctx.fillStyle = '#ff6b9d';
        ctx.beginPath();
        ctx.ellipse(-2, 0, 3 * (1 - wingFlap * 0.5), 4, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right wing
        ctx.beginPath();
        ctx.ellipse(2, 0, 3 * (1 - wingFlap * 0.5), 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(-0.5, -2, 1, 4);
        
        // Antennae
        ctx.strokeStyle = '#4a4a4a';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -2);
        ctx.lineTo(-1, -3);
        ctx.moveTo(0, -2);
        ctx.lineTo(1, -3);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• ROMANCE NOVELS (Colorful, Prominent) â•â•â•
      const romanceBooks = [
        {x: -48, w: 9, h: 16, color: '#ff6b9d', title: 'â™¥'},
        {x: -37, w: 8, h: 18, color: '#ff8aaa', title: 'â™¥'},
        {x: -27, w: 9, h: 15, color: '#ffa8ba', title: 'â™¥'},
        {x: -16, w: 8, h: 17, color: '#c86a8a', title: 'â™¥'},
        {x: -6, w: 9, h: 16, color: '#ff5a8a', title: 'â™¥'},
        {x: 5, w: 8, h: 19, color: '#ff7aa5', title: 'â™¥'},
        {x: 15, w: 9, h: 14, color: '#e85a8a', title: 'â™¥'},
        {x: 26, w: 8, h: 17, color: '#ff9aaa', title: 'â™¥'}
      ];
      
      for (const book of romanceBooks) {
        // Book spine (with slight tilt)
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(x + book.x, y + shelfH/2 - 24 - book.h, book.w, book.h);
        
        // Gold foil lettering stripe
        ctx.fillStyle = '#d4af37';
        ctx.globalAlpha = 0.4;
        ctx.fillRect(x + book.x + 1, y + shelfH/2 - 22, book.w - 2, 2);
        
        // Heart symbol on spine
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.5;
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(book.title, x + book.x + book.w/2, y + shelfH/2 - 14);
        
        // Book edge highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(x + book.x, y + shelfH/2 - 24 - book.h, 1, book.h);
        
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• RIBBON BOW (Bottom Decoration) â•â•â•
      const ribbonX = x + shelfW/2 - 42;
      const ribbonY = y + shelfH/2 - 10;
      
      // Ribbon vertical
      ctx.fillStyle = '#ff8aaa';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(ribbonX - 1.5, ribbonY - 12, 3, 12);
      
      // Bow loops (left and right)
      ctx.beginPath();
      ctx.ellipse(ribbonX - 5, ribbonY - 12, 4, 5, -0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(ribbonX + 5, ribbonY - 12, 4, 5, 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Bow center knot
      ctx.fillStyle = '#ff6b9d';
      ctx.beginPath();
      ctx.arc(ribbonX, ribbonY - 12, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Ribbon tails (flowing down)
      ctx.beginPath();
      ctx.moveTo(ribbonX - 1, ribbonY);
      ctx.lineTo(ribbonX - 3, ribbonY + 6);
      ctx.lineTo(ribbonX, ribbonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ribbonX + 1, ribbonY);
      ctx.lineTo(ribbonX + 3, ribbonY + 6);
      ctx.lineTo(ribbonX, ribbonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• NEW: Pearl Necklace (Top Right Corner) â•â•â•
      const pearlStart = {x: x + shelfW/2 - 35, y: y - shelfH/2 + 12};
      const pearlCount = 9;
      
      // Necklace string (golden chain)
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(pearlStart.x, pearlStart.y);
      for (let i = 0; i <= pearlCount; i++) {
        const px = pearlStart.x + i * 4;
        const py = pearlStart.y + Math.sin(i * 0.8) * 6;
        ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Individual pearls (lustrous white)
      for (let i = 0; i <= pearlCount; i++) {
        const px = pearlStart.x + i * 4;
        const py = pearlStart.y + Math.sin(i * 0.8) * 6;
        
        // Pearl body
        ctx.fillStyle = '#f8f8ff';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Pearl shine
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(px - 0.7, py - 0.7, 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Pearl shadow (subtle depth)
        ctx.fillStyle = '#e8e8f0';
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(px + 0.5, py + 0.5, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• NEW: Champagne Glasses (Bottom Center-Left) â•â•â•
      const glass1X = x - 18;
      const glass2X = x - 8;
      const glassY = y + shelfH/2 - 16;
      
      // First glass
      ctx.strokeStyle = '#d8e8f8';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.7;
      // Stem
      ctx.beginPath();
      ctx.moveTo(glass1X, glassY + 10);
      ctx.lineTo(glass1X, glassY);
      ctx.stroke();
      // Bowl
      ctx.beginPath();
      ctx.moveTo(glass1X - 3, glassY);
      ctx.lineTo(glass1X - 4, glassY - 6);
      ctx.lineTo(glass1X + 4, glassY - 6);
      ctx.lineTo(glass1X + 3, glassY);
      ctx.stroke();
      // Base
      ctx.beginPath();
      ctx.moveTo(glass1X - 3, glassY + 10);
      ctx.lineTo(glass1X + 3, glassY + 10);
      ctx.stroke();
      
      // Second glass (tilted, touching first)
      ctx.save();
      ctx.translate(glass2X, glassY);
      ctx.rotate(0.2);
      // Stem
      ctx.beginPath();
      ctx.moveTo(0, 10);
      ctx.lineTo(0, 0);
      ctx.stroke();
      // Bowl
      ctx.beginPath();
      ctx.moveTo(-3, 0);
      ctx.lineTo(-4, -6);
      ctx.lineTo(4, -6);
      ctx.lineTo(3, 0);
      ctx.stroke();
      // Base
      ctx.beginPath();
      ctx.moveTo(-3, 10);
      ctx.lineTo(3, 10);
      ctx.stroke();
      ctx.restore();
      
      // Champagne liquid (golden)
      ctx.fillStyle = '#f0d860';
      ctx.globalAlpha = 0.4;
      ctx.fillRect(glass1X - 3, glassY - 3, 6, 3);
      ctx.globalAlpha = 1;
      
      // Bubbles rising
      for (let i = 0; i < 3; i++) {
        const bubbleY = glassY - 4 + i * 2 - (time * 0.02 % 6);
        if (bubbleY < glassY - 6) continue;
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(glass1X + (i % 2 === 0 ? -1 : 1), bubbleY, 0.7, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• NEW: Floating Rose Petals (Scattered) â•â•â•
      const petalPositions = [
        {x: x - 20, y: y - 8, angle: 0.3, size: 1},
        {x: x + 12, y: y + 5, angle: -0.5, size: 0.9},
        {x: x - 35, y: y + 12, angle: 0.8, size: 0.8},
        {x: x + 25, y: y - 15, angle: -0.3, size: 1.1}
      ];
      
      for (const petal of petalPositions) {
        const petalFloat = Math.sin(time * 0.003 + petal.x) * 2;
        const petalRotate = Math.sin(time * 0.002 + petal.y) * 0.3;
        
        ctx.save();
        ctx.translate(petal.x, petal.y + petalFloat);
        ctx.rotate(petal.angle + petalRotate);
        ctx.scale(petal.size, petal.size);
        
        // Petal shape (tear drop)
        ctx.fillStyle = '#ff9aaa';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -3);
        ctx.quadraticCurveTo(2, -1, 1, 2);
        ctx.quadraticCurveTo(0, 3, -1, 2);
        ctx.quadraticCurveTo(-2, -1, 0, -3);
        ctx.fill();
        
        // Petal vein
        ctx.strokeStyle = '#ff6b9d';
        ctx.lineWidth = 0.3;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.moveTo(0, -2);
        ctx.lineTo(0, 2);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• NEW: Musical Notes (Love Song) â•â•â•
      const notePositions = [
        {x: x - shelfW/2 + 40, y: y - shelfH/2 + 20, type: 'eighth'},
        {x: x - shelfW/2 + 48, y: y - shelfH/2 + 16, type: 'quarter'},
        {x: x - shelfW/2 + 56, y: y - shelfH/2 + 22, type: 'eighth'}
      ];
      
      for (const note of notePositions) {
        const noteFloat = Math.sin(time * 0.004 + note.x) * 1.5;
        
        ctx.fillStyle = '#ff6b9d';
        ctx.globalAlpha = 0.4;
        
        // Note head
        ctx.save();
        ctx.translate(note.x, note.y + noteFloat);
        ctx.rotate(0.3);
        ctx.beginPath();
        ctx.ellipse(0, 0, 2, 2.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Note stem
        if (note.type === 'eighth' || note.type === 'quarter') {
          ctx.fillRect(1.5, -6, 1, 6);
        }
        
        // Note flag (for eighth notes)
        if (note.type === 'eighth') {
          ctx.beginPath();
          ctx.moveTo(2.5, -6);
          ctx.quadraticCurveTo(5, -4, 4, -2);
          ctx.lineTo(2.5, -3);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• NEW: "Love" Text in Cursive Script â•â•â•
      ctx.save();
      ctx.font = 'italic 10px Georgia';
      ctx.fillStyle = '#ff6b9d';
      ctx.globalAlpha = 0.25;
      ctx.textAlign = 'center';
      
      // Multiple "Love" words scattered
      const loveWords = [
        {x: x + 10, y: y - 20, size: 8},
        {x: x - 25, y: y + 15, size: 7},
        {x: x + 30, y: y - 5, size: 6}
      ];
      
      for (const love of loveWords) {
        ctx.font = `italic ${love.size}px Georgia`;
        const pulse = 0.8 + Math.sin(time * 0.003 + love.x) * 0.2;
        ctx.globalAlpha = 0.2 * pulse;
        ctx.fillText('Love', love.x, love.y);
      }
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ADDITIONAL ROMANTIC ENHANCEMENTS - AUGMENTED DETAILS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // â•â•â• CHERRY BLOSSOM PETALS (Floating) â•â•â•
      const flowerPositions = [
        {x: x - 35, y: y - 24, rot: 0.3, size: 1.2},
        {x: x - 10, y: y - 28, rot: -0.5, size: 1},
        {x: x + 20, y: y - 22, rot: 0.7, size: 1.1},
        {x: x + 38, y: y - 26, rot: -0.3, size: 0.9},
        {x: x - 20, y: y + 15, rot: 0.4, size: 1},
        {x: x + 10, y: y + 18, rot: -0.6, size: 1.1}
      ];
      
      for (const flower of flowerPositions) {
        ctx.save();
        ctx.translate(flower.x, flower.y);
        ctx.rotate(flower.rot + Math.sin(time * 0.003) * 0.2);
        ctx.scale(flower.size, flower.size);
        
        ctx.fillStyle = '#ffc8d8';
        ctx.globalAlpha = 0.6;
        
        // Petal shape (5 petals)
        for (let p = 0; p < 5; p++) {
          const angle = (p / 5) * Math.PI * 2 - Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.ellipse(Math.cos(angle) * 3, Math.sin(angle) * 3, 2, 3, angle, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Center
        ctx.fillStyle = '#f0d060';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• BABY CUPID (Top Right Corner) â•â•â•
      const cupidX = x + shelfW/2 - 15;
      const cupidY = y - shelfH/2 + 20;
      const cupidFloat = Math.sin(time * 0.004) * 2;
      
      // Cupid head
      ctx.fillStyle = '#ffd8c8';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(cupidX, cupidY + cupidFloat, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes (closed - content)
      ctx.strokeStyle = '#8a6a5a';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.arc(cupidX - 1.5, cupidY + cupidFloat - 1, 1, 0, Math.PI);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cupidX + 1.5, cupidY + cupidFloat - 1, 1, 0, Math.PI);
      ctx.stroke();
      
      // Smile
      ctx.beginPath();
      ctx.arc(cupidX, cupidY + cupidFloat + 1, 1.5, 0, Math.PI);
      ctx.stroke();
      
      // Baby body (small)
      ctx.fillStyle = '#ffd8c8';
      ctx.fillRect(cupidX - 2, cupidY + cupidFloat + 3, 4, 5);
      
      // Diaper (white)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(cupidX - 2.5, cupidY + cupidFloat + 5, 5, 3);
      
      // Wings (tiny)
      ctx.fillStyle = '#ffe8f8';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.ellipse(cupidX - 3, cupidY + cupidFloat + 4, 2.5, 3, -0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cupidX + 3, cupidY + cupidFloat + 4, 2.5, 3, 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      // Mini bow and arrow
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.7;
      // Bow
      ctx.beginPath();
      ctx.arc(cupidX + 6, cupidY + cupidFloat + 1, 3, -Math.PI/3, Math.PI/3);
      ctx.stroke();
      // Bowstring
      ctx.beginPath();
      ctx.moveTo(cupidX + 4, cupidY + cupidFloat - 1.5);
      ctx.lineTo(cupidX + 4, cupidY + cupidFloat + 3.5);
      ctx.stroke();
      // Arrow
      ctx.beginPath();
      ctx.moveTo(cupidX + 3, cupidY + cupidFloat + 1);
      ctx.lineTo(cupidX + 1, cupidY + cupidFloat + 1);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // â•â•â• LOVE LOCKET (Bottom Left) â•â•â•
      const locketX = x - shelfW/2 + 35;
      const locketY = y + shelfH/2 - 12;
      
      // Locket (heart-shaped)
      ctx.fillStyle = '#d4af37';
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.moveTo(locketX, locketY + 4);
      ctx.arc(locketX - 2.5, locketY, 2.5, 0, Math.PI, true);
      ctx.arc(locketX + 2.5, locketY, 2.5, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      
      // Locket detail (hinge line)
      ctx.strokeStyle = '#b89020';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(locketX - 3, locketY + 1);
      ctx.lineTo(locketX + 3, locketY + 1);
      ctx.stroke();
      
      // Chain
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(locketX, locketY - 3);
      ctx.lineTo(locketX, locketY - 8);
      ctx.stroke();
      
      // Shine
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(locketX - 1, locketY, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• DECORATIVE SPARKLES (Throughout) â•â•â•
      const sparklePositions = [
        {x: x - 40, y: y - 10, size: 1.5, phase: 0},
        {x: x - 25, y: y + 5, size: 1.2, phase: 0.5},
        {x: x + 15, y: y - 15, size: 1.8, phase: 1},
        {x: x + 35, y: y + 10, size: 1.3, phase: 1.5},
        {x: x - 5, y: y - 20, size: 1.6, phase: 2},
        {x: x + 25, y: y + 18, size: 1.4, phase: 2.5}
      ];
      
      for (const sparkle of sparklePositions) {
        const twinkle = Math.abs(Math.sin(time * 0.008 + sparkle.phase)) * 0.8 + 0.2;
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = twinkle * 0.7;
        
        // 4-pointed star sparkle
        ctx.save();
        ctx.translate(sparkle.x, sparkle.y);
        ctx.rotate(time * 0.003 + sparkle.phase);
        
        // Horizontal beam
        ctx.fillRect(-sparkle.size * 2, -0.5, sparkle.size * 4, 1);
        // Vertical beam
        ctx.fillRect(-0.5, -sparkle.size * 2, 1, sparkle.size * 4);
        // Diagonal beams
        ctx.rotate(Math.PI / 4);
        ctx.fillRect(-sparkle.size * 1.5, -0.4, sparkle.size * 3, 0.8);
        ctx.fillRect(-0.4, -sparkle.size * 1.5, 0.8, sparkle.size * 3);
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• LOVE CONFETTI (Scattered) â•â•â•
      const confettiShapes = ['heart', 'circle', 'square'];
      const confettiColors = ['#ff6b9d', '#ff8aaa', '#ffa8ba', '#ffffff'];
      
      for (let i = 0; i < 15; i++) {
        const cx = x - shelfW/2 + 15 + (i % 5) * 20;
        const cy = y - shelfH/2 + 25 + Math.floor(i / 5) * 15;
        const shape = confettiShapes[i % 3];
        const color = confettiColors[i % 4];
        const rotate = (time * 0.002 + i) % (Math.PI * 2);
        const pulse = 0.8 + Math.sin(time * 0.006 + i) * 0.2;
        
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotate);
        ctx.scale(pulse, pulse);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.15;
        
        if (shape === 'heart') {
          ctx.beginPath();
          ctx.moveTo(0, 1.5);
          ctx.arc(-1, 0, 1, 0, Math.PI, true);
          ctx.arc(1, 0, 1, 0, Math.PI, true);
          ctx.closePath();
          ctx.fill();
        } else if (shape === 'circle') {
          ctx.beginPath();
          ctx.arc(0, 0, 1.2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillRect(-1, -1, 2, 2);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• ROMANTIC QUOTE SCROLL (Bottom) â•â•â•
      const scrollX = x + shelfW/2 - 48;
      const scrollY = y + shelfH/2 - 25;
      
      // Scroll paper
      ctx.fillStyle = '#fffaf0';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(scrollX - 10, scrollY, 20, 8);
      
      // Scroll curls
      ctx.beginPath();
      ctx.arc(scrollX - 10, scrollY + 4, 3, -Math.PI/2, Math.PI/2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(scrollX + 10, scrollY + 4, 3, Math.PI/2, -Math.PI/2);
      ctx.fill();
      
      // "LOVE" text (tiny)
      ctx.fillStyle = '#c84a6a';
      ctx.font = '5px "Press Start 2P"';
      ctx.globalAlpha = 0.6;
      ctx.textAlign = 'center';
      ctx.fillText('LOVE', scrollX, scrollY + 5);
      ctx.globalAlpha = 1;
      
      // Bow center knot
      ctx.fillStyle = '#ff6b9d';
      ctx.beginPath();
      ctx.arc(ribbonX, ribbonY - 12, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Ribbon tails
      ctx.fillStyle = '#ff8aaa';
      ctx.beginPath();
      ctx.moveTo(ribbonX - 2, ribbonY);
      ctx.lineTo(ribbonX - 5, ribbonY + 6);
      ctx.lineTo(ribbonX - 3, ribbonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(ribbonX + 2, ribbonY);
      ctx.lineTo(ribbonX + 5, ribbonY + 6);
      ctx.lineTo(ribbonX + 3, ribbonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• FLOATING PARTICLES: Hearts, Sparkles, Petals â•â•â•
      if (Math.random() < 0.04 * particleChanceMultiplier) {
        const particleType = Math.random();
        const pX = x + rnd(-shelfW/2 + 10, shelfW/2 - 10);
        const pY = y + shelfH/2 - 5;
        
        if (particleType < 0.4) {
          // Floating heart
          particles.push({
            x: pX,
            y: pY,
            vx: rnd(-8, 8),
            vy: -25,
            life: 1800,
            maxLife: 1800,
            color: Math.random() < 0.5 ? '#ff6b9d' : '#ff8aaa',
            size: rnd(3, 7),
            type: 'heart',
            alpha: 1,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: rnd(-0.03, 0.03)
          });
        } else if (particleType < 0.7) {
          // Sparkle
          particles.push({
            x: pX,
            y: pY,
            vx: rnd(-10, 10),
            vy: -30,
            life: 1200,
            maxLife: 1200,
            color: '#ffffff',
            size: rnd(2, 4),
            type: 'circle',
            alpha: 0.8
          });
        } else {
          // Rose petal
          particles.push({
            x: pX,
            y: pY,
            vx: rnd(-12, 12),
            vy: -20,
            life: 2000,
            maxLife: 2000,
            color: '#ffaac8',
            size: rnd(3, 6),
            type: 'circle',
            alpha: 0.7,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: rnd(-0.04, 0.04)
          });
        }
      }
      break;

      
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HORROR SHELF - NINTENDO-QUALITY ENHANCEMENT
    // Dark, Spooky, Detailed - AAA Polish
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'HORROR':
      // Very dark wood background with gradient
      const horrorGrad = ctx.createLinearGradient(x, y - shelfH/2, x, y + shelfH/2);
      horrorGrad.addColorStop(0, '#1a0a0a');
      horrorGrad.addColorStop(1, '#2a1a1a');
      ctx.fillStyle = horrorGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Blood red thick border
      ctx.strokeStyle = '#8a2a2a';
      ctx.lineWidth = 4;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner shadow border
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.5;
      ctx.strokeRect(x - shelfW/2 + 3, y - shelfH/2 + 3, shelfW - 6, shelfH - 6);
      ctx.globalAlpha = 1;
      
      // â•â•â• BLOOD DRIPS (top edge) â•â•â•
      const bloodDrips = [
        {x: x - 30, len: 12},
        {x: x - 10, len: 8},
        {x: x + 15, len: 15},
        {x: x + 35, len: 10}
      ];
      for (const drip of bloodDrips) {
        const dripGrad = ctx.createLinearGradient(drip.x, y - shelfH/2, drip.x, y - shelfH/2 + drip.len);
        dripGrad.addColorStop(0, '#8a2a2a');
        dripGrad.addColorStop(1, 'rgba(138, 42, 42, 0)');
        ctx.fillStyle = dripGrad;
        ctx.fillRect(drip.x - 1.5, y - shelfH/2, 3, drip.len);
        // Drip bottom
        ctx.beginPath();
        ctx.ellipse(drip.x, y - shelfH/2 + drip.len, 2, 3, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // â•â•â• EXTENSIVE COBWEB SYSTEM â•â•â•
      ctx.strokeStyle = '#9a9a9a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      
      // Top left corner web (extended)
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, y - shelfH/2);
        ctx.lineTo(x - shelfW/2 + 20, y - shelfH/2 + 3 + i * 3);
        ctx.stroke();
      }
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, y - shelfH/2);
        ctx.lineTo(x - shelfW/2 + 3 + i * 3, y - shelfH/2 + 20);
        ctx.stroke();
      }
      // Connecting strands
      ctx.beginPath();
      ctx.arc(x - shelfW/2 + 10, y - shelfH/2 + 10, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      // Top right corner web (extended)
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(x + shelfW/2, y - shelfH/2);
        ctx.lineTo(x + shelfW/2 - 20, y - shelfH/2 + 3 + i * 3);
        ctx.stroke();
      }
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(x + shelfW/2, y - shelfH/2);
        ctx.lineTo(x + shelfW/2 - 3 - i * 3, y - shelfH/2 + 20);
        ctx.stroke();
      }
      // Connecting strands
      ctx.beginPath();
      ctx.arc(x + shelfW/2 - 10, y - shelfH/2 + 10, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // â•â•â• LARGE SKULL CENTERPIECE (top center) â•â•â•
      const skullX = x;
      const skullY = y - shelfH/2 + 18;
      
      // Skull (bone white)
      ctx.fillStyle = '#d8d8d8';
      ctx.globalAlpha = 0.9;
      // Cranium
      ctx.beginPath();
      ctx.ellipse(skullX, skullY - 3, 8, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      // Jaw
      ctx.beginPath();
      ctx.ellipse(skullX, skullY + 5, 6, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye sockets (hollow)
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.ellipse(skullX - 3, skullY - 4, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(skullX + 3, skullY - 4, 2.5, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Nose cavity
      ctx.beginPath();
      ctx.moveTo(skullX, skullY);
      ctx.lineTo(skullX - 1.5, skullY + 2);
      ctx.lineTo(skullX + 1.5, skullY + 2);
      ctx.closePath();
      ctx.fill();
      
      // Teeth (detailed)
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 6; i++) {
        ctx.fillRect(skullX - 5 + i * 2, skullY + 6, 1.5, 2);
      }
      
      // Cracks in skull
      ctx.strokeStyle = '#8a8a8a';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(skullX + 4, skullY - 8);
      ctx.lineTo(skullX + 6, skullY - 3);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(skullX - 5, skullY - 5);
      ctx.lineTo(skullX - 2, skullY);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // â•â•â• GOTHIC CANDELABRA (left side) â•â•â•
      const candleX = x - shelfW/2 + 25;
      const candleY = y;
      
      // Base
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(candleX - 3, candleY + 8, 6, 3);
      // Stem
      ctx.fillRect(candleX - 1, candleY - 5, 2, 13);
      // Candle holder
      ctx.fillRect(candleX - 2, candleY - 8, 4, 3);
      // Candle
      ctx.fillStyle = '#d8c8a8';
      ctx.fillRect(candleX - 1.5, candleY - 15, 3, 7);
      // Flame (animated)
      const flameFlicker = Math.sin(time * 0.015) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(255, 180, 60, ${0.8 + flameFlicker * 0.2})`;
      ctx.beginPath();
      ctx.moveTo(candleX, candleY - 15);
      ctx.lineTo(candleX - 2, candleY - 12);
      ctx.lineTo(candleX + 2, candleY - 12);
      ctx.closePath();
      ctx.fill();
      // Flame glow
      ctx.fillStyle = `rgba(255, 150, 40, ${0.3 * flameFlicker})`;
      ctx.beginPath();
      ctx.arc(candleX, candleY - 13, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // â•â•â• RUSTY CHAIN (across top) â•â•â•
      ctx.strokeStyle = '#5a4a3a';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.8;
      
      const chainY = y - shelfH/2 + 35;
      for (let i = 0; i < 7; i++) {
        const chainX = x - 40 + i * 14;
        const chainSag = Math.abs(i - 3) * -2; // Sag in middle
        
        // Chain link
        ctx.beginPath();
        ctx.ellipse(chainX, chainY + chainSag, 4, 6, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Padlock
      ctx.fillStyle = '#4a3a2a';
      ctx.fillRect(x - 5, chainY - 2, 10, 8);
      ctx.beginPath();
      ctx.arc(x, chainY - 4, 4, Math.PI, 0, true);
      ctx.stroke();
      ctx.fill();
      
      ctx.globalAlpha = 1;
      
      // â•â•â• MULTIPLE SPIDERS â•â•â•
      const spiders = [
        {baseX: x - 35, baseY: y - 20},
        {baseX: x + 32, baseY: y - 18},
        {baseX: x - 15, baseY: y + 10}
      ];
      
      for (let s = 0; s < spiders.length; s++) {
        const spider = spiders[s];
        const spiderX = spider.baseX + Math.sin(time * 0.001 + s) * 6;
        const spiderY = spider.baseY + Math.sin(time * 0.0015 + s) * 3;
        
        // Spider body
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(spiderX, spiderY, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(spiderX, spiderY + 3, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Animated legs
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const legAngle = (i / 8) * Math.PI * 2 + Math.sin(time * 0.01 + s + i) * 0.4;
          const legLength = 5 + Math.sin(time * 0.008 + s + i) * 1;
          ctx.beginPath();
          ctx.moveTo(spiderX, spiderY);
          ctx.lineTo(spiderX + Math.cos(legAngle) * legLength, spiderY + Math.sin(legAngle) * legLength);
          ctx.stroke();
        }
      }
      
      // â•â•â• BAT SILHOUETTE (flying) â•â•â•
      const batX = x + shelfW/2 - 20;
      const batY = y - 5;
      const wingFlap = Math.sin(time * 0.02) * 3;
      
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = 0.7;
      // Bat body
      ctx.beginPath();
      ctx.ellipse(batX, batY, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Left wing
      ctx.beginPath();
      ctx.moveTo(batX, batY);
      ctx.lineTo(batX - 6, batY - 3 + wingFlap);
      ctx.lineTo(batX - 4, batY + 2);
      ctx.closePath();
      ctx.fill();
      // Right wing
      ctx.beginPath();
      ctx.moveTo(batX, batY);
      ctx.lineTo(batX + 6, batY - 3 - wingFlap);
      ctx.lineTo(batX + 4, batY + 2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• HORROR BOOKS (worn and dark) â•â•â•
      const horrorBooks = [
        {x: -45, w: 7, h: 16, color: '#4a1a1a', tilt: -0.05},
        {x: -35, w: 6, h: 13, color: '#1a1a3a', tilt: 0},
        {x: -26, w: 8, h: 15, color: '#3a1a2a', tilt: 0.03},
        {x: -15, w: 6, h: 12, color: '#2a2a1a', tilt: -0.02},
        {x: -7, w: 7, h: 17, color: '#3a1a1a', tilt: 0},
        {x: 3, w: 6, h: 14, color: '#2a1a2a', tilt: 0.02},
        {x: 12, w: 8, h: 13, color: '#1a2a2a', tilt: 0},
        {x: 23, w: 7, h: 16, color: '#2a1a3a', tilt: -0.03}
      ];
      
      for (const book of horrorBooks) {
        ctx.save();
        ctx.translate(x + book.x + book.w/2, y + shelfH/2 - 18 - book.h/2);
        ctx.rotate(book.tilt);
        
        // Book spine
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.8;
        ctx.fillRect(-book.w/2, -book.h/2, book.w, book.h);
        
        // Dark spine line
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(-book.w/2, -book.h/2, 1, book.h);
        
        // Gothic title (decorative line)
        ctx.fillStyle = '#8a2a2a';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(-book.w/2 + 2, 0, book.w - 4, 1);
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• DUST/MIST PARTICLES â•â•â•
      if (Math.random() < 0.02 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2, shelfW/2),
          y: y + shelfH/2,
          vx: rnd(-5, 5),
          vy: -15,
          life: 2000,
          maxLife: 2000,
          color: '#4a4a4a',
          size: rnd(2, 4),
          type: 'circle',
          alpha: 0.3
        });
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ADDITIONAL HORROR ENHANCEMENTS - MORE SPOOKY DETAILS!
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // â•â•â• HAUNTED EYES (watching from darkness) â•â•â•
      const eyePositions = [
        {x: x - shelfW/2 + 12, y: y - 8},
        {x: x + shelfW/2 - 12, y: y + 12},
        {x: x - 20, y: y + 18}
      ];
      
      for (const eye of eyePositions) {
        const blink = Math.sin(time * 0.003 + eye.x) * 0.5 + 0.5;
        const lookAtPlayer = Math.sin(time * 0.002 + eye.y) * 2;
        
        // Eye whites
        ctx.fillStyle = '#ffffaa';
        ctx.globalAlpha = 0.7 * blink;
        ctx.beginPath();
        ctx.ellipse(eye.x - 3, eye.y, 2.5, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(eye.x + 3, eye.y, 2.5, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils (following motion)
        ctx.fillStyle = '#ff0000';
        ctx.globalAlpha = 0.9 * blink;
        ctx.beginPath();
        ctx.arc(eye.x - 3 + lookAtPlayer * 0.3, eye.y, 1.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eye.x + 3 + lookAtPlayer * 0.3, eye.y, 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye glow
        ctx.fillStyle = '#ff0000';
        ctx.globalAlpha = 0.2 * blink;
        ctx.beginPath();
        ctx.arc(eye.x - 3, eye.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eye.x + 3, eye.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• GHOSTLY FIGURE (right side, floating) â•â•â•
      const ghostX = x + shelfW/2 - 15;
      const ghostY = y + 5;
      const ghostFloat = Math.sin(time * 0.003) * 3;
      const ghostFade = Math.sin(time * 0.004) * 0.2 + 0.5;
      
      ctx.save();
      ctx.translate(ghostX, ghostY + ghostFloat);
      ctx.globalAlpha = ghostFade * 0.6;
      
      // Ghost body (flowing shape)
      ctx.fillStyle = '#d8d8e8';
      ctx.beginPath();
      ctx.ellipse(0, -5, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Ghost tail (wispy)
      ctx.beginPath();
      ctx.moveTo(-6, 3);
      ctx.quadraticCurveTo(-3, 8, -2, 10);
      ctx.lineTo(2, 10);
      ctx.quadraticCurveTo(3, 8, 6, 3);
      ctx.lineTo(0, -3);
      ctx.closePath();
      ctx.fill();
      
      // Wavy bottom edge
      ctx.strokeStyle = '#d8d8e8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2 + time * 0.005;
        const waveX = Math.cos(angle) * 4;
        const waveY = 8 + Math.sin(angle) * 1.5;
        if (i === 0) ctx.moveTo(waveX, waveY);
        else ctx.lineTo(waveX, waveY);
      }
      ctx.stroke();
      
      // Ghost eyes (hollow)
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = ghostFade * 0.8;
      ctx.beginPath();
      ctx.arc(-2, -7, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2, -7, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Ghost mouth (O shape)
      ctx.beginPath();
      ctx.arc(0, -4, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOMBSTONE (bottom left) â•â•â•
      const tombX = x - shelfW/2 + 18;
      const tombY = y + shelfH/2 - 15;
      
      // Tombstone shape
      ctx.fillStyle = '#5a5a6a';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(tombX - 6, tombY, 12, 12);
      
      // Rounded top
      ctx.beginPath();
      ctx.arc(tombX, tombY, 6, Math.PI, 0, true);
      ctx.fill();
      
      // Stone cracks
      ctx.strokeStyle = '#3a3a4a';
      ctx.lineWidth = 0.8;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(tombX - 3, tombY + 2);
      ctx.lineTo(tombX - 1, tombY + 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tombX + 2, tombY + 4);
      ctx.lineTo(tombX + 4, tombY + 8);
      ctx.stroke();
      
      // RIP text
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = 0.9;
      ctx.font = 'bold 5px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('RIP', tombX, tombY + 6);
      
      // Cross symbol
      ctx.fillRect(tombX - 1, tombY - 4, 2, 5);
      ctx.fillRect(tombX - 2.5, tombY - 2.5, 5, 2);
      ctx.globalAlpha = 1;
      
      // â•â•â• FULL MOON (background, top right) â•â•â•
      const moonX = x + shelfW/2 - 22;
      const moonY = y - shelfH/2 + 15;
      
      // Moon glow
      ctx.fillStyle = '#ffffcc';
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.arc(moonX, moonY, 14, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon body
      ctx.fillStyle = '#ffffdd';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(moonX, moonY, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Moon craters
      ctx.fillStyle = '#eeeebb';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(moonX - 3, moonY - 2, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(moonX + 2, moonY + 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(moonX + 1, moonY - 3, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• HANGING SKELETON HAND (top, reaching down) â•â•â•
      const handX = x + 10;
      const handY = y - shelfH/2 + 30;
      const handSway = Math.sin(time * 0.002) * 2;
      
      ctx.save();
      ctx.translate(handX + handSway, handY);
      ctx.globalAlpha = 0.7;
      
      // Chain/rope holding hand
      ctx.strokeStyle = '#6a5a4a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(handSway * 0.5, 0);
      ctx.stroke();
      
      // Palm
      ctx.fillStyle = '#d8d8c8';
      ctx.beginPath();
      ctx.ellipse(0, 0, 3, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Fingers (skeletal)
      for (let i = 0; i < 4; i++) {
        const fingerAngle = -0.4 + i * 0.3;
        const fingerCurl = Math.sin(time * 0.004 + i) * 0.2;
        
        ctx.save();
        ctx.rotate(fingerAngle + fingerCurl);
        
        // Finger bones (2 segments)
        ctx.strokeStyle = '#c8c8b8';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(0, 4);
        ctx.lineTo(0, 7);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, 7);
        ctx.lineTo(0, 10);
        ctx.stroke();
        
        // Finger joints
        ctx.fillStyle = '#b8b8a8';
        ctx.beginPath();
        ctx.arc(0, 7, 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Claw tip
        ctx.fillStyle = '#8a8a7a';
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(-0.5, 11.5);
        ctx.lineTo(0.5, 11.5);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Thumb
      ctx.save();
      ctx.rotate(-0.8);
      ctx.strokeStyle = '#c8c8b8';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(0, 4);
      ctx.lineTo(0, 8);
      ctx.stroke();
      ctx.restore();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• CREEPY VINES (left edge, crawling) â•â•â•
      const vineStartX = x - shelfW/2 + 8;
      const vineStartY = y + shelfH/2 - 8;
      
      ctx.strokeStyle = '#2a3a2a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      
      // Main vine
      ctx.beginPath();
      ctx.moveTo(vineStartX, vineStartY);
      ctx.quadraticCurveTo(vineStartX + 5, vineStartY - 15, vineStartX + 3, vineStartY - 25);
      ctx.quadraticCurveTo(vineStartX + 8, vineStartY - 30, vineStartX + 6, vineStartY - 38);
      ctx.stroke();
      
      // Thorns on vine
      ctx.fillStyle = '#3a4a3a';
      const thornPositions = [
        {x: vineStartX + 4, y: vineStartY - 12},
        {x: vineStartX + 2, y: vineStartY - 20},
        {x: vineStartX + 7, y: vineStartY - 28},
        {x: vineStartX + 5, y: vineStartY - 35}
      ];
      
      for (const thorn of thornPositions) {
        ctx.beginPath();
        ctx.moveTo(thorn.x, thorn.y);
        ctx.lineTo(thorn.x - 2, thorn.y - 2);
        ctx.lineTo(thorn.x + 1, thorn.y - 1);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• DRIPPING SLIME (bottom right) â•â•â•
      const slimeX = x + shelfW/2 - 25;
      const slimeY = y + shelfH/2 - 10;
      const slimeDrip = Math.sin(time * 0.004) * 2;
      
      // Slime puddle on shelf
      ctx.fillStyle = '#4a8a4a';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.ellipse(slimeX, slimeY + 8, 8, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Dripping slime
      const slimeGrad = ctx.createLinearGradient(slimeX, slimeY, slimeX, slimeY + 6 + slimeDrip);
      slimeGrad.addColorStop(0, '#6aaa6a');
      slimeGrad.addColorStop(1, 'rgba(106, 170, 106, 0)');
      ctx.fillStyle = slimeGrad;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(slimeX - 1.5, slimeY, 3, 6 + slimeDrip);
      
      // Drip blob
      ctx.fillStyle = '#6aaa6a';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.ellipse(slimeX, slimeY + 6 + slimeDrip, 2, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• CREAKING COFFIN (bottom center) â•â•â•
      const coffinX = x;
      const coffinY = y + shelfH/2 - 12;
      
      // Coffin body
      ctx.fillStyle = '#3a2a1a';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(coffinX - 5, coffinY);
      ctx.lineTo(coffinX - 6, coffinY + 8);
      ctx.lineTo(coffinX - 3, coffinY + 12);
      ctx.lineTo(coffinX + 3, coffinY + 12);
      ctx.lineTo(coffinX + 6, coffinY + 8);
      ctx.lineTo(coffinX + 5, coffinY);
      ctx.closePath();
      ctx.fill();
      
      // Coffin lid (slightly open)
      ctx.strokeStyle = '#5a4a3a';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(coffinX - 4, coffinY + 2);
      ctx.lineTo(coffinX - 5, coffinY + 6);
      ctx.stroke();
      
      // Nails
      ctx.fillStyle = '#6a5a4a';
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(coffinX - 4 + i * 4, coffinY + 4, 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Eerie glow from inside
      ctx.fillStyle = '#8a4a8a';
      ctx.globalAlpha = 0.3;
      ctx.fillRect(coffinX - 3, coffinY + 3, 2, 4);
      ctx.globalAlpha = 1;
      
      // â•â•â• SHADOW HANDS (reaching from below) â•â•â•
      const shadowHands = [
        {x: x - 30, y: y + shelfH/2 - 8},
        {x: x + 25, y: y + shelfH/2 - 6}
      ];
      
      for (const hand of shadowHands) {
        const reach = Math.sin(time * 0.003 + hand.x) * 2;
        
        ctx.save();
        ctx.translate(hand.x, hand.y + reach);
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#1a1a1a';
        
        // Palm shadow
        ctx.beginPath();
        ctx.ellipse(0, 0, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Finger shadows
        for (let i = 0; i < 5; i++) {
          const angle = -0.5 + i * 0.25;
          ctx.save();
          ctx.rotate(angle);
          ctx.fillRect(-1, -5, 2, 6);
          ctx.restore();
        }
        
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• PURPLE MIST (floating across shelf) â•â•â•
      if (Math.random() < 0.025 * particleChanceMultiplier) {
        particles.push({
          x: x - shelfW/2,
          y: y + rnd(-shelfH/2 + 10, shelfH/2 - 10),
          vx: rnd(8, 15),
          vy: rnd(-3, 3),
          life: 3000,
          maxLife: 3000,
          color: '#8a4a8a',
          size: rnd(4, 8),
          type: 'circle',
          alpha: 0.2
        });
      }
      break;
      
    // â”€â”€â”€ HISTORY: Ancient Aged Wood â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'HISTORY':
      // Dark weathered wood
      ctx.fillStyle = '#5a4428';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Age cracks
      ctx.strokeStyle = '#3a2818';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 5; i++) {
        const cx = x - shelfW/2 + Math.random() * shelfW;
        const cy = y - shelfH/2 + Math.random() * shelfH;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + rnd(-5, 5), cy + rnd(3, 8));
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Iron brackets (aged)
      ctx.fillStyle = '#4a3a2a';
      ctx.fillRect(x - shelfW/2 + 3, y - shelfH/2 + 2, 4, 10);
      ctx.fillRect(x + shelfW/2 - 7, y - shelfH/2 + 2, 4, 10);
      ctx.fillRect(x - shelfW/2 + 3, y + shelfH/2 - 12, 4, 10);
      ctx.fillRect(x + shelfW/2 - 7, y + shelfH/2 - 12, 4, 10);
      
      // Rusty nails
      ctx.fillStyle = '#6a4a2a';
      for (let i = 0; i < 6; i++) {
        ctx.fillRect(x - shelfW/2 + 10 + i * 11, y - shelfH/2 + 5, 2, 2);
      }
      
      // Ancient scrolls and old books
      ctx.fillStyle = '#d4b896';
      ctx.globalAlpha = 0.5;
      ctx.fillRect(x - 25, y + 15, 8, 3); // Scroll
      ctx.fillRect(x - 15, y + 12, 6, 10); // Old book
      ctx.fillRect(x, y + 14, 5, 8); // Small book
      ctx.globalAlpha = 1;
      
      // Clock/hourglass icon
      ctx.strokeStyle = '#8a6a4a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 28, y - 18, 4, 0, Math.PI * 2);
      ctx.stroke();
      break;
      
    // â”€â”€â”€ SCIENCE: Modern Industrial Steel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCIENCE SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Laboratory Theme - Beakers, Molecules, Formulas, Discovery!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'SCIENCE':
      // Clean laboratory white background
      ctx.fillStyle = '#f5f8fa';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Subtle grid pattern (lab paper)
      ctx.strokeStyle = '#e0e8f0';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 8; i++) {
        // Vertical lines
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2 + i * 15, y - shelfH/2);
        ctx.lineTo(x - shelfW/2 + i * 15, y + shelfH/2);
        ctx.stroke();
        // Horizontal lines
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, y - shelfH/2 + i * 10);
        ctx.lineTo(x + shelfW/2, y - shelfH/2 + i * 10);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Metallic frame border (lab cabinet)
      ctx.strokeStyle = '#7a8a9a';
      ctx.lineWidth = 4;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner metallic edge
      ctx.strokeStyle = '#9aaaba';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.strokeRect(x - shelfW/2 + 3, y - shelfH/2 + 3, shelfW - 6, shelfH - 6);
      ctx.globalAlpha = 1;
      
      // Corner rivets (metal fasteners)
      const rivetCorners = [
        {x: x - shelfW/2 + 6, y: y - shelfH/2 + 6},
        {x: x + shelfW/2 - 6, y: y - shelfH/2 + 6},
        {x: x - shelfW/2 + 6, y: y + shelfH/2 - 6},
        {x: x + shelfW/2 - 6, y: y + shelfH/2 - 6}
      ];
      for (const rivet of rivetCorners) {
        // Outer rivet
        ctx.fillStyle = '#5a6a7a';
        ctx.beginPath();
        ctx.arc(rivet.x, rivet.y, 3, 0, Math.PI * 2);
        ctx.fill();
        // Inner shine
        ctx.fillStyle = '#9aaaba';
        ctx.beginPath();
        ctx.arc(rivet.x - 0.5, rivet.y - 0.5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        // Center hole
        ctx.fillStyle = '#3a4a5a';
        ctx.beginPath();
        ctx.arc(rivet.x, rivet.y, 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // â•â•â• TOP LEFT: ERLENMEYER FLASK (Large, Detailed) â•â•â•
      const flaskX = x - shelfW/2 + 25;
      const flaskY = y - shelfH/2 + 30;
      
      // Flask body (conical)
      ctx.strokeStyle = '#4a8ac2';
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(flaskX - 8, flaskY + 12);
      ctx.lineTo(flaskX - 4, flaskY - 5);
      ctx.lineTo(flaskX - 3, flaskY - 8);
      ctx.lineTo(flaskX + 3, flaskY - 8);
      ctx.lineTo(flaskX + 4, flaskY - 5);
      ctx.lineTo(flaskX + 8, flaskY + 12);
      ctx.stroke();
      
      // Flask neck
      ctx.beginPath();
      ctx.moveTo(flaskX - 3, flaskY - 8);
      ctx.lineTo(flaskX - 3, flaskY - 12);
      ctx.lineTo(flaskX + 3, flaskY - 12);
      ctx.lineTo(flaskX + 3, flaskY - 8);
      ctx.stroke();
      
      // Flask bottom
      ctx.beginPath();
      ctx.moveTo(flaskX - 8, flaskY + 12);
      ctx.lineTo(flaskX + 8, flaskY + 12);
      ctx.stroke();
      
      // Liquid inside (blue chemical)
      ctx.fillStyle = '#4ac2e8';
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(flaskX - 7, flaskY + 8);
      ctx.lineTo(flaskX - 5, flaskY + 2);
      ctx.lineTo(flaskX + 5, flaskY + 2);
      ctx.lineTo(flaskX + 7, flaskY + 8);
      ctx.lineTo(flaskX + 7, flaskY + 11);
      ctx.lineTo(flaskX - 7, flaskY + 11);
      ctx.closePath();
      ctx.fill();
      
      // Liquid surface (wavy)
      ctx.strokeStyle = '#4a8ac2';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(flaskX - 5, flaskY + 2);
      ctx.quadraticCurveTo(flaskX - 2, flaskY + 1, flaskX, flaskY + 2);
      ctx.quadraticCurveTo(flaskX + 2, flaskY + 3, flaskX + 5, flaskY + 2);
      ctx.stroke();
      
      // Glass shine
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(flaskX - 3, flaskY - 10);
      ctx.lineTo(flaskX - 2, flaskY + 5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Bubbles rising (animated)
      if (Math.random() < 0.15 * particleChanceMultiplier) {
        const bubbleX = flaskX + rnd(-4, 4);
        const bubbleY = flaskY + 10;
        particles.push({
          x: bubbleX,
          y: bubbleY,
          vx: 0,
          vy: -25,
          life: 1000,
          maxLife: 1000,
          color: '#ffffff',
          size: rnd(1.5, 3),
          type: 'circle',
          alpha: 0.7
        });
      }
      
      // â•â•â• TOP CENTER: DNA HELIX (Rotating) â•â•â•
      const dnaX = x;
      const dnaY = y - shelfH/2 + 22;
      const dnaRotation = time * 0.002;
      
      ctx.save();
      ctx.translate(dnaX, dnaY);
      
      // DNA strands (double helix)
      ctx.strokeStyle = '#4ac28a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      
      // First strand
      ctx.beginPath();
      for (let i = 0; i < 20; i++) {
        const t = i / 20;
        const yPos = t * 25 - 12;
        const xPos = Math.sin(t * Math.PI * 3 + dnaRotation) * 6;
        if (i === 0) ctx.moveTo(xPos, yPos);
        else ctx.lineTo(xPos, yPos);
      }
      ctx.stroke();
      
      // Second strand (opposite phase)
      ctx.strokeStyle = '#8a4ac2';
      ctx.beginPath();
      for (let i = 0; i < 20; i++) {
        const t = i / 20;
        const yPos = t * 25 - 12;
        const xPos = Math.sin(t * Math.PI * 3 + dnaRotation + Math.PI) * 6;
        if (i === 0) ctx.moveTo(xPos, yPos);
        else ctx.lineTo(xPos, yPos);
      }
      ctx.stroke();
      
      // Base pairs (connecting rungs)
      ctx.strokeStyle = '#c28a4a';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 8; i++) {
        const t = i / 8;
        const yPos = t * 25 - 12;
        const x1 = Math.sin(t * Math.PI * 3 + dnaRotation) * 6;
        const x2 = Math.sin(t * Math.PI * 3 + dnaRotation + Math.PI) * 6;
        ctx.beginPath();
        ctx.moveTo(x1, yPos);
        ctx.lineTo(x2, yPos);
        ctx.stroke();
        
        // Base pair dots
        ctx.fillStyle = '#c28a4a';
        ctx.beginPath();
        ctx.arc(x1, yPos, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x2, yPos, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: MICROSCOPE (Detailed) â•â•â•
      const microscopeX = x + shelfW/2 - 22;
      const microscopeY = y - shelfH/2 + 28;
      
      // Base
      ctx.fillStyle = '#5a6a7a';
      ctx.fillRect(microscopeX - 6, microscopeY + 10, 12, 3);
      
      // Stage
      ctx.fillRect(microscopeX - 4, microscopeY + 2, 8, 2);
      
      // Pillar
      ctx.fillRect(microscopeX + 2, microscopeY - 8, 2, 10);
      
      // Arm (angled)
      ctx.save();
      ctx.translate(microscopeX + 3, microscopeY - 8);
      ctx.rotate(-0.4);
      ctx.fillRect(0, 0, 2, 10);
      ctx.restore();
      
      // Eyepiece
      ctx.fillStyle = '#3a4a5a';
      ctx.fillRect(microscopeX - 2, microscopeY - 15, 3, 5);
      
      // Objective lens (bottom)
      ctx.fillStyle = '#7a8a9a';
      ctx.beginPath();
      ctx.arc(microscopeX + 1, microscopeY + 2, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Lens shine
      ctx.fillStyle = '#c8d8e8';
      ctx.beginPath();
      ctx.arc(microscopeX + 0.5, microscopeY + 1.5, 1, 0, Math.PI * 2);
      ctx.fill();
      
      // â•â•â• LEFT SIDE: PERIODIC TABLE SECTION â•â•â•
      const tableX = x - shelfW/2 + 15;
      const tableY = y;
      
      // Periodic table grid (6 elements shown)
      const elements = [
        {x: 0, y: 0, symbol: 'H', color: '#ff6b6b'},
        {x: 12, y: 0, symbol: 'C', color: '#4a8ac2'},
        {x: 24, y: 0, symbol: 'N', color: '#4ac28a'},
        {x: 0, y: 10, symbol: 'O', color: '#c24a8a'},
        {x: 12, y: 10, symbol: 'Fe', color: '#c28a4a'},
        {x: 24, y: 10, symbol: 'Au', color: '#d4af37'}
      ];
      
      for (const elem of elements) {
        // Element box
        ctx.strokeStyle = elem.color;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.6;
        ctx.strokeRect(tableX + elem.x, tableY + elem.y, 10, 8);
        
        // Element symbol
        ctx.fillStyle = elem.color;
        ctx.globalAlpha = 0.8;
        ctx.font = 'bold 6px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(elem.symbol, tableX + elem.x + 5, tableY + elem.y + 6);
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: ROTATING ATOM MODEL (3D Effect) â•â•â•
      const atomX = x + 10;
      const atomY = y + 5;
      const atomRotation = time * 0.003;
      
      ctx.save();
      ctx.translate(atomX, atomY);
      
      // Electron orbits (3 orbital paths)
      const orbitAngles = [0, Math.PI / 3, -Math.PI / 3];
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.rotate(orbitAngles[i] + atomRotation);
        
        // Orbit path
        ctx.strokeStyle = '#4ac28a';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.ellipse(0, 0, 10, 3, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Electron (moving along orbit)
        const electronAngle = atomRotation * 2 + i * Math.PI * 2 / 3;
        const electronX = Math.cos(electronAngle) * 10;
        const electronY = Math.sin(electronAngle) * 3;
        
        ctx.fillStyle = '#4a8ac2';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(electronX, electronY, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Electron glow
        ctx.fillStyle = '#4ac2e8';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(electronX, electronY, 3.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Nucleus (protons + neutrons)
      ctx.fillStyle = '#c24a4a';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Nucleus detail (smaller particles)
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        ctx.fillStyle = i % 2 === 0 ? '#c24a4a' : '#4a8ac2';
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * 1.5, Math.sin(angle) * 1.5, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• RIGHT SIDE: CHEMICAL FORMULA (E=mcÂ²) â•â•â•
      const formulaX = x + shelfW/2 - 25;
      const formulaY = y + 8;
      
      ctx.fillStyle = '#2a4a6a';
      ctx.globalAlpha = 0.7;
      ctx.font = 'bold 12px "Times New Roman"';
      ctx.textAlign = 'center';
      ctx.fillText('E=mcÂ²', formulaX, formulaY);
      
      // Formula underline
      ctx.strokeStyle = '#4ac28a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(formulaX - 15, formulaY + 2);
      ctx.lineTo(formulaX + 15, formulaY + 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM LEFT: TEST TUBES RACK â•â•â•
      const rackX = x - shelfW/2 + 20;
      const rackY = y + shelfH/2 - 18;
      
      // Rack base
      ctx.fillStyle = '#7a8a9a';
      ctx.fillRect(rackX - 8, rackY + 14, 16, 2);
      
      // Test tubes (3 tubes)
      const tubeColors = ['#ff6b9d', '#4ac2e8', '#c2e84a'];
      for (let i = 0; i < 3; i++) {
        const tubeX = rackX - 5 + i * 5;
        
        // Tube
        ctx.strokeStyle = '#6a8aaa';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(tubeX - 1.5, rackY + 14);
        ctx.lineTo(tubeX - 1.5, rackY + 2);
        ctx.lineTo(tubeX + 1.5, rackY + 2);
        ctx.lineTo(tubeX + 1.5, rackY + 14);
        ctx.stroke();
        
        // Liquid inside
        ctx.fillStyle = tubeColors[i];
        ctx.globalAlpha = 0.5;
        ctx.fillRect(tubeX - 1, rackY + 8, 2, 6);
        
        // Cork/cap
        ctx.fillStyle = '#8a6a4a';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(tubeX - 1.5, rackY + 1, 3, 1.5);
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM CENTER: MOLECULAR STRUCTURE (Benzene Ring) â•â•â•
      const benzeneX = x;
      const benzeneY = y + shelfH/2 - 12;
      
      ctx.strokeStyle = '#4a8ac2';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      
      // Hexagon structure
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const px = benzeneX + Math.cos(angle) * 6;
        const py = benzeneY + Math.sin(angle) * 6;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Inner circle (aromatic)
      ctx.beginPath();
      ctx.arc(benzeneX, benzeneY, 4, 0, Math.PI * 2);
      ctx.stroke();
      
      // Carbon atoms at vertices
      ctx.fillStyle = '#2a4a6a';
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const px = benzeneX + Math.cos(angle) * 6;
        const py = benzeneY + Math.sin(angle) * 6;
        ctx.beginPath();
        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM RIGHT: PETRI DISH with Bacteria â•â•â•
      const petriX = x + shelfW/2 - 18;
      const petriY = y + shelfH/2 - 12;
      
      // Dish outline
      ctx.strokeStyle = '#6a8aaa';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(petriX, petriY, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      // Agar (growth medium)
      ctx.fillStyle = '#f0e8d0';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(petriX, petriY, 7, 0, Math.PI * 2);
      ctx.fill();
      
      // Bacteria colonies (colorful dots)
      const bacteriaPositions = [
        {x: -3, y: -2, color: '#8a4ac2', size: 1.5},
        {x: 2, y: -3, color: '#4ac28a', size: 1.2},
        {x: -2, y: 2, color: '#c24a8a', size: 1.8},
        {x: 3, y: 1, color: '#4a8ac2', size: 1.3},
        {x: 0, y: 0, color: '#c2c24a', size: 1.6}
      ];
      
      for (const bacteria of bacteriaPositions) {
        ctx.fillStyle = bacteria.color;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(petriX + bacteria.x, petriY + bacteria.y, bacteria.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Bacteria glow
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(petriX + bacteria.x, petriY + bacteria.y, bacteria.size + 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• SCIENCE BOOKS (Textbooks with formulas) â•â•â•
      const scienceBooks = [
        {x: -50, w: 9, h: 16, color: '#4a8ac2', label: 'Hâ‚‚O'},
        {x: -38, w: 8, h: 18, color: '#4ac28a', label: 'DNA'},
        {x: -28, w: 9, h: 15, color: '#c28a4a', label: 'Fe'},
        {x: -17, w: 8, h: 17, color: '#8a4ac2', label: 'COâ‚‚'},
        {x: -7, w: 9, h: 16, color: '#c24a8a', label: 'Oâ‚‚'},
        {x: 4, w: 8, h: 19, color: '#4ac2e8', label: 'NaCl'},
        {x: 14, w: 9, h: 14, color: '#c2c24a', label: 'pH'},
        {x: 25, w: 8, h: 17, color: '#ff6b9d', label: 'ATP'}
      ];
      
      for (const book of scienceBooks) {
        // Book spine
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(x + book.x, y + shelfH/2 - 26 - book.h, book.w, book.h);
        
        // White label stripe
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(x + book.x + 1, y + shelfH/2 - 20, book.w - 2, 3);
        
        // Formula/label on spine
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.9;
        ctx.font = 'bold 6px Arial';
        ctx.textAlign = 'center';
        ctx.save();
        ctx.translate(x + book.x + book.w/2, y + shelfH/2 - 14);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(book.label, 0, 2);
        ctx.restore();
        
        // Book edge highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(x + book.x, y + shelfH/2 - 26 - book.h, 1, book.h);
        
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• FLOATING PARTICLES: Sparkles (Discovery moments!) â•â•â•
      if (Math.random() < 0.03 * particleChanceMultiplier) {
        const sparkleX = x + rnd(-shelfW/2 + 15, shelfW/2 - 15);
        const sparkleY = y + rnd(-shelfH/2 + 15, shelfH/2 - 15);
        
        particles.push({
          x: sparkleX,
          y: sparkleY,
          vx: rnd(-10, 10),
          vy: rnd(-10, 10),
          life: 1200,
          maxLife: 1200,
          color: Math.random() < 0.5 ? '#4ac2e8' : '#4ac28a',
          size: rnd(2, 4),
          type: 'sparkle',
          alpha: 0.8
        });
      }
      break;
      
    // â”€â”€â”€ SCI-FI: Futuristic Tech â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCI-FI SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Futuristic Technology Theme - Holograms, Robots, Data, Space!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'SCIFI':
      // Deep space metallic background
      ctx.fillStyle = '#1a2a3a';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Tech panel gradient
      const scifiGrad = ctx.createLinearGradient(x, y - shelfH/2, x, y + shelfH/2);
      scifiGrad.addColorStop(0, '#2a4a6a');
      scifiGrad.addColorStop(0.5, '#1a3a5a');
      scifiGrad.addColorStop(1, '#0a2a4a');
      ctx.fillStyle = scifiGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Metallic panel lines (horizontal)
      ctx.strokeStyle = '#3a5a7a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, y - shelfH/2 + 14 + i * 14);
        ctx.lineTo(x + shelfW/2, y - shelfH/2 + 14 + i * 14);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Neon cyan border (glowing)
      ctx.strokeStyle = '#4ac8ff';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.8;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner glow border
      ctx.strokeStyle = '#8adfff';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      ctx.strokeRect(x - shelfW/2 + 2, y - shelfH/2 + 2, shelfW - 4, shelfH - 4);
      ctx.globalAlpha = 1;
      
      // Corner bolts/rivets (tech detail)
      const techCorners = [
        {x: x - shelfW/2 + 5, y: y - shelfH/2 + 5},
        {x: x + shelfW/2 - 5, y: y - shelfH/2 + 5},
        {x: x - shelfW/2 + 5, y: y + shelfH/2 - 5},
        {x: x + shelfW/2 - 5, y: y + shelfH/2 - 5}
      ];
      for (const corner of techCorners) {
        // Hexagonal bolt
        ctx.strokeStyle = '#5a7a9a';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const px = corner.x + Math.cos(angle) * 2;
          const py = corner.y + Math.sin(angle) * 2;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        
        // Center hole
        ctx.fillStyle = '#2a3a4a';
        ctx.beginPath();
        ctx.arc(corner.x, corner.y, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP LEFT: HOLOGRAPHIC DISPLAY â•â•â•
      const holoX = x - shelfW/2 + 22;
      const holoY = y - shelfH/2 + 22;
      const holoPulse = Math.sin(time * 0.005) * 0.3 + 0.7;
      const holoFlicker = Math.random() < 0.95 ? 1 : 0.3; // Occasional glitch
      
      // Hologram projector base
      ctx.fillStyle = '#4a5a6a';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(holoX - 6, holoY + 8, 12, 3);
      
      // Projector lens
      ctx.fillStyle = '#4ac8ff';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(holoX, holoY + 7, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Holographic figure (rotating wireframe head)
      ctx.save();
      ctx.translate(holoX, holoY);
      ctx.rotate(time * 0.002);
      ctx.globalAlpha = holoPulse * 0.6 * holoFlicker;
      
      // Head outline
      ctx.strokeStyle = '#4ac8ff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(0, -2, 5, 6, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Face grid lines
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.moveTo(i * 3, -8);
        ctx.lineTo(i * 3, 4);
        ctx.stroke();
      }
      for (let i = -2; i <= 1; i++) {
        ctx.beginPath();
        ctx.ellipse(0, -2, 5, 6 - Math.abs(i * 2), 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Hologram scan lines
      ctx.globalAlpha = 0.3 * holoFlicker;
      const scanPos = (time * 0.01) % 12;
      ctx.strokeStyle = '#8adfff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-5, -8 + scanPos);
      ctx.lineTo(5, -8 + scanPos);
      ctx.stroke();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP CENTER: ROBOT HEAD â•â•â•
      const robotX = x;
      const robotY = y - shelfH/2 + 20;
      const robotBlink = Math.floor(time * 0.002) % 10 === 0 ? 0.3 : 1;
      
      // Robot head (rectangular)
      ctx.fillStyle = '#6a7a8a';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(robotX - 7, robotY - 8, 14, 12);
      
      // Head highlight
      ctx.fillStyle = '#8a9aaa';
      ctx.globalAlpha = 0.5;
      ctx.fillRect(robotX - 6, robotY - 7, 5, 5);
      
      // Antenna
      ctx.strokeStyle = '#7a8a9a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(robotX, robotY - 8);
      ctx.lineTo(robotX, robotY - 12);
      ctx.stroke();
      
      // Antenna tip (blinking light)
      const antennaBlink = Math.sin(time * 0.015) * 0.5 + 0.5;
      ctx.fillStyle = '#ff4a4a';
      ctx.globalAlpha = antennaBlink;
      ctx.beginPath();
      ctx.arc(robotX, robotY - 12, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Robot eyes (LED)
      ctx.fillStyle = '#4aff8a';
      ctx.globalAlpha = 0.9 * robotBlink;
      ctx.fillRect(robotX - 5, robotY - 4, 3, 2);
      ctx.fillRect(robotX + 2, robotY - 4, 3, 2);
      
      // Eye glow
      ctx.fillStyle = '#4aff8a';
      ctx.globalAlpha = 0.4 * robotBlink;
      ctx.fillRect(robotX - 6, robotY - 5, 5, 4);
      ctx.fillRect(robotX + 1, robotY - 5, 5, 4);
      
      // Robot mouth (speaker grille)
      ctx.strokeStyle = '#4a5a6a';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(robotX - 4 + i * 2, robotY + 1);
        ctx.lineTo(robotX - 4 + i * 2, robotY + 3);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: SPACESHIP (detailed) â•â•â•
      const shipX = x + shelfW/2 - 20;
      const shipY = y - shelfH/2 + 20;
      const shipThrust = Math.sin(time * 0.02) * 0.3 + 0.7;
      
      // Ship body (sleek design)
      ctx.fillStyle = '#7a8a9a';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(shipX + 8, shipY);
      ctx.lineTo(shipX + 4, shipY - 3);
      ctx.lineTo(shipX - 6, shipY - 3);
      ctx.lineTo(shipX - 8, shipY);
      ctx.lineTo(shipX - 6, shipY + 3);
      ctx.lineTo(shipX + 4, shipY + 3);
      ctx.closePath();
      ctx.fill();
      
      // Cockpit window
      ctx.fillStyle = '#4ac8ff';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(shipX + 3, shipY, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Wing details
      ctx.strokeStyle = '#5a6a7a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(shipX - 4, shipY);
      ctx.lineTo(shipX - 4, shipY - 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(shipX - 4, shipY);
      ctx.lineTo(shipX - 4, shipY + 2);
      ctx.stroke();
      
      // Engine glow (animated)
      ctx.fillStyle = '#4aafff';
      ctx.globalAlpha = shipThrust * 0.8;
      ctx.beginPath();
      ctx.arc(shipX - 8, shipY, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Exhaust trail
      for (let i = 0; i < 4; i++) {
        ctx.fillStyle = i % 2 === 0 ? '#4aafff' : '#8acfff';
        ctx.globalAlpha = (1 - i * 0.25) * shipThrust * 0.5;
        ctx.beginPath();
        ctx.arc(shipX - 10 - i * 2, shipY + (i % 2 === 0 ? -1 : 1), 1.5 - i * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• LEFT SIDE: PLANET WITH RINGS â•â•â•
      const planetX = x - shelfW/2 + 18;
      const planetY = y + 5;
      
      // Planet body
      ctx.fillStyle = '#8aff4a';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(planetX, planetY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Planet surface details (continents)
      ctx.fillStyle = '#6adf2a';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(planetX - 2, planetY - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(planetX + 3, planetY + 1, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Rings (elliptical)
      ctx.strokeStyle = '#aaffaa';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.ellipse(planetX, planetY, 12, 3, -Math.PI / 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // Ring shadow on planet
      ctx.strokeStyle = '#6adf2a';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.ellipse(planetX, planetY, 6, 1.5, -Math.PI / 6, 0, Math.PI);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: DATA STREAM VISUALIZATION â•â•â•
      const dataStreamX = x - 10;
      const dataStreamY = y + 8;
      
      // Data nodes (connected network)
      const dataNodes = [
        {x: 0, y: 0},
        {x: -8, y: -6},
        {x: 8, y: -6},
        {x: -6, y: 6},
        {x: 6, y: 6}
      ];
      
      // Connecting lines (data flow)
      ctx.strokeStyle = '#4ac8ff';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      for (let i = 1; i < dataNodes.length; i++) {
        ctx.beginPath();
        ctx.moveTo(dataStreamX + dataNodes[0].x, dataStreamY + dataNodes[0].y);
        ctx.lineTo(dataStreamX + dataNodes[i].x, dataStreamY + dataNodes[i].y);
        ctx.stroke();
      }
      
      // Data flow animation (dots traveling along lines)
      const flowProgress = (time * 0.003) % 1;
      ctx.fillStyle = '#8adfff';
      ctx.globalAlpha = 0.8;
      for (let i = 1; i < dataNodes.length; i++) {
        const startNode = dataNodes[0];
        const endNode = dataNodes[i];
        const flowX = dataStreamX + startNode.x + (endNode.x - startNode.x) * flowProgress;
        const flowY = dataStreamY + startNode.y + (endNode.y - startNode.y) * flowProgress;
        ctx.beginPath();
        ctx.arc(flowX, flowY, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Data nodes (glowing dots)
      for (const node of dataNodes) {
        const nodePulse = Math.sin(time * 0.004 + node.x + node.y) * 0.3 + 0.7;
        ctx.fillStyle = '#4ac8ff';
        ctx.globalAlpha = nodePulse * 0.9;
        ctx.beginPath();
        ctx.arc(dataStreamX + node.x, dataStreamY + node.y, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Node glow
        ctx.globalAlpha = nodePulse * 0.4;
        ctx.beginPath();
        ctx.arc(dataStreamX + node.x, dataStreamY + node.y, 3.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• RIGHT SIDE: SPACE STATION SECTION â•â•â•
      const stationX = x + shelfW/2 - 18;
      const stationY = y + 8;
      const stationRotate = time * 0.001;
      
      ctx.save();
      ctx.translate(stationX, stationY);
      ctx.rotate(stationRotate);
      ctx.globalAlpha = 0.8;
      
      // Station hub (hexagon)
      ctx.strokeStyle = '#7a8a9a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const px = Math.cos(angle) * 6;
        const py = Math.sin(angle) * 6;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Station modules (extending arms)
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const armX = Math.cos(angle) * 6;
        const armY = Math.sin(angle) * 6;
        
        ctx.fillStyle = '#6a7a8a';
        ctx.fillRect(armX - 1, armY - 1, 2, 4);
      }
      
      // Central core (glowing)
      ctx.fillStyle = '#4ac8ff';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM: ADVANCED CIRCUIT BOARD â•â•â•
      const circuitY = y + shelfH/2 - 20;
      
      // Circuit traces (cyan lines)
      ctx.strokeStyle = '#3a8aaa';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      
      // Horizontal traces
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2 + 10, circuitY + i * 4);
        ctx.lineTo(x + shelfW/2 - 10, circuitY + i * 4);
        ctx.stroke();
      }
      
      // Vertical traces
      for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2 + 15 + i * 12, circuitY - 3);
        ctx.lineTo(x - shelfW/2 + 15 + i * 12, circuitY + 10);
        ctx.stroke();
      }
      
      // Circuit nodes (connection points)
      ctx.fillStyle = '#4ac8ff';
      ctx.globalAlpha = 0.7;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 3; j++) {
          ctx.beginPath();
          ctx.arc(x - shelfW/2 + 15 + i * 12, circuitY + j * 4, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• SCI-FI BOOKS (Metallic Holographic Spines) â•â•â•
      const scifiBooks = [
        {x: -52, w: 8, h: 15, color: '#3a6a8a', title: 'âˆ'},
        {x: -42, w: 7, h: 17, color: '#2a5a7a', title: 'âš›'},
        {x: -33, w: 8, h: 14, color: '#4a7a9a', title: 'â—ˆ'},
        {x: -23, w: 7, h: 16, color: '#2a4a6a', title: 'â¬¡'},
        {x: -14, w: 8, h: 15, color: '#3a6a8a', title: 'â—‰'},
        {x: -4, w: 7, h: 18, color: '#5a8aaa', title: 'âŠ•'},
        {x: 5, w: 8, h: 14, color: '#2a5a7a', title: 'â—Š'},
        {x: 15, w: 7, h: 16, color: '#4a7a9a', title: 'â¬¢'}
      ];
      
      for (const book of scifiBooks) {
        // Book spine (metallic gradient)
        const bookGrad = ctx.createLinearGradient(
          x + book.x, y + shelfH/2 - 26 - book.h,
          x + book.x + book.w, y + shelfH/2 - 26
        );
        bookGrad.addColorStop(0, book.color);
        bookGrad.addColorStop(0.5, '#5a7a9a');
        bookGrad.addColorStop(1, book.color);
        ctx.fillStyle = bookGrad;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(x + book.x, y + shelfH/2 - 26 - book.h, book.w, book.h);
        
        // Cyan holographic stripe
        ctx.fillStyle = '#4ac8ff';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(x + book.x + 1, y + shelfH/2 - 24, book.w - 2, 2);
        
        // Sci-fi symbol on spine
        ctx.fillStyle = '#8adfff';
        ctx.globalAlpha = 0.8;
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(book.title, x + book.x + book.w/2, y + shelfH/2 - 16);
        
        // Edge highlight (metallic shine)
        ctx.fillStyle = 'rgba(138, 223, 255, 0.4)';
        ctx.fillRect(x + book.x, y + shelfH/2 - 26 - book.h, 1, book.h);
        
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• ANIMATED ELEMENTS â•â•â•
      
      // LED Status Lights (sequenced blinking)
      const ledColors = ['#4ac8ff', '#8aff4a', '#ff4ac8'];
      const ledSequence = Math.floor(time * 0.003) % 3;
      
      for (let i = 0; i < 3; i++) {
        const isActive = (i === ledSequence);
        const brightness = isActive ? (0.9 + Math.sin(time * 0.01) * 0.1) : 0.3;
        
        ctx.fillStyle = ledColors[i];
        ctx.globalAlpha = brightness;
        ctx.beginPath();
        ctx.arc(x - shelfW/2 + 10 + i * 10, y - shelfH/2 + 8, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Active LED glow
        if (isActive) {
          ctx.globalAlpha = 0.4;
          ctx.beginPath();
          ctx.arc(x - shelfW/2 + 10 + i * 10, y - shelfH/2 + 8, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
      
      // Scanning line (vertical sweep)
      const scanProgress = (time * 0.002) % 1;
      const scanX = x - shelfW/2 + scanProgress * shelfW;
      ctx.strokeStyle = '#4ac8ff';
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(scanX, y - shelfH/2 + 12);
      ctx.lineTo(scanX, y + shelfH/2 - 12);
      ctx.stroke();
      
      // Scan glow
      ctx.globalAlpha = 0.2;
      ctx.lineWidth = 6;
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• FLOATING PARTICLES: Digital Sparks â•â•â•
      if (Math.random() < 0.04 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2 + 10, shelfW/2 - 10),
          y: y + rnd(-shelfH/2 + 10, shelfH/2 - 10),
          vx: rnd(-15, 15),
          vy: rnd(-15, 15),
          life: 1000,
          maxLife: 1000,
          color: Math.random() < 0.5 ? '#4ac8ff' : '#8aff4a',
          size: rnd(1.5, 3),
          type: 'sparkle',
          alpha: 0.9
        });
      }
      break;
      
    // â”€â”€â”€ TABLETS: Ancient Stone â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TABLETS SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Ancient Egyptian Theme - Pyramids, Hieroglyphs, Pharaohs, Mysteries!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'TABLETS':
      // Desert sandstone background
      ctx.fillStyle = '#c8a878';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Sandstone gradient (weathered look)
      const sandGrad = ctx.createLinearGradient(x, y - shelfH/2, x, y + shelfH/2);
      sandGrad.addColorStop(0, '#d8b888');
      sandGrad.addColorStop(0.5, '#c8a878');
      sandGrad.addColorStop(1, '#a88858');
      ctx.fillStyle = sandGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Stone texture (rough, aged surface)
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 35; i++) {
        ctx.fillStyle = i % 3 === 0 ? '#d8b888' : (i % 3 === 1 ? '#b89868' : '#988858');
        const sx = x - shelfW/2 + rnd(0, shelfW);
        const sy = y - shelfH/2 + rnd(0, shelfH);
        ctx.fillRect(sx, sy, rnd(2, 5), rnd(2, 5));
      }
      ctx.globalAlpha = 1;
      
      // Ancient carved border (deep relief)
      ctx.strokeStyle = '#6a5a4a';
      ctx.lineWidth = 4;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner decorative border (hieroglyphic pattern)
      ctx.strokeStyle = '#8a7a6a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.strokeRect(x - shelfW/2 + 4, y - shelfH/2 + 4, shelfW - 8, shelfH - 8);
      ctx.globalAlpha = 1;
      
      // Corner decorative elements (lotus flowers)
      const lotusCorners = [
        {x: x - shelfW/2 + 8, y: y - shelfH/2 + 8, angle: 0},
        {x: x + shelfW/2 - 8, y: y - shelfH/2 + 8, angle: Math.PI/2},
        {x: x - shelfW/2 + 8, y: y + shelfH/2 - 8, angle: -Math.PI/2},
        {x: x + shelfW/2 - 8, y: y + shelfH/2 - 8, angle: Math.PI}
      ];
      
      for (const lotus of lotusCorners) {
        ctx.save();
        ctx.translate(lotus.x, lotus.y);
        ctx.rotate(lotus.angle);
        ctx.strokeStyle = '#6a5a4a';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.6;
        
        // Lotus petals (3)
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.arc(i * 2 - 2, 0, 2, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• TOP LEFT: PYRAMID (with golden capstone) â•â•â•
      const pyramidX = x - shelfW/2 + 22;
      const pyramidY = y - shelfH/2 + 28;
      
      // Pyramid body (stone blocks)
      ctx.fillStyle = '#a89868';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(pyramidX, pyramidY - 16);
      ctx.lineTo(pyramidX - 12, pyramidY + 8);
      ctx.lineTo(pyramidX + 12, pyramidY + 8);
      ctx.closePath();
      ctx.fill();
      
      // Pyramid shading (left side darker)
      ctx.fillStyle = '#887848';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(pyramidX, pyramidY - 16);
      ctx.lineTo(pyramidX - 12, pyramidY + 8);
      ctx.lineTo(pyramidX, pyramidY + 8);
      ctx.closePath();
      ctx.fill();
      
      // Stone block lines (horizontal layers)
      ctx.strokeStyle = '#786838';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 5; i++) {
        const blockY = pyramidY + 6 - i * 5;
        const blockWidth = (i + 1) * 4;
        ctx.beginPath();
        ctx.moveTo(pyramidX - blockWidth, blockY);
        ctx.lineTo(pyramidX + blockWidth, blockY);
        ctx.stroke();
      }
      
      // Golden capstone (glowing)
      ctx.fillStyle = '#d4af37';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(pyramidX, pyramidY - 16);
      ctx.lineTo(pyramidX - 3, pyramidY - 12);
      ctx.lineTo(pyramidX + 3, pyramidY - 12);
      ctx.closePath();
      ctx.fill();
      
      // Capstone glow
      ctx.fillStyle = '#f0c850';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(pyramidX, pyramidY - 14, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP CENTER: EYE OF HORUS (large, detailed) â•â•â•
      const horusX = x;
      const horusY = y - shelfH/2 + 18;
      const horusPulse = Math.sin(time * 0.004) * 0.3 + 0.7;
      
      // Eye outline
      ctx.strokeStyle = '#6a5a4a';
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(horusX, horusY, 8, 5, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Pupil (mystical blue)
      ctx.fillStyle = '#4a8ac8';
      ctx.globalAlpha = horusPulse * 0.8;
      ctx.beginPath();
      ctx.arc(horusX, horusY, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Pupil glow (mystical power)
      ctx.fillStyle = '#4ac8e8';
      ctx.globalAlpha = horusPulse * 0.4;
      ctx.beginPath();
      ctx.arc(horusX, horusY, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye makeup lines (Egyptian style)
      ctx.strokeStyle = '#4a3a2a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      // Upper line
      ctx.beginPath();
      ctx.moveTo(horusX - 8, horusY);
      ctx.lineTo(horusX - 12, horusY - 2);
      ctx.stroke();
      // Lower spiral
      ctx.beginPath();
      ctx.moveTo(horusX + 8, horusY);
      ctx.quadraticCurveTo(horusX + 10, horusY + 3, horusX + 8, horusY + 5);
      ctx.stroke();
      // Lower line
      ctx.beginPath();
      ctx.moveTo(horusX, horusY + 5);
      ctx.lineTo(horusX - 2, horusY + 7);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: ANKH SYMBOL (large, ornate) â•â•â•
      const ankhX = x + shelfW/2 - 20;
      const ankhY = y - shelfH/2 + 22;
      
      // Ankh loop (top)
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(ankhX, ankhY - 6, 5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Ankh vertical (body)
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(ankhX, ankhY - 1);
      ctx.lineTo(ankhX, ankhY + 10);
      ctx.stroke();
      
      // Ankh horizontal (arms)
      ctx.beginPath();
      ctx.moveTo(ankhX - 6, ankhY + 2);
      ctx.lineTo(ankhX + 6, ankhY + 2);
      ctx.stroke();
      
      // Golden glow (symbol of life)
      ctx.strokeStyle = '#f0c850';
      ctx.lineWidth = 5;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(ankhX, ankhY - 6, 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• LEFT SIDE: SCARAB BEETLE (sacred symbol) â•â•â•
      const scarabX = x - shelfW/2 + 18;
      const scarabY = y + 2;
      
      // Scarab body
      ctx.fillStyle = '#4a8a4a';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.ellipse(scarabX, scarabY, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Scarab head
      ctx.fillStyle = '#3a7a3a';
      ctx.beginPath();
      ctx.arc(scarabX, scarabY - 8, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Wing pattern (decorative lines)
      ctx.strokeStyle = '#2a6a2a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(scarabX, scarabY - 6);
      ctx.lineTo(scarabX, scarabY + 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(scarabX - 4, scarabY - 4);
      ctx.lineTo(scarabX + 4, scarabY - 4);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(scarabX - 4, scarabY);
      ctx.lineTo(scarabX + 4, scarabY);
      ctx.stroke();
      
      // Scarab legs (6 legs)
      ctx.strokeStyle = '#3a7a3a';
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 3; i++) {
        const legY = scarabY - 2 + i * 3;
        // Left legs
        ctx.beginPath();
        ctx.moveTo(scarabX - 6, legY);
        ctx.lineTo(scarabX - 9, legY + 2);
        ctx.stroke();
        // Right legs
        ctx.beginPath();
        ctx.moveTo(scarabX + 6, legY);
        ctx.lineTo(scarabX + 9, legY + 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: PAPYRUS SCROLL (rolled) â•â•â•
      const papyrusX = x + 8;
      const papyrusY = y + 5;
      
      // Scroll paper (aged yellow)
      ctx.fillStyle = '#f0e8c8';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(papyrusX - 10, papyrusY - 6, 20, 12);
      
      // Scroll aging/stains
      ctx.fillStyle = '#d8c8a8';
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.arc(papyrusX + rnd(-8, 8), papyrusY + rnd(-4, 4), rnd(1, 3), 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Hieroglyphic writing on scroll
      ctx.strokeStyle = '#6a5a4a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 4; j++) {
          ctx.beginPath();
          ctx.moveTo(papyrusX - 8 + j * 4, papyrusY - 4 + i * 3);
          ctx.lineTo(papyrusX - 6 + j * 4, papyrusY - 4 + i * 3);
          ctx.stroke();
        }
      }
      
      // Rolled edges (wooden rods)
      ctx.fillStyle = '#8a6a4a';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(papyrusX - 11, papyrusY - 7, 2, 14);
      ctx.fillRect(papyrusX + 9, papyrusY - 7, 2, 14);
      
      // Rod details (caps)
      ctx.fillStyle = '#6a5a3a';
      ctx.fillRect(papyrusX - 11, papyrusY - 7, 2, 2);
      ctx.fillRect(papyrusX - 11, papyrusY + 5, 2, 2);
      ctx.fillRect(papyrusX + 9, papyrusY - 7, 2, 2);
      ctx.fillRect(papyrusX + 9, papyrusY + 5, 2, 2);
      ctx.globalAlpha = 1;
      
      // â•â•â• RIGHT SIDE: CANOPIC JAR (burial jar) â•â•â•
      const jarX = x + shelfW/2 - 16;
      const jarY = y + 8;
      
      // Jar body
      ctx.fillStyle = '#c8a878';
      ctx.globalAlpha = 0.9;
      ctx.fillRect(jarX - 5, jarY - 2, 10, 10);
      
      // Jar neck
      ctx.fillRect(jarX - 4, jarY - 6, 8, 4);
      
      // Jackal head lid (Anubis style)
      ctx.fillStyle = '#4a4a4a';
      ctx.globalAlpha = 0.8;
      // Head
      ctx.fillRect(jarX - 3, jarY - 10, 6, 4);
      // Snout
      ctx.fillRect(jarX - 2, jarY - 11, 4, 2);
      // Ears
      ctx.fillRect(jarX - 4, jarY - 11, 2, 3);
      ctx.fillRect(jarX + 2, jarY - 11, 2, 3);
      
      // Jar decorative bands (gold)
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(jarX - 5, jarY);
      ctx.lineTo(jarX + 5, jarY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(jarX - 5, jarY + 4);
      ctx.lineTo(jarX + 5, jarY + 4);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM: STONE TABLETS (carved hieroglyphs) â•â•â•
      const tablets = [
        {x: x - 38, y: y + shelfH/2 - 18, w: 12, h: 16},
        {x: x - 22, y: y + shelfH/2 - 20, w: 11, h: 18},
        {x: x - 8, y: y + shelfH/2 - 19, w: 12, h: 17},
        {x: x + 8, y: y + shelfH/2 - 21, w: 11, h: 19},
        {x: x + 23, y: y + shelfH/2 - 18, w: 12, h: 16}
      ];
      
      for (const tablet of tablets) {
        // Tablet stone
        ctx.fillStyle = '#988868';
        ctx.globalAlpha = 0.9;
        ctx.fillRect(tablet.x, tablet.y, tablet.w, tablet.h);
        
        // Tablet border (carved edge)
        ctx.strokeStyle = '#6a5a4a';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.7;
        ctx.strokeRect(tablet.x, tablet.y, tablet.w, tablet.h);
        
        // Carved hieroglyphs (lines)
        ctx.strokeStyle = '#5a4a3a';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;
        const numLines = Math.floor(tablet.h / 3) - 1;
        for (let i = 0; i < numLines; i++) {
          ctx.beginPath();
          ctx.moveTo(tablet.x + 2, tablet.y + 4 + i * 3);
          ctx.lineTo(tablet.x + tablet.w - 2, tablet.y + 4 + i * 3);
          ctx.stroke();
        }
        
        // Carved symbols (random hieroglyphs)
        ctx.fillStyle = '#6a5a4a';
        ctx.font = '6px serif';
        ctx.globalAlpha = 0.5;
        const symbols = ['â˜¥', 'ğ“‚€', 'ğ“¹', 'â˜¨', 'âœ¦'];
        const symbol = symbols[Math.floor(tablet.x) % symbols.length];
        ctx.fillText(symbol, tablet.x + 3, tablet.y + tablet.h - 3);
        
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• HIEROGLYPHIC BORDER DECORATIONS (top edge) â•â•â•
      const hieroglyphs = [
        {x: x - shelfW/2 + 45, y: y - shelfH/2 + 10, symbol: 'ğ“‚€'},
        {x: x - shelfW/2 + 60, y: y - shelfH/2 + 10, symbol: 'ğ“¹'},
        {x: x - shelfW/2 + 75, y: y - shelfH/2 + 10, symbol: 'â˜¥'},
        {x: x - shelfW/2 + 90, y: y - shelfH/2 + 10, symbol: 'ğ“ƒ­'}
      ];
      
      for (const glyph of hieroglyphs) {
        const glyphPulse = Math.sin(time * 0.003 + glyph.x) * 0.3 + 0.7;
        ctx.fillStyle = '#8a7a5a';
        ctx.globalAlpha = glyphPulse * 0.6;
        ctx.font = 'bold 8px serif';
        ctx.fillText(glyph.symbol, glyph.x, glyph.y);
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• SAND PARTICLES (desert dust) â•â•â•
      if (Math.random() < 0.03 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2, shelfW/2),
          y: y + shelfH/2,
          vx: rnd(-8, 8),
          vy: rnd(-20, -10),
          life: 1500,
          maxLife: 1500,
          color: '#c8a878',
          size: rnd(1.5, 3),
          type: 'circle',
          alpha: 0.6
        });
      }
      
      // â•â•â• MYSTICAL GLOWING HIEROGLYPHS (floating symbols) â•â•â•
      if (Math.random() < 0.04 * particleChanceMultiplier) {
        const glyphSymbols = ['â˜¥', 'ğ“‚€', 'ğ“¹', 'â—ˆ', 'âŠ•'];
        particles.push({
          x: x + rnd(-shelfW/2 + 10, shelfW/2 - 10),
          y: y - shelfH/2,
          vx: 0,
          vy: 25,
          life: 2500,
          maxLife: 2500,
          color: '#d4af37',
          size: 8,
          type: 'code',
          alpha: 0.5,
          char: glyphSymbols[rint(0, glyphSymbols.length - 1)]
        });
      }
      break;
      
    // â”€â”€â”€ MANGA: Japanese Style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MANGA SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Japanese Manga/Anime Theme - Chibi, Panels, Cherry Blossoms, Action!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'MANGA':
      // Clean white paper background (manga page)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Subtle halftone dot pattern (manga shading)
      ctx.fillStyle = '#f0f0f0';
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 40; i++) {
        const dotX = x - shelfW/2 + (i % 8) * 14 + 7;
        const dotY = y - shelfH/2 + Math.floor(i / 8) * 14 + 7;
        ctx.beginPath();
        ctx.arc(dotX, dotY, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // Bold black border (manga panel style)
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 4;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner panel border
      ctx.lineWidth = 2;
      ctx.strokeRect(x - shelfW/2 + 3, y - shelfH/2 + 3, shelfW - 6, shelfH - 6);
      
      // Red accent corners (Rising Sun inspired)
      ctx.fillStyle = '#ff4444';
      ctx.globalAlpha = 0.8;
      
      const cornerSize = 12;
      // Top-left
      ctx.beginPath();
      ctx.moveTo(x - shelfW/2, y - shelfH/2);
      ctx.lineTo(x - shelfW/2 + cornerSize, y - shelfH/2);
      ctx.lineTo(x - shelfW/2, y - shelfH/2 + cornerSize);
      ctx.closePath();
      ctx.fill();
      
      // Top-right
      ctx.beginPath();
      ctx.moveTo(x + shelfW/2, y - shelfH/2);
      ctx.lineTo(x + shelfW/2 - cornerSize, y - shelfH/2);
      ctx.lineTo(x + shelfW/2, y - shelfH/2 + cornerSize);
      ctx.closePath();
      ctx.fill();
      
      // Bottom-left
      ctx.beginPath();
      ctx.moveTo(x - shelfW/2, y + shelfH/2);
      ctx.lineTo(x - shelfW/2 + cornerSize, y + shelfH/2);
      ctx.lineTo(x - shelfW/2, y + shelfH/2 - cornerSize);
      ctx.closePath();
      ctx.fill();
      
      // Bottom-right
      ctx.beginPath();
      ctx.moveTo(x + shelfW/2, y + shelfH/2);
      ctx.lineTo(x + shelfW/2 - cornerSize, y + shelfH/2);
      ctx.lineTo(x + shelfW/2, y + shelfH/2 - cornerSize);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP CENTER: SPEECH BUBBLE WITH JAPANESE TEXT â•â•â•
      const bubbleX = x + 5;
      const bubbleY = y - shelfH/2 + 16;
      const bubblePulse = Math.sin(time * 0.004) * 0.1 + 1;
      
      ctx.save();
      ctx.translate(bubbleX, bubbleY);
      ctx.scale(bubblePulse, bubblePulse);
      
      // Speech bubble outline
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.95;
      
      ctx.beginPath();
      ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Speech bubble tail
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(-8, 6);
      ctx.lineTo(-12, 10);
      ctx.lineTo(-6, 8);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Japanese text (ãƒãƒ³ã‚¬ = "manga")
      ctx.fillStyle = '#1a1a1a';
      ctx.font = 'bold 8px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.9;
      ctx.fillText('ãƒãƒ³ã‚¬', 0, 3);
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: MANGA ACTION EFFECTS â•â•â•
      const actionX = x + shelfW/2 - 18;
      const actionY = y - shelfH/2 + 20;
      
      // Impact star burst
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const length = 8 + Math.sin(time * 0.008 + i) * 2;
        ctx.beginPath();
        ctx.moveTo(actionX, actionY);
        ctx.lineTo(actionX + Math.cos(angle) * length, actionY + Math.sin(angle) * length);
        ctx.stroke();
      }
      
      // Center impact circle
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(actionX, actionY, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: CHERRY BLOSSOM BRANCH (sakura) â•â•â•
      const branchX = x - 8;
      const branchY = y + 2;
      
      // Branch
      ctx.strokeStyle = '#8a6a5a';
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(branchX - 15, branchY + 8);
      ctx.quadraticCurveTo(branchX - 5, branchY + 2, branchX + 5, branchY - 2);
      ctx.quadraticCurveTo(branchX + 10, branchY - 4, branchX + 15, branchY - 3);
      ctx.stroke();
      
      // Small branch offshoots
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(branchX - 8, branchY + 5);
      ctx.lineTo(branchX - 10, branchY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branchX + 2, branchY);
      ctx.lineTo(branchX + 4, branchY - 4);
      ctx.stroke();
      
      // Cherry blossoms (5 petals each)
      const blossoms = [
        {x: branchX - 10, y: branchY + 1},
        {x: branchX - 2, y: branchY - 1},
        {x: branchX + 6, y: branchY - 3},
        {x: branchX + 12, y: branchY - 2}
      ];
      
      for (const blossom of blossoms) {
        const blossomPulse = Math.sin(time * 0.003 + blossom.x) * 0.2 + 0.8;
        ctx.fillStyle = '#ffb0c8';
        ctx.globalAlpha = blossomPulse * 0.9;
        
        // 5 petals in a circle
        for (let p = 0; p < 5; p++) {
          const angle = (p / 5) * Math.PI * 2 - Math.PI / 2;
          const petalX = blossom.x + Math.cos(angle) * 2.5;
          const petalY = blossom.y + Math.sin(angle) * 2.5;
          
          ctx.beginPath();
          ctx.arc(petalX, petalY, 1.8, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Center
        ctx.fillStyle = '#f0e850';
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(blossom.x, blossom.y, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• MANGA VOLUMES (colorful spines, right-to-left) â•â•â•
      const mangaBooks = [
        {x: 46, w: 7, h: 16, color: '#ff6a8a', volume: '5'},
        {x: 37, w: 6, h: 15, color: '#6a8aff', volume: '4'},
        {x: 29, w: 7, h: 17, color: '#ffa84a', volume: '3'},
        {x: 20, w: 6, h: 14, color: '#8aff6a', volume: '2'},
        {x: 12, w: 7, h: 16, color: '#c86aff', volume: '1'},
        {x: 3, w: 6, h: 15, color: '#ff8a4a', volume: 'EX'},
        {x: -5, w: 7, h: 17, color: '#4ac8ff', volume: 'âˆ'},
        {x: -14, w: 6, h: 14, color: '#ffc84a', volume: 'â˜…'}
      ];
      
      for (const book of mangaBooks) {
        ctx.save();
        ctx.translate(x + book.x, y + shelfH/2 - 28);
        
        // Book spine (bright colors)
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(-book.w/2, 0, book.w, book.h);
        
        // Black spine edge (manga style)
        ctx.fillStyle = '#1a1a1a';
        ctx.globalAlpha = 0.9;
        ctx.fillRect(book.w/2 - 1, 0, 1, book.h);
        
        // White label stripe
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(-book.w/2 + 1, book.h/2 - 2, book.w - 2, 4);
        
        // Volume number
        ctx.fillStyle = '#1a1a1a';
        ctx.globalAlpha = 0.9;
        ctx.font = 'bold 6px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(book.volume, 0, book.h/2 + 2);
        
        // Small manga icon (star)
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.7;
        ctx.font = 'bold 5px sans-serif';
        ctx.fillText('â˜…', 0, 5);
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• FLOATING ELEMENTS â•â•â•
      
      // Halftone sparkles (manga effect)
      if (Math.random() < 0.04 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2 + 10, shelfW/2 - 10),
          y: y + shelfH/2,
          vx: rnd(-8, 8),
          vy: rnd(-25, -15),
          life: 1800,
          maxLife: 1800,
          color: '#ffffff',
          size: rnd(2, 4),
          type: 'sparkle',
          alpha: 0.8,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: rnd(-0.06, 0.06)
        });
      }
      
      // Cherry blossom petals (gently floating)
      if (Math.random() < 0.03 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2, shelfW/2),
          y: y - shelfH/2 - 10,
          vx: rnd(-8, 8),
          vy: 18,
          life: 3000,
          maxLife: 3000,
          color: '#ffb0c8',
          size: 4,
          type: 'petal',
          alpha: 0.8,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: rnd(-0.04, 0.04)
        });
      }
      break;
      
    // â”€â”€â”€ MYSTERY: Detective Noir â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MYSTERY SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Detective Noir Theme - Clues, Evidence, Investigation, Suspense!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'MYSTERY':
      // Dark noir atmosphere background
      const noirGrad = ctx.createLinearGradient(x, y - shelfH/2, x, y + shelfH/2);
      noirGrad.addColorStop(0, '#2a3a4a');
      noirGrad.addColorStop(0.5, '#3a4a5a');
      noirGrad.addColorStop(1, '#1a2a3a');
      ctx.fillStyle = noirGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Subtle rain streaks (noir atmosphere)
      ctx.strokeStyle = '#4a5a6a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 12; i++) {
        const rainX = x - shelfW/2 + i * 9;
        const rainOffset = (time * 0.08 + i * 20) % 80;
        ctx.beginPath();
        ctx.moveTo(rainX, y - shelfH/2 + rainOffset);
        ctx.lineTo(rainX + 2, y - shelfH/2 + rainOffset + 8);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Dark border (case file edge)
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 3;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Yellow crime scene tape (top and bottom)
      ctx.fillStyle = '#f0e840';
      ctx.globalAlpha = 0.4;
      ctx.fillRect(x - shelfW/2, y - shelfH/2 + 10, shelfW, 5);
      ctx.fillRect(x - shelfW/2, y + shelfH/2 - 15, shelfW, 5);
      
      // "CRIME SCENE - DO NOT CROSS" text
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = 0.8;
      ctx.font = 'bold 4px sans-serif';
      ctx.textAlign = 'left';
      for (let i = 0; i < 3; i++) {
        ctx.fillText('CRIME SCENE', x - shelfW/2 + 5 + i * 38, y - shelfH/2 + 13);
        ctx.fillText('DO NOT CROSS', x - shelfW/2 + 5 + i * 38, y + shelfH/2 - 11);
      }
      ctx.globalAlpha = 1;
      
      // Corner evidence markers
      const markers = [
        {x: x - shelfW/2 + 8, y: y - shelfH/2 + 8},
        {x: x + shelfW/2 - 8, y: y - shelfH/2 + 8},
        {x: x - shelfW/2 + 8, y: y + shelfH/2 - 8},
        {x: x + shelfW/2 - 8, y: y + shelfH/2 - 8}
      ];
      
      for (let i = 0; i < markers.length; i++) {
        const marker = markers[i];
        // Yellow evidence marker circle
        ctx.fillStyle = '#f0e840';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(marker.x, marker.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Evidence number
        ctx.fillStyle = '#1a1a1a';
        ctx.globalAlpha = 0.9;
        ctx.font = 'bold 6px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(String(i + 1), marker.x, marker.y + 2);
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP LEFT: DETECTIVE SILHOUETTE (iconic profile) â•â•â•
      const detectiveX = x - shelfW/2 + 22;
      const detectiveY = y - shelfH/2 + 24;
      
      ctx.save();
      ctx.translate(detectiveX, detectiveY);
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = 0.85;
      
      // Detective hat (fedora)
      ctx.beginPath();
      ctx.ellipse(0, -8, 7, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(-5, -8, 10, 3);
      
      // Hat crown
      ctx.beginPath();
      ctx.ellipse(0, -10, 4, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Head silhouette
      ctx.beginPath();
      ctx.arc(0, -2, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Nose profile
      ctx.beginPath();
      ctx.moveTo(4, -2);
      ctx.lineTo(6, -1);
      ctx.lineTo(5, 0);
      ctx.fill();
      
      // Coat collar (trench coat)
      ctx.fillRect(-3, 3, 6, 4);
      ctx.beginPath();
      ctx.moveTo(-3, 3);
      ctx.lineTo(-5, 5);
      ctx.lineTo(-4, 7);
      ctx.lineTo(-3, 7);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(3, 3);
      ctx.lineTo(5, 5);
      ctx.lineTo(4, 7);
      ctx.lineTo(3, 7);
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP CENTER: MAGNIFYING GLASS (detailed) â•â•â•
      const magX = x;
      const magY = y - shelfH/2 + 20;
      const magGlint = Math.sin(time * 0.004) * 0.5 + 0.5;
      
      // Glass lens (outer)
      ctx.strokeStyle = '#8a7a6a';
      ctx.lineWidth = 2.5;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(magX, magY, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      // Glass lens (inner reflection)
      ctx.strokeStyle = '#aaaa9a';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(magX, magY, 6.5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Handle (wooden)
      ctx.strokeStyle = '#6a5a4a';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(magX + 6, magY + 6);
      ctx.lineTo(magX + 11, magY + 11);
      ctx.stroke();
      
      // Handle end cap
      ctx.fillStyle = '#5a4a3a';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(magX + 11, magY + 11, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Lens glare (animated)
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = magGlint * 0.7;
      ctx.beginPath();
      ctx.arc(magX - 2, magY - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Glare sparkle
      if (magGlint > 0.7) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.globalAlpha = (magGlint - 0.7) * 2;
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(magX - 2, magY - 2);
          ctx.lineTo(magX - 2 + Math.cos(angle) * 5, magY - 2 + Math.sin(angle) * 5);
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: SMOKING PIPE (detective accessory) â•â•â•
      const pipeX = x + shelfW/2 - 18;
      const pipeY = y - shelfH/2 + 22;
      
      // Pipe bowl
      ctx.fillStyle = '#6a4a3a';
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.ellipse(pipeX, pipeY, 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Bowl opening
      ctx.fillStyle = '#2a2a2a';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.ellipse(pipeX, pipeY - 2, 2.5, 1.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Pipe stem
      ctx.strokeStyle = '#4a3a2a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.moveTo(pipeX + 4, pipeY + 2);
      ctx.lineTo(pipeX + 12, pipeY + 2);
      ctx.stroke();
      
      // Mouthpiece
      ctx.fillStyle = '#3a2a1a';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(pipeX + 12, pipeY + 1, 3, 2);
      
      // Smoke wisps (animated)
      const smokePhase = time * 0.002;
      for (let i = 0; i < 3; i++) {
        const smokeY = pipeY - 5 - i * 4 + Math.sin(smokePhase + i) * 2;
        const smokeX = pipeX + Math.sin(smokePhase * 1.5 + i * 0.5) * 3;
        
        ctx.strokeStyle = '#d8d8d8';
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = (1 - i * 0.3) * 0.4;
        ctx.beginPath();
        ctx.arc(smokeX, smokeY, 2 + i, 0, Math.PI);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• LEFT SIDE: FINGERPRINT (evidence) â•â•â•
      const printX = x - shelfW/2 + 18;
      const printY = y + 4;
      
      ctx.strokeStyle = '#6a7a8a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.5;
      
      // Fingerprint ridges (concentric ovals)
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.ellipse(printX, printY, 3 + i * 1.2, 4 + i * 1.5, 0.2, 0, Math.PI * 1.6);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: FOOTPRINTS (clue trail) â•â•â•
      const footprints = [
        {x: x - 15, y: y - 5, angle: 0.3},
        {x: x - 8, y: y + 2, angle: -0.2},
        {x: x, y: y - 2, angle: 0.25},
        {x: x + 8, y: y + 3, angle: -0.15}
      ];
      
      for (const foot of footprints) {
        ctx.save();
        ctx.translate(foot.x, foot.y);
        ctx.rotate(foot.angle);
        
        ctx.fillStyle = '#5a6a7a';
        ctx.globalAlpha = 0.35;
        
        // Shoe sole
        ctx.beginPath();
        ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Heel
        ctx.beginPath();
        ctx.ellipse(0, -3, 2, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• RIGHT SIDE: QUESTION MARKS (mystery symbols) â•â•â•
      const qMarks = [
        {x: x + shelfW/2 - 16, y: y + 2, size: 10, phase: 0},
        {x: x + shelfW/2 - 10, y: y + 10, size: 8, phase: 0.5}
      ];
      
      for (const qm of qMarks) {
        const qmPulse = Math.sin(time * 0.005 + qm.phase) * 0.15 + 1;
        
        ctx.save();
        ctx.translate(qm.x, qm.y);
        ctx.scale(qmPulse, qmPulse);
        
        ctx.fillStyle = '#f0e840';
        ctx.globalAlpha = 0.7;
        ctx.font = `bold ${qm.size}px serif`;
        ctx.textAlign = 'center';
        ctx.fillText('?', 0, qm.size * 0.35);
        
        // Shadow for depth
        ctx.fillStyle = '#1a1a1a';
        ctx.globalAlpha = 0.3;
        ctx.fillText('?', 1, qm.size * 0.35 + 1);
        
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM LEFT: BLOODY KNIFE (murder weapon silhouette) â•â•â•
      const knifeX = x - shelfW/2 + 15;
      const knifeY = y + shelfH/2 - 22;
      
      ctx.save();
      ctx.translate(knifeX, knifeY);
      ctx.rotate(-0.3);
      
      // Knife blade
      ctx.fillStyle = '#8a9aaa';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(2, -8);
      ctx.lineTo(2, 4);
      ctx.lineTo(0, 4);
      ctx.closePath();
      ctx.fill();
      
      // Blade tip
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(1, -10);
      ctx.lineTo(2, -8);
      ctx.closePath();
      ctx.fill();
      
      // Handle
      ctx.fillStyle = '#3a3a3a';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(0, 4, 2, 5);
      
      // Blood drip (red)
      ctx.fillStyle = '#8a2a2a';
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(1, -3);
      ctx.lineTo(0.5, 0);
      ctx.lineTo(1.5, 0);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM CENTER: CASE FILES (stacked papers) â•â•â•
      const filesX = x - 5;
      const filesY = y + shelfH/2 - 20;
      
      // Paper stack (3 sheets)
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i === 0 ? '#e8e8d8' : '#d8d8c8';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(filesX + i, filesY + i, 14, 10);
        
        // Paper lines (text simulation)
        ctx.strokeStyle = '#4a4a4a';
        ctx.lineWidth = 0.5;
        ctx.globalAlpha = 0.4;
        for (let j = 0; j < 3; j++) {
          ctx.beginPath();
          ctx.moveTo(filesX + i + 2, filesY + i + 3 + j * 2);
          ctx.lineTo(filesX + i + 12, filesY + i + 3 + j * 2);
          ctx.stroke();
        }
      }
      
      // "TOP SECRET" stamp
      ctx.fillStyle = '#aa2a2a';
      ctx.globalAlpha = 0.5;
      ctx.font = 'bold 4px sans-serif';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.translate(filesX + 7, filesY + 5);
      ctx.rotate(-0.2);
      ctx.fillText('SECRET', 0, 0);
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM RIGHT: POCKET WATCH (time is running out) â•â•â•
      const watchX = x + shelfW/2 - 14;
      const watchY = y + shelfH/2 - 18;
      
      // Watch case
      ctx.strokeStyle = '#c8a84a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(watchX, watchY, 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // Watch face
      ctx.fillStyle = '#f8f8f0';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(watchX, watchY, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Hour markers
      ctx.fillStyle = '#1a1a1a';
      ctx.globalAlpha = 0.6;
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
        const markX = watchX + Math.cos(angle) * 4;
        const markY = watchY + Math.sin(angle) * 4;
        ctx.fillRect(markX - 0.5, markY - 0.5, 1, 1);
      }
      
      // Watch hands (showing ominous time)
      const hourAngle = (time * 0.0005) % (Math.PI * 2);
      const minuteAngle = (time * 0.006) % (Math.PI * 2);
      
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.8;
      // Hour hand
      ctx.beginPath();
      ctx.moveTo(watchX, watchY);
      ctx.lineTo(watchX + Math.cos(hourAngle - Math.PI/2) * 2.5, watchY + Math.sin(hourAngle - Math.PI/2) * 2.5);
      ctx.stroke();
      // Minute hand
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(watchX, watchY);
      ctx.lineTo(watchX + Math.cos(minuteAngle - Math.PI/2) * 4, watchY + Math.sin(minuteAngle - Math.PI/2) * 4);
      ctx.stroke();
      
      // Watch chain
      ctx.strokeStyle = '#a89848';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(watchX + 5, watchY - 4);
      ctx.lineTo(watchX + 8, watchY - 8);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // â•â•â• MYSTERY NOVELS (dark leather-bound) â•â•â•
      const mysteryBooks = [
        {x: -48, w: 7, h: 15, color: '#2a3a4a', title: '?'},
        {x: -38, w: 6, h: 13, color: '#1a2a3a', title: '!'},
        {x: -29, w: 7, h: 16, color: '#3a4a5a', title: 'ğŸ”'},
        {x: -19, w: 6, h: 14, color: '#2a3a4a', title: 'âš '},
        {x: -10, w: 7, h: 15, color: '#1a2a3a', title: '?'},
        {x: 0, w: 6, h: 13, color: '#3a4a5a', title: '!'},
        {x: 9, w: 7, h: 16, color: '#2a3a4a', title: '?'},
        {x: 19, w: 6, h: 14, color: '#1a2a3a', title: 'âš '}
      ];
      
      for (const book of mysteryBooks) {
        // Book spine (dark leather)
        ctx.fillStyle = book.color;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(x + book.x, y + shelfH/2 - 28 - book.h, book.w, book.h);
        
        // Gold spine accent (detective style)
        ctx.fillStyle = '#c8a84a';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(x + book.x, y + shelfH/2 - 28 - book.h, 1, book.h);
        
        // Gold title stripe
        ctx.fillRect(x + book.x + 1, y + shelfH/2 - 16, book.w - 2, 2);
        
        // Mystery symbol
        ctx.fillStyle = '#c8a84a';
        ctx.globalAlpha = 0.7;
        ctx.font = 'bold 7px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(book.title, x + book.x + book.w/2, y + shelfH/2 - 20);
        
        // Worn edges
        ctx.fillStyle = '#1a1a1a';
        ctx.globalAlpha = 0.3;
        ctx.fillRect(x + book.x + book.w - 1, y + shelfH/2 - 28 - book.h, 1, book.h);
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• FLOATING PARTICLES: FOG/MIST â•â•â•
      if (Math.random() < 0.025 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2, shelfW/2),
          y: y + shelfH/2,
          vx: rnd(-5, 5),
          vy: rnd(-15, -10),
          life: 2500,
          maxLife: 2500,
          color: '#6a7a8a',
          size: rnd(4, 8),
          type: 'circle',
          alpha: 0.2
        });
      }
      break;
      
    // â”€â”€â”€ ART: Colorful Creative Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'ART':
      // Painted wooden frame
      ctx.fillStyle = '#e8d8c8';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Rainbow border stripes
      const artColors = ['#ff4444', '#ff8844', '#ffcc44', '#44ff44', '#4444ff', '#aa44ff'];
      ctx.lineWidth = 2;
      for (let i = 0; i < artColors.length; i++) {
        ctx.strokeStyle = artColors[i];
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2 + i * 2, y - shelfH/2);
        ctx.lineTo(x - shelfW/2, y - shelfH/2 + i * 2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(x + shelfW/2 - i * 2, y + shelfH/2);
        ctx.lineTo(x + shelfW/2, y + shelfH/2 - i * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Decorative swirls
      ctx.strokeStyle = '#c8a848';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x - 30, y - 20, 5, 0, Math.PI);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + 30, y + 20, 5, Math.PI, 0);
      ctx.stroke();
      
      // Art books (colorful spines)
      const artBookColors = ['#ff5555', '#55ff55', '#5555ff', '#ffff55', '#ff55ff'];
      for (let i = 0; i < artBookColors.length; i++) {
        ctx.fillStyle = artBookColors[i];
        ctx.globalAlpha = 0.6;
        ctx.fillRect(x - 25 + i * 10, y + 12, 6, 12);
      }
      ctx.globalAlpha = 1;
      
      // Palette icon
      ctx.fillStyle = '#8a6a4a';
      ctx.beginPath();
      ctx.arc(x + 28, y - 16, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(x + 26, y - 18, 2, 2);
      ctx.fillStyle = '#4444ff';
      ctx.fillRect(x + 29, y - 16, 2, 2);
      ctx.fillStyle = '#ffff44';
      ctx.fillRect(x + 26, y - 14, 2, 2);
      break;
      
    // â”€â”€â”€ PHILOSOPHY: Scholarly Mahogany â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'PHILOSOPHY':
      // Rich dark wood
      ctx.fillStyle = '#6a3a2a';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Mahogany grain
      ctx.globalAlpha = 0.2;
      for (let i = 0; i < 8; i++) {
        ctx.strokeStyle = i % 2 === 0 ? '#5a2a1a' : '#7a4a3a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - shelfW/2, y - shelfH/2 + i * 6);
        ctx.lineTo(x + shelfW/2, y - shelfH/2 + i * 6);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Brass fixtures
      ctx.fillStyle = '#c8a848';
      ctx.fillRect(x - shelfW/2 + 4, y - shelfH/2 + 3, 3, 8);
      ctx.fillRect(x + shelfW/2 - 7, y - shelfH/2 + 3, 3, 8);
      
      // Thought bubble icon
      ctx.strokeStyle = '#a89878';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 26, y - 18, 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + 30, y - 14, 2, 0, Math.PI * 2);
      ctx.stroke();
      
      // Question mark
      ctx.fillStyle = '#a89878';
      ctx.font = '12px serif';
      ctx.fillText('?', x - 30, y - 14);
      
      // Leather-bound books
      ctx.fillStyle = '#8a5a3a';
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(x - 20 + i * 10, y + 14, 7, 11);
      }
      ctx.globalAlpha = 1;
      break;
      
    // â”€â”€â”€ BIOGRAPHY: Portrait Gallery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'BIOGRAPHY':
      // Neutral wood with frames
      ctx.fillStyle = '#b89868';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Picture frame molding
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 3;
      ctx.strokeRect(x - shelfW/2 + 2, y - shelfH/2 + 2, shelfW - 4, shelfH - 4);
      
      // Inner border
      ctx.strokeStyle = '#8a6a4a';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - shelfW/2 + 5, y - shelfH/2 + 5, shelfW - 10, shelfH - 10);
      
      // Small portrait silhouettes
      const portraits = [
        {x: -25, y: -15}, {x: 0, y: -15}, {x: 25, y: -15}
      ];
      
      for (const port of portraits) {
        // Frame
        ctx.strokeStyle = '#5a4a3a';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + port.x - 6, y + port.y - 6, 12, 14);
        
        // Portrait (silhouette)
        ctx.fillStyle = '#4a3a2a';
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(x + port.x, y + port.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(x + port.x - 5, y + port.y + 2, 10, 6);
        ctx.globalAlpha = 1;
      }
      
      // Books with names on spines
      ctx.fillStyle = '#7a5a3a';
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(x - 22 + i * 14, y + 14, 10, 12);
      }
      ctx.globalAlpha = 1;
      break;
      
    // â”€â”€â”€ POETRY: Delicate & Romantic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'POETRY':
      // Light painted wood
      ctx.fillStyle = '#f4e8d8';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Floral corner decorations
      ctx.fillStyle = '#e8a8c8';
      ctx.globalAlpha = 0.6;
      
      // Flower petals (corners)
      for (let corner = 0; corner < 4; corner++) {
        const cx = corner < 2 ? x - shelfW/2 + 8 : x + shelfW/2 - 8;
        const cy = corner % 2 === 0 ? y - shelfH/2 + 8 : y + shelfH/2 - 8;
        
        for (let petal = 0; petal < 5; petal++) {
          const angle = (petal / 5) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(cx + Math.cos(angle) * 3, cy + Math.sin(angle) * 3, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
      
      // Decorative border
      ctx.strokeStyle = '#d4b4a4';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.strokeRect(x - shelfW/2 + 4, y - shelfH/2 + 4, shelfW - 8, shelfH - 8);
      ctx.setLineDash([]);
      
      // Heart icon
      ctx.fillStyle = '#e8a8c8';
      ctx.beginPath();
      ctx.moveTo(x + 28, y - 14);
      ctx.arc(x + 25, y - 16, 3, 0, Math.PI, true);
      ctx.arc(x + 31, y - 16, 3, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      
      // Thin poetry books
      ctx.fillStyle = '#c8a8b8';
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(x - 24 + i * 10, y + 16, 4, 10);
      }
      ctx.globalAlpha = 1;
      break;
      
    // â”€â”€â”€ RELIGION: Sacred & Reverent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'RELIGION':
      // Dark sacred wood
      ctx.fillStyle = '#4a3828';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Gold gilded edges
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 3;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      ctx.strokeStyle = '#c49f27';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - shelfW/2 + 3, y - shelfH/2 + 3, shelfW - 6, shelfH - 6);
      
      // Cross symbol
      ctx.fillStyle = '#d4af37';
      ctx.fillRect(x + 25, y - 20, 6, 2);
      ctx.fillRect(x + 27, y - 22, 2, 6);
      
      // Star of David
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 28, y - 18);
      ctx.lineTo(x - 25, y - 12);
      ctx.lineTo(x - 31, y - 12);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x - 28, y - 14);
      ctx.lineTo(x - 31, y - 20);
      ctx.lineTo(x - 25, y - 20);
      ctx.closePath();
      ctx.stroke();
      
      // Ornate shelves
      ctx.fillStyle = '#3a2818';
      ctx.fillRect(x - shelfW/2 + 4, y - shelfH/2 + 14, shelfW - 8, 3);
      ctx.fillRect(x - shelfW/2 + 4, y, shelfW - 8, 3);
      
      // Large sacred texts
      ctx.fillStyle = '#6a4828';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(x - 24, y + 12, 12, 14);
      ctx.fillRect(x - 8, y + 12, 12, 14);
      ctx.fillRect(x + 8, y + 12, 12, 14);
      ctx.globalAlpha = 1;
      
      // Gold crosses on book spines
      ctx.fillStyle = '#d4af37';
      ctx.fillRect(x - 19, y + 18, 2, 5);
      ctx.fillRect(x - 21, y + 19, 6, 2);
      break;
      
    // â”€â”€â”€ FORBIDDEN: Dark & Ominous â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FORBIDDEN SHELF - NINTENDO AAA+ QUALITY ENHANCEMENT
    // Psychedelic Mesmerizing Theme - Trippy, Mind-Bending, Hypnotic!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case 'FORBIDDEN':
      // Shifting rainbow gradient background
      const psychedelicTime = time * 0.001;
      const hue1 = (psychedelicTime * 30) % 360;
      const hue2 = (hue1 + 120) % 360;
      const hue3 = (hue1 + 240) % 360;
      
      const rainbowGrad = ctx.createLinearGradient(x - shelfW/2, y - shelfH/2, x + shelfW/2, y + shelfH/2);
      rainbowGrad.addColorStop(0, `hsl(${hue1}, 80%, 30%)`);
      rainbowGrad.addColorStop(0.5, `hsl(${hue2}, 80%, 25%)`);
      rainbowGrad.addColorStop(1, `hsl(${hue3}, 80%, 30%)`);
      ctx.fillStyle = rainbowGrad;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Pulsing energy waves overlay
      const wavePulse = Math.sin(time * 0.004) * 0.2 + 0.3;
      ctx.fillStyle = `hsl(${(hue1 + 180) % 360}, 100%, 50%)`;
      ctx.globalAlpha = wavePulse * 0.3;
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      ctx.globalAlpha = 1;
      
      // Kaleidoscope border pattern
      ctx.strokeStyle = `hsl(${hue1}, 100%, 60%)`;
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.8;
      ctx.strokeRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      
      // Inner rainbow border
      ctx.strokeStyle = `hsl(${hue2}, 100%, 60%)`;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.strokeRect(x - shelfW/2 + 3, y - shelfH/2 + 3, shelfW - 6, shelfH - 6);
      ctx.globalAlpha = 1;
      
      // â•â•â• CENTER: LARGE MORPHING GEOMETRIC SHAPES â•â•â•
      const morphX = x;
      const morphY = y;
      const morphProgress = (time * 0.002) % 1;
      const sides = 3 + Math.floor(morphProgress * 5); // 3 to 7 sides
      
      ctx.save();
      ctx.translate(morphX, morphY);
      ctx.rotate(time * 0.001);
      
      // Outer shape (LARGE - 30px radius)
      ctx.strokeStyle = `hsl(${hue2}, 100%, 60%)`;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
        const px = Math.cos(angle) * 30;
        const py = Math.sin(angle) * 30;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Middle shape
      ctx.strokeStyle = `hsl(${hue3}, 100%, 60%)`;
      ctx.lineWidth = 2.5;
      ctx.rotate(Math.PI / sides);
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
        const px = Math.cos(angle) * 20;
        const py = Math.sin(angle) * 20;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Inner shape (inverted rotation)
      ctx.strokeStyle = `hsl(${hue1}, 100%, 70%)`;
      ctx.lineWidth = 2;
      ctx.rotate(Math.PI / sides);
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
        const px = Math.cos(angle) * 12;
        const py = Math.sin(angle) * 12;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Central pulsing core
      const corePulse = Math.sin(time * 0.008) * 0.4 + 0.6;
      const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8 * corePulse);
      coreGrad.addColorStop(0, `hsl(${hue1}, 100%, 80%)`);
      coreGrad.addColorStop(0.5, `hsl(${hue2}, 100%, 60%)`);
      coreGrad.addColorStop(1, `hsl(${hue3}, 100%, 40%)`);
      ctx.fillStyle = coreGrad;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(0, 0, 8 * corePulse, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• CORNER VORTEXES (swirling patterns) â•â•â•
      const vortexes = [
        {x: x - shelfW/2 + 10, y: y - shelfH/2 + 10},
        {x: x + shelfW/2 - 10, y: y - shelfH/2 + 10},
        {x: x - shelfW/2 + 10, y: y + shelfH/2 - 10},
        {x: x + shelfW/2 - 10, y: y + shelfH/2 - 10}
      ];
      
      for (let v = 0; v < vortexes.length; v++) {
        const vortex = vortexes[v];
        ctx.save();
        ctx.translate(vortex.x, vortex.y);
        ctx.rotate(time * 0.004 * (v % 2 === 0 ? 1 : -1));
        
        for (let i = 0; i < 4; i++) {
          const vortexRadius = 3 + i * 2;
          const vortexHue = (hue1 + v * 90 + i * 30) % 360;
          
          ctx.strokeStyle = `hsl(${vortexHue}, 100%, 60%)`;
          ctx.lineWidth = 1.5;
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.arc(0, 0, vortexRadius, i * Math.PI / 4, i * Math.PI / 4 + Math.PI);
          ctx.stroke();
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      // â•â•â• PARTICLES: RAINBOW SPARKLES & FLOATING GLYPHS â•â•â•
      if (Math.random() < 0.08 * particleChanceMultiplier) {
        particles.push({
          x: x + rnd(-shelfW/2, shelfW/2),
          y: y + shelfH/2,
          vx: rnd(-12, 12),
          vy: rnd(-35, -20),
          life: 2500,
          maxLife: 2500,
          color: `hsl(${Math.random() * 360}, 100%, 70%)`,
          size: rnd(2, 5),
          type: 'sparkle',
          alpha: 0.9,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: rnd(-0.05, 0.05)
        });
      }
      
      // Floating symbols
      if (Math.random() < 0.04 * particleChanceMultiplier) {
        const glyphSymbols = ['â—ˆ', 'â—‰', 'â—Š', 'â¬¡', 'â¬¢', 'â—¯', 'â­˜', 'âŠ™'];
        particles.push({
          x: x + rnd(-shelfW/2 + 10, shelfW/2 - 10),
          y: y + shelfH/2,
          vx: rnd(-8, 8),
          vy: -25,
          life: 3000,
          maxLife: 3000,
          color: `hsl(${Math.random() * 360}, 100%, 70%)`,
          size: 10,
          type: 'code',
          alpha: 0.8,
          char: glyphSymbols[rint(0, glyphSymbols.length - 1)]
        });
      }
      break;

      
      // â•â•â• TOP CENTER: HYPNOTIC SPIRAL (rotating, mesmerizing) â•â•â•
      const spiralX = x;
      const spiralY = y - shelfH/2 + 20;
      const spiralRotate = time * 0.003;
      
      ctx.save();
      ctx.translate(spiralX, spiralY);
      ctx.rotate(spiralRotate);
      
      // Multi-layered spiral (8 arms)
      for (let arm = 0; arm < 8; arm++) {
        const armAngle = (arm / 8) * Math.PI * 2;
        ctx.strokeStyle = `hsl(${(hue1 + arm * 45) % 360}, 100%, 60%)`;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;
        
        ctx.beginPath();
        for (let i = 0; i < 30; i++) {
          const t = i / 30;
          const r = t * 15;
          const angle = armAngle + t * Math.PI * 4;
          const px = Math.cos(angle) * r;
          const py = Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      
      // Central pulsing eye
      const eyePulse = Math.sin(time * 0.008) * 0.4 + 0.6;
      const centerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 5 * eyePulse);
      centerGrad.addColorStop(0, `hsl(${hue1}, 100%, 80%)`);
      centerGrad.addColorStop(0.5, `hsl(${hue2}, 100%, 60%)`);
      centerGrad.addColorStop(1, `hsl(${hue3}, 100%, 40%)`);
      ctx.fillStyle = centerGrad;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(0, 0, 5 * eyePulse, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP LEFT: KALEIDOSCOPE MANDALA â•â•â•
      const mandalaX = x - shelfW/2 + 20;
      const mandalaY = y - shelfH/2 + 20;
      const mandalaRotate = time * 0.002;
      
      ctx.save();
      ctx.translate(mandalaX, mandalaY);
      ctx.rotate(mandalaRotate);
      
      // 6-fold symmetry pattern
      for (let i = 0; i < 6; i++) {
        ctx.save();
        ctx.rotate((i / 6) * Math.PI * 2);
        
        // Petal shape
        ctx.fillStyle = `hsl(${(hue1 + i * 60) % 360}, 90%, 55%)`;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(0, -8, 4, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner detail
        ctx.fillStyle = `hsl(${(hue1 + i * 60 + 30) % 360}, 90%, 70%)`;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.ellipse(0, -8, 2, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Center ring
      ctx.strokeStyle = `hsl(${hue1}, 100%, 70%)`;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(0, 0, 4, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• TOP RIGHT: FRACTAL TREE (branching pattern) â•â•â•
      const fractalX = x + shelfW/2 - 20;
      const fractalY = y - shelfH/2 + 30;
      const fractalWave = Math.sin(time * 0.003);
      
      function drawFractalBranch(x, y, length, angle, depth, baseHue) {
        if (depth === 0 || length < 1) return;
        
        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;
        
        ctx.strokeStyle = `hsl(${(baseHue + depth * 40) % 360}, 90%, ${70 - depth * 10}%)`;
        ctx.lineWidth = depth * 0.8;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Branch recursively
        const angleOffset = 0.5 + fractalWave * 0.2;
        drawFractalBranch(endX, endY, length * 0.67, angle - angleOffset, depth - 1, baseHue);
        drawFractalBranch(endX, endY, length * 0.67, angle + angleOffset, depth - 1, baseHue);
      }
      
      ctx.save();
      drawFractalBranch(fractalX, fractalY, 10, -Math.PI/2, 4, hue1);
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // â•â•â• LEFT SIDE: WAVE INTERFERENCE PATTERN â•â•â•
      const waveX = x - shelfW/2 + 15;
      const waveY = y;
      
      for (let i = 0; i < 5; i++) {
        const waveOffset = time * 0.002 + i * 0.5;
        const waveRadius = 4 + Math.sin(waveOffset) * 2;
        
        ctx.strokeStyle = `hsl(${(hue1 + i * 72) % 360}, 100%, 60%)`;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(waveX, waveY, waveRadius + i * 3, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• RIGHT SIDE: PLASMA BALL EFFECT â•â•â•
      const plasmaX = x + shelfW/2 - 15;
      const plasmaY = y;
      
      // Outer glow
      const plasmaGrad = ctx.createRadialGradient(plasmaX, plasmaY, 0, plasmaX, plasmaY, 12);
      plasmaGrad.addColorStop(0, `hsl(${hue1}, 100%, 70%)`);
      plasmaGrad.addColorStop(0.5, `hsl(${hue2}, 100%, 50%)`);
      plasmaGrad.addColorStop(1, `hsla(${hue3}, 100%, 30%, 0)`);
      ctx.fillStyle = plasmaGrad;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(plasmaX, plasmaY, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Lightning bolts
      for (let i = 0; i < 6; i++) {
        const boltAngle = (i / 6) * Math.PI * 2 + time * 0.005;
        const boltLength = 8 + Math.sin(time * 0.01 + i) * 3;
        
        ctx.strokeStyle = `hsl(${(hue1 + i * 60) % 360}, 100%, 80%)`;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(plasmaX, plasmaY);
        
        // Jagged lightning path
        for (let j = 0; j < 3; j++) {
          const t = (j + 1) / 3;
          const jag = (Math.sin(time * 0.02 + i + j) * 2);
          const px = plasmaX + Math.cos(boltAngle) * boltLength * t + jag;
          const py = plasmaY + Math.sin(boltAngle) * boltLength * t + jag;
          ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // â•â•â• BOTTOM: TRIPPY BOOKS (shifting colors, wavy) â•â•â•
      const trippyBooks = [
        {x: -48, w: 9, h: 16},
        {x: -36, w: 8, h: 18},
        {x: -25, w: 9, h: 15},
        {x: -13, w: 8, h: 17},
        {x: -2, w: 9, h: 16},
        {x: 10, w: 8, h: 19},
        {x: 21, w: 9, h: 14},
        {x: 33, w: 8, h: 17}
      ];
      
      for (let i = 0; i < trippyBooks.length; i++) {
        const book = trippyBooks[i];
        const bookHue = (hue1 + i * 45 + time * 10) % 360;
        const bookWave = Math.sin(time * 0.005 + i) * 2;
        
        ctx.save();
        ctx.translate(x + book.x, y + shelfH/2 - 26 - book.h/2 + bookWave);
        ctx.rotate(Math.sin(time * 0.003 + i) * 0.1);
        
        // Book gradient (shifting)
        const bookGrad = ctx.createLinearGradient(-book.w/2, -book.h/2, book.w/2, book.h/2);
        bookGrad.addColorStop(0, `hsl(${bookHue}, 90%, 50%)`);
        bookGrad.addColorStop(0.5, `hsl(${(bookHue + 60) % 360}, 90%, 60%)`);
        bookGrad.addColorStop(1, `hsl(${bookHue}, 90%, 50%)`);
        ctx.fillStyle = bookGrad;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(-book.w/2, -book.h/2, book.w, book.h);
        
        // Glowing edge
        ctx.strokeStyle = `hsl(${(bookHue + 180) % 360}, 100%, 70%)`;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.8;
        ctx.strokeRect(-book.w/2, -book.h/2, book.w, book.h);
        
        // Pulsing symbol
        const symbolPulse = Math.sin(time * 0.006 + i) * 0.3 + 0.7;
        ctx.fillStyle = `hsl(${(bookHue + 120) % 360}, 100%, 90%)`;
        ctx.globalAlpha = symbolPulse;
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        const symbols = ['â—ˆ', 'â—‰', 'â—Š', 'â¬¡', 'â¬¢', 'â—¯', 'â­˜', 'âŠ™'];
        ctx.fillText(symbols[i], 0, 3);
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      break;

    case 'TRASH':
      // This case shouldn't be hit as trash uses renderTrashCan
      // But we'll add a fallback
      ctx.fillStyle = '#5a5a6a';
      ctx.fillRect(x - shelfW/2, y - shelfH/2, shelfW, shelfH);
      break;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LABEL SIGN (applies to all)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const labelY = y - shelfH/2 - 14;
  
  // Sign chain
  ctx.strokeStyle = '#8a8a9a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x, y - shelfH/2);
  ctx.lineTo(x, labelY);
  ctx.stroke();
  
  // Sign background (themed by type)
  const signW = 60;
  const signH = 16;
  
  // Sign color based on shelf type
  let signBg = '#f0ebd6';
  let signBorder = '#c8a84a';
  
  if (shelf.type === 'FORBIDDEN') {
    signBg = '#2a1a2a';
    signBorder = '#aa44aa';
  } else if (shelf.type === 'SCIENCE') {
    signBg = '#d8e8f8';
    signBorder = '#7a8a9a';
  } else if (shelf.type === 'ART') {
    signBg = '#fff8e8';
    signBorder = '#ff8844';
  }
  
  ctx.fillStyle = signBg;
  ctx.fillRect(x - signW/2, labelY, signW, signH);
  
  // Sign border
  ctx.strokeStyle = signBorder;
  ctx.lineWidth = 2;
  ctx.strokeRect(x - signW/2, labelY, signW, signH);
  
  // Label text
  const textColor = shelf.type === 'FORBIDDEN' ? '#aa44aa' : BOOK_COLORS[shelf.type];
  ctx.fillStyle = textColor;
  ctx.font = 'bold 7px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText(BOOK_LABELS[shelf.type].toUpperCase(), x, labelY + 11);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO: BONUS READY INDICATORS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  if (shelf.bonusState) {
    const bonus = shelf.bonusState;
    const indicatorY = y - shelfH/2 - 45;
    
    switch(shelf.type) {
      case 'FICTION':
        // Page Turner - Show progress (4/5 means next is bonus!)
        if (bonus.pageTurnerReady) {
          const flutter = Math.sin(time * 0.02) * 2;
          ctx.save();
          ctx.translate(x, indicatorY);
          ctx.rotate(flutter * 0.1);
          
          // Fluttering page
          ctx.fillStyle = '#f0ebd6';
          ctx.globalAlpha = 0.8;
          ctx.fillRect(-6, -8, 12, 16);
          
          // Page lines
          ctx.strokeStyle = '#1a1a1a';
          ctx.lineWidth = 0.5;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(-4, -4 + i * 4);
            ctx.lineTo(4, -4 + i * 4);
            ctx.stroke();
          }
          
          ctx.restore();
          ctx.globalAlpha = 1;
          
          // "READY!" text
          ctx.fillStyle = '#ff6aaa';
          ctx.font = 'bold 6px "Press Start 2P"';
          ctx.fillText('READY!', x, indicatorY + 18);
        }
        break;
        
      case 'HORROR':
        // Jump Scare - Show skull on next jump scare slot
        if (bonus.nextJumpScare !== null) {
          const targetSlot = bonus.nextJumpScare % shelf.capacity;
          if (targetSlot < shelf.filedCount + 3) { // Show when getting close
            const pulse = Math.sin(time * 0.01) * 0.3 + 0.7;
            ctx.globalAlpha = pulse * 0.6;
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 10px sans-serif';
            ctx.fillText('ğŸ’€', x, indicatorY);
            ctx.globalAlpha = 1;
          }
        }
        break;
        
      case 'SCIENCE':
        // Experiment - Show current chain
        if (bonus.scienceChain > 0) {
          const bubblePulse = Math.sin(time * 0.015) * 2;
          
          // Beaker with bubbles
          ctx.strokeStyle = '#4a8ac2';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - 6, indicatorY + 8);
          ctx.lineTo(x - 6, indicatorY);
          ctx.lineTo(x + 6, indicatorY);
          ctx.lineTo(x + 6, indicatorY + 8);
          ctx.stroke();
          
          // Bubbles
          for (let i = 0; i < bonus.scienceChain; i++) {
            ctx.fillStyle = '#4ac8ff';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(x + rnd(-4, 4), indicatorY + 4 + bubblePulse - i * 3, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
          
          // Chain count
          ctx.fillStyle = '#4ac28a';
          ctx.font = 'bold 6px "Press Start 2P"';
          ctx.fillText(`x${bonus.scienceChain}`, x, indicatorY + 18);
        }
        break;
        
      case 'MYSTERY':
        // Clue Collector - Show fingerprint and multiplier
        if (bonus.cluesFound > 0) {
          const glowPulse = Math.sin(time * 0.008) * 0.2 + 0.8;
          
          // Magnifying glass
          ctx.strokeStyle = '#c8a84a';
          ctx.lineWidth = 2;
          ctx.globalAlpha = glowPulse;
          ctx.beginPath();
          ctx.arc(x - 2, indicatorY, 5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 2, indicatorY + 3);
          ctx.lineTo(x + 6, indicatorY + 7);
          ctx.stroke();
          ctx.globalAlpha = 1;
          
          // Multiplier
          ctx.fillStyle = '#f0e840';
          ctx.font = 'bold 6px "Press Start 2P"';
          ctx.fillText(`x${bonus.mysteryMultiplier.toFixed(1)}`, x, indicatorY + 18);
        }
        break;
        
      case 'TABLETS':
        // Ancient Wisdom - Show accumulated knowledge
        if (bonus.wisdomCount > 0) {
          const wisdomGlow = Math.sin(time * 0.006) * 0.3 + 0.7;
          
          // Ancient scroll
          ctx.fillStyle = '#d4b896';
          ctx.globalAlpha = wisdomGlow * 0.8;
          ctx.fillRect(x - 6, indicatorY - 4, 12, 10);
          
          // Scroll details
          ctx.strokeStyle = '#8a7a5a';
          ctx.lineWidth = 1;
          ctx.strokeRect(x - 6, indicatorY - 4, 12, 10);
          
          // Hieroglyphs on scroll
          ctx.fillStyle = '#6a5a4a';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(x - 4, indicatorY - 2 + i * 3, 8, 1);
          }
          ctx.globalAlpha = 1;
          
          // Wisdom multiplier (golden)
          const wisdomMult = 1 + (bonus.wisdomCount * 0.01);
          ctx.fillStyle = '#c8a84a';
          ctx.font = 'bold 6px "Press Start 2P"';
          ctx.fillText(`x${wisdomMult.toFixed(2)}`, x, indicatorY + 18);
          
          // Enlightenment sparkle
          if (wisdomGlow > 0.9) {
            ctx.fillStyle = '#f0e840';
            ctx.globalAlpha = (wisdomGlow - 0.9) * 10;
            ctx.fillText('âœ¦', x, indicatorY - 8);
            ctx.globalAlpha = 1;
          }
        }
        break;
        
      case 'MANGA':
        // Combo Attack - Show speed lines
        if (bonus.mangaExtension > 0) {
          const lineIntensity = Math.min(bonus.mangaExtension / 3000, 1);
          ctx.strokeStyle = '#4a4a4a';
          ctx.lineWidth = 1;
          ctx.globalAlpha = lineIntensity * 0.6;
          
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(x, indicatorY);
            ctx.lineTo(x + Math.cos(angle) * 12, indicatorY + Math.sin(angle) * 12);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
          
          // Extension amount
          ctx.fillStyle = '#ff6a8a';
          ctx.font = 'bold 6px "Press Start 2P"';
          ctx.fillText(`+${Math.floor(bonus.mangaExtension / 1000)}s`, x, indicatorY + 18);
        }
        break;
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DYNAMIC BOOK SLOTS (Nintendo Magic!)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const slotsPerRow = 5;
  const totalRows = 4;
  const slotWidth = 6;
  const slotHeight = 10;
  const slotSpacing = 2;
  const rowSpacing = 3;
  const slotsStartY = y - shelfH/2 + 8;
  const slotsStartX = x - (slotsPerRow * (slotWidth + slotSpacing)) / 2;
  
  // Render all 20 slots
  for (let row = 0; row < totalRows; row++) {
    for (let col = 0; col < slotsPerRow; col++) {
      const slotIndex = row * slotsPerRow + col;
      const slotX = slotsStartX + col * (slotWidth + slotSpacing);
      const slotY = slotsStartY + row * (slotHeight + rowSpacing);
      
      // Find book in this slot
      const book = shelf.storedBooks?.find(b => b.slotIndex === slotIndex);
      
      if (book) {
        // FILED BOOK - Render with Nintendo polish
        const age = Date.now() - book.spawnTime;
        const popProgress = Math.max(0, 1 - age / 200); // 200ms pop-in
        
        // Pop-in animation (scale from 0 to 1)
        const scale = 1 - popProgress * 0.5;
        const offsetY = popProgress * -5; // Bounce in from above
        
        ctx.save();
        ctx.translate(slotX + slotWidth/2, slotY + slotHeight/2 + offsetY);
        ctx.scale(scale, scale);
        
        // Book with slight 3D effect
        ctx.fillStyle = book.color;
        ctx.fillRect(-slotWidth/2, -slotHeight/2, slotWidth, slotHeight);
        
        // Spine (black line)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(-slotWidth/2, -slotHeight/2, 1, slotHeight);
        
        // Page edge (white highlight)
        ctx.fillStyle = '#f0f0e8';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(slotWidth/2 - 2, -slotHeight/2, 1, slotHeight);
        ctx.globalAlpha = 1;
        
        // Shine effect on newly filed books
        if (age < 500) {
          const shineAlpha = 1 - (age / 500);
          ctx.fillStyle = '#ffffff';
          ctx.globalAlpha = shineAlpha * 0.4;
          ctx.fillRect(-slotWidth/2, -slotHeight/2, slotWidth, slotHeight);
          ctx.globalAlpha = 1;
        }
        
        ctx.restore();
      } else {
        // EMPTY SLOT - Show subtle outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.strokeRect(slotX, slotY, slotWidth, slotHeight);
        ctx.setLineDash([]);
      }
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CAPACITY COUNTER (Nintendo-style UI)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const counterY = y + shelfH/2 + 8;
  const fillPercentage = shelf.filedCount / shelf.capacity;
  
  // Progress bar background
  const barWidth = 60;
  const barHeight = 6;
  const barX = x - barWidth/2;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(barX, counterY, barWidth, barHeight);
  
  // Progress bar fill (color-coded)
  let barColor = '#4a8cff'; // Blue
  if (fillPercentage >= 1.0) barColor = '#f0e840'; // Gold when complete
  else if (fillPercentage >= 0.75) barColor = '#2aaa5c'; // Green when close
  
  const fillWidth = barWidth * fillPercentage;
  
  // Animated fill with shimmer
  const shimmer = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
  ctx.fillStyle = barColor;
  ctx.globalAlpha = shimmer;
  ctx.fillRect(barX, counterY, fillWidth, barHeight);
  ctx.globalAlpha = 1;
  
  // Bar border
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, counterY, barWidth, barHeight);
  
  // Counter text
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 3;
  ctx.font = 'bold 7px "Press Start 2P"';
  ctx.textAlign = 'center';
  const counterText = `${shelf.filedCount}/${shelf.capacity}`;
  ctx.strokeText(counterText, x, counterY + 16);
  ctx.fillText(counterText, x, counterY + 16);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COMPLETION EFFECTS (Nintendo celebration!)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  if (shelf.isComplete) {
    // Golden aura pulse
    const auraPulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
    ctx.globalAlpha = auraPulse * 0.3;
    ctx.fillStyle = '#f0e840';
    ctx.beginPath();
    ctx.arc(x, y, 50 + auraPulse * 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Completion star
    const starSize = 10 + Math.sin(Date.now() * 0.008) * 2;
    ctx.fillStyle = '#f0e840';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    
    // Draw star above shelf
    const starY = y - shelfH/2 - 28;
    ctx.save();
    ctx.translate(x, starY);
    ctx.rotate(Date.now() * 0.001); // Slow rotation
    
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
      const outerRadius = starSize;
      const innerRadius = starSize * 0.4;
      
      // Outer point
      ctx.lineTo(
        Math.cos(angle) * outerRadius,
        Math.sin(angle) * outerRadius
      );
      
      // Inner point
      const innerAngle = angle + Math.PI / 5;
      ctx.lineTo(
        Math.cos(innerAngle) * innerRadius,
        Math.sin(innerAngle) * innerRadius
      );
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    
    // Sparkles around completed shelf
    if (Math.random() < 0.3) {
      const sparkleAngle = Math.random() * Math.PI * 2;
      const sparkleDist = 40 + Math.random() * 15;
      PARTICLE_TYPES.SPARKLE(
        x + Math.cos(sparkleAngle) * sparkleDist,
        y + Math.sin(sparkleAngle) * sparkleDist,
        '#f0e840',
        500
      );
    }
    
    // Celebration animation (first 2 seconds after completion)
    if (shelf.completionCelebration > 0) {
      const celebProgress = 1 - (shelf.completionCelebration / 2000);
      
      // Expanding golden ring
      ctx.strokeStyle = '#f0e840';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 1 - celebProgress;
      ctx.beginPath();
      ctx.arc(x, y, 30 + celebProgress * 50, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // "COMPLETE!" text that rises and fades
      if (shelf.completionCelebration > 1500) {
        const textAlpha = (shelf.completionCelebration - 1500) / 500;
        const textY = y - 60 - (1 - textAlpha) * 20;
        
        ctx.globalAlpha = textAlpha;
        ctx.fillStyle = '#f0e840';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.font = 'bold 8px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.strokeText('COMPLETE!', x, textY);
        ctx.fillText('COMPLETE!', x, textY);
        ctx.globalAlpha = 1;
      }
    }
  }
  
  // Restore transformations (lean, scale, etc.)
  ctx.restore();
}

function renderTrashCan(can) {
  const x = can.x, y = can.y;
  
  // Glow if carrying trash
  let shouldGlow = false;
  for (const book of player.carrying) {
    if (book && book.type === 'TRASH') {
      shouldGlow = true;
      break;
    }
  }
  
  if (shouldGlow) {
    const pulse = Math.sin(can.glowPulse) * 0.3 + 0.7;
    ctx.globalAlpha = 0.5 * pulse;
    ctx.fillStyle = SHELF_GLOW.TRASH;
    ctx.fillRect(x - 50, y - 50, 100, 100);
    ctx.globalAlpha = 1;
  }
  
  // Acceptance pulse
  if (can.acceptPulse > 0) {
    ctx.globalAlpha = can.acceptPulse * 0.6;
    ctx.fillStyle = SHELF_GLOW.TRASH;
    const r = 50 + (1 - can.acceptPulse) * 40;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    
    // Secondary ring
    ctx.globalAlpha = can.acceptPulse * 0.3;
    ctx.beginPath();
    ctx.arc(x, y, r + 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  // Shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(x - 30, y + 38, 60, 8);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRASH CAN - SCALED TO SHELF HEIGHT (72px)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Trash can body - 3D cylinder (scaled 2.25x to match shelf height)
  const canW = 63;  // Scaled from 28
  const canH = 72;  // Matches shelf height!
  const topW = 72;  // Scaled from 32
  
  // Front face
  ctx.fillStyle = '#5a5a6a';
  ctx.fillRect(x - canW/2, y - canH/2 + 9, canW, canH);
  
  // Side panels (3D effect - left)
  ctx.fillStyle = '#4a4a5a';
  ctx.beginPath();
  ctx.moveTo(x - canW/2, y - canH/2 + 9);
  ctx.lineTo(x - canW/2 - 9, y - canH/2);
  ctx.lineTo(x - canW/2 - 9, y + canH/2);
  ctx.lineTo(x - canW/2, y + canH/2 + 9);
  ctx.closePath();
  ctx.fill();
  
  // Side panel (right)
  ctx.fillStyle = '#6a6a7a';
  ctx.beginPath();
  ctx.moveTo(x + canW/2, y - canH/2 + 9);
  ctx.lineTo(x + canW/2 + 9, y - canH/2);
  ctx.lineTo(x + canW/2 + 9, y + canH/2);
  ctx.lineTo(x + canW/2, y + canH/2 + 9);
  ctx.closePath();
  ctx.fill();
  
  // Metal bands (scaled)
  ctx.fillStyle = '#7a7a8a';
  ctx.fillRect(x - topW/2, y - canH/2, topW, 9);
  ctx.fillRect(x - canW/2 - 4, y, canW + 8, 7);
  
  // Lid (slightly open animation)
  const lidOpen = shouldGlow ? Math.sin(Date.now() * 0.01) * 4 : 0;
  
  // Lid back (scaled)
  ctx.fillStyle = '#6a6a7a';
  ctx.fillRect(x - topW/2, y - canH/2 - 13 + lidOpen, topW, 13);
  
  // Lid top (scaled)
  ctx.fillStyle = '#7a7a8a';
  ctx.beginPath();
  ctx.moveTo(x - topW/2, y - canH/2 - 13 + lidOpen);
  ctx.lineTo(x - topW/2 - 7, y - canH/2 - 18 + lidOpen);
  ctx.lineTo(x + topW/2 - 7, y - canH/2 - 18 + lidOpen);
  ctx.lineTo(x + topW/2, y - canH/2 - 13 + lidOpen);
  ctx.closePath();
  ctx.fill();
  
  // Lid handle (scaled)
  ctx.strokeStyle = '#8a8a9a';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(x, y - canH/2 - 22 + lidOpen, 13, Math.PI, 0, false);
  ctx.stroke();
  
  // Trash icon on can (scaled)
  ctx.fillStyle = '#f0e840'; // Changed to yellow (banana theme)
  ctx.font = '24px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('ğŸ—‘', x, y + 5);
  
  // Label
  ctx.fillStyle = '#e87a2e';
  ctx.font = 'bold 7px "Press Start 2P"';
  ctx.fillText('TRASH', x, y - canH/2 - 16);
}

function renderBook(book) {
  if (!book || !book.type) return; // Safety check
  
  ctx.save();
  ctx.translate(book.x, book.y + Math.sin(book.bobPhase) * 3);
  ctx.rotate(book.rot);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRASH = BANANA PEEL (not a book!)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (book.type === 'TRASH') {
    // Scale banana peel to match book size (32Ã—44 equivalent)
    const scale = 1.6; // Scale up to match bigger books
    
    ctx.save();
    ctx.scale(scale, scale);
    
    // â•â•â• POLISHED BANANA PEEL (Realistic Orientation) â•â•â•
    // Stem at TOP, opened peel segments fanning OUT at BOTTOM
    
    // â•â•â• STEM (top - closed end) â•â•â•
    ctx.fillStyle = '#8a6a2a'; // Brown stem
    ctx.fillRect(-1, -18, 2, 4);
    
    // Stem tip
    ctx.fillStyle = '#6a4a1a';
    ctx.beginPath();
    ctx.moveTo(-1, -18);
    ctx.lineTo(0, -20);
    ctx.lineTo(1, -18);
    ctx.fill();
    
    // â•â•â• MAIN BANANA BODY (center - vertical) â•â•â•
    ctx.fillStyle = '#ffe135'; // Bright yellow
    ctx.beginPath();
    ctx.ellipse(0, -5, 5, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Body glow (soft edge)
    ctx.fillStyle = 'rgba(255, 225, 53, 0.4)';
    ctx.beginPath();
    ctx.ellipse(0, -5, 6, 13, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // â•â•â• FOUR PEEL SEGMENTS (Fanning OUT at bottom) â•â•â•
    
    // LEFT PEEL (bottom left - fanning outward)
    ctx.fillStyle = '#f0d840';
    ctx.beginPath();
    ctx.moveTo(-3, 0); // Start at center bottom
    ctx.bezierCurveTo(-5, 2, -9, 5, -11, 8);      // Curve outward
    ctx.bezierCurveTo(-12, 10, -11, 12, -9, 13);   // Curl at tip
    ctx.bezierCurveTo(-7, 14, -5, 12, -4, 9);      // Curve back
    ctx.bezierCurveTo(-3, 6, -3, 3, -3, 0);        // Connect to center
    ctx.closePath();
    ctx.fill();
    
    // LEFT PEEL inner curve (concave depth)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.beginPath();
    ctx.moveTo(-3, 2);
    ctx.quadraticCurveTo(-7, 6, -8, 10);
    ctx.quadraticCurveTo(-5, 10, -3, 6);
    ctx.closePath();
    ctx.fill();
    
    // RIGHT PEEL (bottom right - fanning outward)
    ctx.fillStyle = '#f0d840';
    ctx.beginPath();
    ctx.moveTo(3, 0); // Start at center bottom
    ctx.bezierCurveTo(5, 2, 9, 5, 11, 8);       // Curve outward
    ctx.bezierCurveTo(12, 10, 11, 12, 9, 13);    // Curl at tip
    ctx.bezierCurveTo(7, 14, 5, 12, 4, 9);       // Curve back
    ctx.bezierCurveTo(3, 6, 3, 3, 3, 0);         // Connect to center
    ctx.closePath();
    ctx.fill();
    
    // RIGHT PEEL inner curve (concave depth)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.beginPath();
    ctx.moveTo(3, 2);
    ctx.quadraticCurveTo(7, 6, 8, 10);
    ctx.quadraticCurveTo(5, 10, 3, 6);
    ctx.closePath();
    ctx.fill();
    
    // BACK LEFT PEEL (bottom back left - fanning outward)
    ctx.fillStyle = '#e8c830';
    ctx.beginPath();
    ctx.moveTo(-1, 1); // Start near center
    ctx.bezierCurveTo(-3, 4, -6, 8, -7, 12);     // Curve out-back
    ctx.bezierCurveTo(-7, 14, -6, 15, -4, 14);   // Curl
    ctx.bezierCurveTo(-2, 13, -1, 10, -1, 7);    // Back to center
    ctx.bezierCurveTo(-1, 5, -1, 3, -1, 1);
    ctx.closePath();
    ctx.fill();
    
    // BACK RIGHT PEEL (bottom back right - fanning outward)
    ctx.fillStyle = '#e8c830';
    ctx.beginPath();
    ctx.moveTo(1, 1); // Start near center
    ctx.bezierCurveTo(3, 4, 6, 8, 7, 12);      // Curve out-back
    ctx.bezierCurveTo(7, 14, 6, 15, 4, 14);    // Curl
    ctx.bezierCurveTo(2, 13, 1, 10, 1, 7);     // Back to center
    ctx.bezierCurveTo(1, 5, 1, 3, 1, 1);
    ctx.closePath();
    ctx.fill();
    
    // â•â•â• PEEL HIGHLIGHTS (shine on peels) â•â•â•
    ctx.fillStyle = 'rgba(255, 255, 200, 0.5)';
    
    // Left peel shine
    ctx.beginPath();
    ctx.ellipse(-7, 7, 2, 3, -0.4, 0, Math.PI * 2);
    ctx.fill();
    
    // Right peel shine
    ctx.beginPath();
    ctx.ellipse(7, 7, 2, 3, 0.4, 0, Math.PI * 2);
    ctx.fill();
    
    // â•â•â• BROWN SPOTS (aged/rotten) â•â•â•
    ctx.fillStyle = '#8a6a2a';
    
    // Body spots
    ctx.beginPath();
    ctx.ellipse(-3, -8, 1.2, 1.5, 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.ellipse(2, -5, 1, 1.3, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(0, -12, 0.7, 0, Math.PI * 2);
    ctx.fill();
    
    // Peel spots
    ctx.beginPath();
    ctx.arc(-7, 9, 0.8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(6, 10, 0.9, 0, Math.PI * 2);
    ctx.fill();
    
    // â•â•â• CENTER OPENING (where peels fan out) â•â•â•
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(0, 2, 4, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // â•â•â• BODY SHINE (glossy banana) â•â•â•
    ctx.fillStyle = 'rgba(255, 255, 220, 0.6)';
    ctx.beginPath();
    ctx.ellipse(-2, -10, 2, 4, -0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // â•â•â• PEEL EDGE OUTLINES â•â•â•
    ctx.strokeStyle = '#d4b830';
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.6;
    
    // Outline main peels
    ctx.beginPath();
    ctx.moveTo(-3, 0);
    ctx.bezierCurveTo(-5, 2, -9, 5, -11, 8);
    ctx.bezierCurveTo(-12, 10, -11, 12, -9, 13);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(3, 0);
    ctx.bezierCurveTo(5, 2, 9, 5, 11, 8);
    ctx.bezierCurveTo(12, 10, 11, 12, 9, 13);
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    
    ctx.restore(); // End banana peel scale
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NINTENDO POLISH: STINK LINES (Odor emanating from rotten banana)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const time = Date.now();
    const stinkPhase = book.bobPhase + time * 0.002;
    
    // Green wavy stink lines (3 lines emanating from top)
    ctx.strokeStyle = '#8aaa6a';
    ctx.lineWidth = 1.5;
    ctx.lineCap = 'round';
    ctx.globalAlpha = 0.6 + Math.sin(stinkPhase) * 0.2;
    
    for (let i = 0; i < 3; i++) {
      const offsetX = (i - 1) * 8; // Spread lines left-right
      const linePhase = stinkPhase + i * 0.5;
      
      ctx.beginPath();
      
      // Wavy line going upward from banana
      for (let j = 0; j < 5; j++) {
        const t = j / 4;
        const x = offsetX + Math.sin(linePhase + j * 0.5) * 3;
        const y = -35 - (t * 15); // Rise upward from top of banana
        
        if (j === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
    
  } else {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REGULAR BOOK (EVEN BIGGER - 32Ã—44)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Book body (increased from 24Ã—32 to 32Ã—44)
    ctx.fillStyle = BOOK_COLORS[book.type];
    ctx.fillRect(-16, -22, 32, 44);
    
    // Black spine (left side)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-17, -22, 1, 44);
    
    // Page edge (right side)
    ctx.fillStyle = '#f0ebd6';
    ctx.fillRect(15, -22, 1, 44);
    
    // Top edge (pages)
    ctx.fillRect(-16, -23, 32, 1);
  }
  
  ctx.restore();
}

function renderPowerup(p) {
  if (!p || !p.type) return; // Safety check
  
  const powerup = POWERUP_TYPES[p.type];
  if (!powerup) return; // Safety check
  
  const x = p.x;
  const y = p.y + Math.sin(p.bobPhase) * 6; // Increased bob amplitude
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BIGGER POWERUPS - 2x scale for visibility!
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Pulsing glow (larger)
  const pulse = Math.sin(p.pulsePhase) * 0.3 + 0.7;
  ctx.globalAlpha = 0.5 * pulse;
  ctx.fillStyle = powerup.color;
  ctx.beginPath();
  ctx.arc(x, y, 40, 0, Math.PI * 2); // Increased from 20 to 40
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Secondary glow ring (extra visibility)
  ctx.globalAlpha = 0.3 * pulse;
  ctx.fillStyle = powerup.color;
  ctx.beginPath();
  ctx.arc(x, y, 50, 0, Math.PI * 2); // Extra outer glow
  ctx.fill();
  ctx.globalAlpha = 1;
  
  // Icon background (larger)
  ctx.fillStyle = 'rgba(42, 42, 74, 0.9)';
  ctx.beginPath();
  ctx.arc(x, y, 28, 0, Math.PI * 2); // Increased from 14 to 28
  ctx.fill();
  
  // Border (thicker and larger)
  ctx.strokeStyle = powerup.color;
  ctx.lineWidth = 4; // Increased from 2 to 4
  ctx.beginPath();
  ctx.arc(x, y, 28, 0, Math.PI * 2); // Increased from 14 to 28
  ctx.stroke();
  
  // Inner highlight ring (polish)
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, 26, Math.PI * 1.2, Math.PI * 1.8);
  ctx.stroke();
  
  // Icon (larger)
  ctx.font = '32px "Press Start 2P"'; // Increased from 16 to 32
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = powerup.color;
  ctx.fillText(powerup.icon, x, y);
  ctx.textBaseline = 'alphabetic';
  
  // Sparkle particles around powerup (extra polish)
  if (Math.random() < 0.1) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 35 + Math.random() * 10;
    PARTICLE_TYPES.SPARKLE(
      x + Math.cos(angle) * dist,
      y + Math.sin(angle) * dist,
      powerup.color,
      600
    );
  }
}

function renderPlayer() {
  const px = player.x;
  const py = player.y;
  
  // Render dash trail first (behind player)
  if (player.dashTrail.length > 0) {
    for (let i = 0; i < player.dashTrail.length; i++) {
      const trail = player.dashTrail[i];
      const alpha = trail.alpha * (i / player.dashTrail.length);
      ctx.globalAlpha = alpha * 0.4;
      
      // Simplified player silhouette for trail
      ctx.fillStyle = '#4a8cff';
      ctx.fillRect(trail.x - 7, trail.y - 10, 14, 20);
      
      ctx.globalAlpha = 1;
    }
  }
  
  // Invincibility glow
  if (player.invincible) {
    const pulse = Math.sin(Date.now() * 0.02) * 0.5 + 0.5;
    ctx.globalAlpha = 0.6 * pulse;
    ctx.fillStyle = POWERUP_TYPES.REPEL.color;
    ctx.beginPath();
    ctx.arc(px, py, 30, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  // Idle breathing animation
  const breathe = Math.sin(player.idleTimer * 0.003) * 1.5;
  const baseY = py + breathe;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NINTENDO: SCALE PLAYER TO SHELF HEIGHT (48px)
  // Player is now same height as bookshelves for proper presence!
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const PLAYER_SCALE = 2.6; // Scale up from 27px to ~70px (even bigger!)
  
  // Cape sway animation (follows breathing + movement)
  const capeSway = Math.sin(player.idleTimer * 0.004 + Date.now() * 0.001) * 1.5;
  const capeMovement = player.walkFrame === 1 ? 1 : player.walkFrame === 3 ? -1 : 0;
  
  // Shadow (scaled)
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(px, baseY + 15 * PLAYER_SCALE, 14 * PLAYER_SCALE, 5 * PLAYER_SCALE, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Apply scale transformation for entire player
  ctx.save();
  ctx.translate(px, baseY);
  ctx.scale(PLAYER_SCALE, PLAYER_SCALE);
  ctx.translate(-px, -baseY);
  
  // â•â•â• CAPE (renders behind body) â•â•â•
  if (player.dir !== 0) { // Don't render cape in front view
    const capeX = px + (player.dir === 1 ? -8 : player.dir === 3 ? 8 : 0);
    const capeY = baseY - 8;
    const capeWidth = 16;
    const capeHeight = 18;
    
    // Cape shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(capeX - capeWidth/2 + 1 + capeSway, capeY + 1, capeWidth, capeHeight);
    
    // Cape main
    ctx.fillStyle = '#c41e1e';
    ctx.fillRect(capeX - capeWidth/2 + capeSway, capeY, capeWidth, capeHeight);
    
    // Cape highlights (shine)
    ctx.fillStyle = '#e84a4a';
    ctx.fillRect(capeX - capeWidth/2 + 2 + capeSway, capeY + 2, 4, capeHeight - 4);
    
    // Cape border (gold trim)
    ctx.strokeStyle = '#c8a84a';
    ctx.lineWidth = 1;
    ctx.strokeRect(capeX - capeWidth/2 + capeSway, capeY, capeWidth, capeHeight);
    
    // Cape attachment point
    ctx.fillStyle = '#c8a84a';
    ctx.fillRect(px - 8, baseY - 8, 3, 3);
    ctx.fillRect(px + 5, baseY - 8, 3, 3);
  }
  
  // Walking animation - leg positions
  const walkCycle = [
    { left: 0, right: 0 },    // Frame 0: neutral
    { left: -2, right: 2 },   // Frame 1: left forward
    { left: 0, right: 0 },    // Frame 2: neutral
    { left: 2, right: -2 }    // Frame 3: right forward
  ];
  const legPos = walkCycle[player.walkFrame];
  
  // â•â•â• LEGS & BOOTS â•â•â•
  ctx.fillStyle = '#2c2c6e'; // Luchador tights
  if (player.dir === 0 || player.dir === 2) { // Front/back view
    // Left leg
    ctx.fillRect(px - 6, baseY + 4 + legPos.left, 5, 9 - Math.abs(legPos.left));
    // Right leg
    ctx.fillRect(px + 1, baseY + 4 + legPos.right, 5, 9 - Math.abs(legPos.right));
    
    // Knee pads
    ctx.fillStyle = '#d62a2a';
    ctx.fillRect(px - 6, baseY + 7 + legPos.left, 5, 3);
    ctx.fillRect(px + 1, baseY + 7 + legPos.right, 5, 3);
    
    // Wrestling boots
    ctx.fillStyle = '#3d2b1a';
    ctx.fillRect(px - 7, baseY + 11 + legPos.left, 6, 4);
    ctx.fillRect(px + 1, baseY + 11 + legPos.right, 6, 4);
    
    // Boot laces
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(px - 4, baseY + 12 + legPos.left);
    ctx.lineTo(px - 4, baseY + 14 + legPos.left);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px + 4, baseY + 12 + legPos.right);
    ctx.lineTo(px + 4, baseY + 14 + legPos.right);
    ctx.stroke();
  } else { // Side view
    const offset = player.walkFrame === 1 || player.walkFrame === 3 ? 1 : 0;
    ctx.fillRect(px - 3, baseY + 4 + offset, 6, 9);
    
    // Knee pad
    ctx.fillStyle = '#d62a2a';
    ctx.fillRect(px - 3, baseY + 7 + offset, 6, 3);
    
    // Boot
    ctx.fillStyle = '#3d2b1a';
    ctx.fillRect(px - 3, baseY + 11, 6, 4);
  }
  
  // â•â•â• BODY & SINGLET â•â•â•
  const bodyY = baseY - 3;
  
  // Singlet base (luchador suit)
  ctx.fillStyle = '#d62a2a'; // Red
  ctx.fillRect(px - 8, bodyY, 16, 10);
  
  // Singlet pattern (white stripe)
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(px - 2, bodyY + 1, 4, 8);
  
  // Singlet side accents
  ctx.fillStyle = '#c8a84a'; // Gold
  ctx.fillRect(px - 8, bodyY + 3, 2, 4);
  ctx.fillRect(px + 6, bodyY + 3, 2, 4);
  
  // â•â•â• VEST (Library uniform) â•â•â•
  ctx.fillStyle = '#4a3828'; // Brown leather vest
  // Left side
  ctx.fillRect(px - 9, bodyY, 4, 10);
  // Right side
  ctx.fillRect(px + 5, bodyY, 4, 10);
  
  // Vest buttons
  ctx.fillStyle = '#c8a84a';
  ctx.fillRect(px - 8, bodyY + 2, 2, 2);
  ctx.fillRect(px - 8, bodyY + 6, 2, 2);
  ctx.fillRect(px + 6, bodyY + 2, 2, 2);
  ctx.fillRect(px + 6, bodyY + 6, 2, 2);
  
  // Utility belt
  ctx.fillStyle = '#2a2a1a';
  ctx.fillRect(px - 8, bodyY + 9, 16, 2);
  ctx.fillStyle = '#c8a84a';
  ctx.fillRect(px - 1, bodyY + 9, 2, 3); // Belt buckle
  
  // â•â•â• ARMS â•â•â•
  ctx.fillStyle = '#e8b88a'; // Skin
  const armSwing = player.walkFrame === 1 ? -1 : player.walkFrame === 3 ? 1 : 0;
  
  // Determine if carrying books (arms hold them)
  const isCarrying = player.carrying.length > 0;
  
  if (player.dir === 0 || player.dir === 2) { // Front/back view
    if (isCarrying) {
      // Arms holding books in front
      // Left arm
      ctx.fillRect(px - 11, bodyY + 3, 3, 8);
      // Right arm
      ctx.fillRect(px + 8, bodyY + 3, 3, 8);
      
      // Hands
      ctx.fillStyle = '#d8a87a';
      ctx.fillRect(px - 11, bodyY + 10, 3, 3);
      ctx.fillRect(px + 8, bodyY + 10, 3, 3);
    } else {
      // Arms at sides, animated
      // Left arm
      ctx.fillRect(px - 11, bodyY + 2 - armSwing, 3, 8);
      // Right arm
      ctx.fillRect(px + 8, bodyY + 2 + armSwing, 3, 8);
    }
    
    // Vest sleeves
    ctx.fillStyle = '#4a3828';
    ctx.fillRect(px - 11, bodyY, 3, 4);
    ctx.fillRect(px + 8, bodyY, 3, 4);
  } else { // Side view
    const ax = player.dir === 1 ? px + 7 : px - 10;
    
    if (isCarrying) {
      // Arm forward holding books
      ctx.fillRect(ax, bodyY + 3, 3, 8);
      ctx.fillStyle = '#d8a87a';
      ctx.fillRect(ax, bodyY + 10, 3, 3);
    } else {
      ctx.fillRect(ax, bodyY + 2 + armSwing, 3, 8);
    }
    
    // Vest sleeve
    ctx.fillStyle = '#4a3828';
    ctx.fillRect(ax, bodyY, 3, 4);
  }
  
  // â•â•â• HEAD & NECK â•â•â•
  const headBob = player.walkFrame === 0 || player.walkFrame === 2 ? 0 : -1;
  const headY = bodyY - 9 + headBob;
  
  // Neck
  ctx.fillStyle = '#e8b88a';
  ctx.fillRect(px - 3, bodyY - 2, 6, 3);
  
  // Bow tie
  ctx.fillStyle = '#1a1a4a'; // Dark blue
  ctx.fillRect(px - 4, bodyY - 1, 8, 2);
  ctx.fillRect(px - 2, bodyY - 2, 4, 4);
  ctx.fillStyle = '#4a4a8a'; // Lighter blue center
  ctx.fillRect(px - 1, bodyY - 1, 2, 2);
  
  // Head base (skin/chin showing)
  ctx.fillStyle = '#e8b88a';
  ctx.fillRect(px - 7, headY, 14, 10);
  
  // â•â•â• LUCHADOR MASK (UPGRADED DESIGN) â•â•â•
  // Main mask color
  ctx.fillStyle = '#d62a2a'; // Red
  ctx.fillRect(px - 7, headY, 14, 8);
  
  // Mask top stripe (white)
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(px - 7, headY, 14, 3);
  
  // Mask center stripe (gold)
  ctx.fillStyle = '#c8a84a';
  ctx.fillRect(px - 2, headY, 4, 8);
  
  // Mask star emblem (center)
  ctx.fillStyle = '#f0e840';
  const starSize = 3;
  // Simple star (5-pointed)
  ctx.fillRect(px - 1, headY + 3, 2, 2);
  ctx.fillRect(px - 2, headY + 4, 4, 1);
  ctx.fillRect(px, headY + 2, 1, 1);
  
  // Mask nose bridge
  ctx.fillStyle = '#b81c1c';
  ctx.fillRect(px - 1, headY + 4, 2, 3);
  
  // Eye holes (almond-shaped)
  const shouldBlink = Math.floor(player.idleTimer / 2000) % 5 === 0 && 
                      (player.idleTimer % 2000) < 100;
  
  if (!shouldBlink && player.dir !== 2) { // Don't show eyes when facing away
    // Eye hole outlines
    ctx.fillStyle = '#1a1a1a';
    
    if (player.dir === 0 || player.dir === 3) { // Left eye
      // Almond shape (wider in middle)
      ctx.fillRect(px - 5, headY + 4, 1, 2);
      ctx.fillRect(px - 4, headY + 3, 2, 4);
      ctx.fillRect(px - 2, headY + 4, 1, 2);
      
      // Eye inside (white)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px - 4, headY + 4, 2, 2);
      
      // Pupil
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(px - 4, headY + 4, 1, 1);
    }
    
    if (player.dir === 0 || player.dir === 1) { // Right eye
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(px + 1, headY + 4, 1, 2);
      ctx.fillRect(px + 2, headY + 3, 2, 4);
      ctx.fillRect(px + 4, headY + 4, 1, 2);
      
      // Eye inside
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px + 2, headY + 4, 2, 2);
      
      // Pupil
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(px + 3, headY + 4, 1, 1);
    }
  } else if (shouldBlink && player.dir !== 2) {
    // Blink - horizontal lines
    ctx.fillStyle = '#1a1a1a';
    if (player.dir === 0 || player.dir === 3) {
      ctx.fillRect(px - 5, headY + 4, 3, 1);
    }
    if (player.dir === 0 || player.dir === 1) {
      ctx.fillRect(px + 2, headY + 4, 3, 1);
    }
  }
  
  // Mask stitching detail
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(px - 7, headY + 2);
  ctx.lineTo(px + 7, headY + 2);
  ctx.stroke();
  
  // â•â•â• CARRYING BOOKS (in arms, not floating) â•â•â•
  if (player.carrying.length > 0) {
    const numBooks = player.carrying.length;
    const stackWidth = Math.min(numBooks * 5, 12);
    const stackX = px - stackWidth / 2;
    const stackY = bodyY + 8;
    
    // Draw books stacked in arms
    for (let i = 0; i < numBooks; i++) {
      const book = player.carrying[i];
      const bookOffset = i * 2;
      const bookBob = Math.sin(Date.now() * 0.005 + i * 0.5) * 0.5;
      
      // Book
      ctx.fillStyle = BOOK_COLORS[book.type];
      ctx.fillRect(stackX + bookOffset, stackY - i * 3 + bookBob, 8, 3);
      
      // Book spine
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(stackX + bookOffset, stackY - i * 3 + bookBob, 1, 3);
      
      // Book pages (side view)
      ctx.fillStyle = '#f0f0e8';
      ctx.fillRect(stackX + bookOffset + 7, stackY - i * 3 + bookBob, 1, 3);
    }
    
    // Struggle indicator when carrying many
    if (numBooks >= 4) {
      const sweat = Math.sin(Date.now() * 0.02);
      if (sweat > 0.8) {
        ctx.fillStyle = '#6ab8ff';
        ctx.fillRect(px + 5, headY + 2, 2, 2);
      }
    }
  }
  
  // Power-up visual effects
  if (activePowerup && activePowerup.type) {
    renderPowerupEffects(px, py);
  }
  
  // Dash speed lines effect
  if (player.dashing) {
    const speedLineCount = 5;
    for (let i = 0; i < speedLineCount; i++) {
      const lineAlpha = 0.6 - (i * 0.1);
      ctx.globalAlpha = lineAlpha;
      ctx.strokeStyle = '#4a8cff';
      ctx.lineWidth = 2;
      
      let startX, startY, endX, endY;
      if (player.dir === 0) { // Down
        startX = px + rnd(-10, 10);
        startY = py - 20 - i * 8;
        endX = startX;
        endY = startY - 12;
      } else if (player.dir === 1) { // Right
        startX = px - 20 - i * 8;
        startY = py + rnd(-10, 10);
        endX = startX - 12;
        endY = startY;
      } else if (player.dir === 2) { // Up
        startX = px + rnd(-10, 10);
        startY = py + 20 + i * 8;
        endX = startX;
        endY = startY + 12;
      } else { // Left
        startX = px + 20 + i * 8;
        startY = py + rnd(-10, 10);
        endX = startX + 12;
        endY = startY;
      }
      
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  
  // Book throw charge indicator
  if (player.throwingBook && player.throwCharge > 0) {
    const chargeSize = 15 + player.throwCharge * 15;
    ctx.strokeStyle = '#ff6aaa';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.5 + player.throwCharge * 0.3;
    ctx.beginPath();
    ctx.arc(px, py - 35, chargeSize, 0, Math.PI * 2 * player.throwCharge);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Charge attack indicator
  if (player.chargingAttack && player.chargeProgress > 0) {
    const rings = 3;
    for (let i = 0; i < rings; i++) {
      const ringSize = 30 + i * 15 + player.chargeProgress * 20;
      const pulse = Math.sin(Date.now() * 0.01 + i) * 0.2 + 0.6;
      ctx.strokeStyle = '#f0e840';
      ctx.lineWidth = 2;
      ctx.globalAlpha = pulse * player.chargeProgress;
      ctx.beginPath();
      ctx.arc(px, py, ringSize, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    
    // Charge percentage text
    if (player.chargeProgress >= 0.5) {
      ctx.fillStyle = player.chargeProgress >= 1 ? '#f0e840' : '#ffffff';
      ctx.font = '8px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText(`${Math.floor(player.chargeProgress * 100)}%`, px, py - 50);
    }
  }
  
  // Parry window indicator
  if (parryWindow > 0) {
    const pulse = Math.sin(Date.now() * 0.05) * 0.3 + 0.7;
    ctx.strokeStyle = '#f0e840';
    ctx.lineWidth = 3;
    ctx.globalAlpha = pulse;
    ctx.beginPath();
    ctx.arc(px, py, 25, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Restore player scale transformation
  ctx.restore();
}

// â”€â”€ Render Power-up Visual Effects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderPowerupEffects(px, py) {
  const powerup = POWERUP_TYPES[activePowerup.type];
  if (!powerup) return;
  
  const time = Date.now();
  
  switch(activePowerup.type) {
    case 'SPEED':
      // Speed lines radiating outward
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + time * 0.01;
        const dist = 25 + Math.sin(time * 0.005 + i) * 5;
        const lineLength = 12;
        
        const x1 = px + Math.cos(angle) * dist;
        const y1 = py + Math.sin(angle) * dist;
        const x2 = px + Math.cos(angle) * (dist + lineLength);
        const y2 = py + Math.sin(angle) * (dist + lineLength);
        
        ctx.strokeStyle = powerup.color;
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Speed icon floating above
      ctx.fillStyle = powerup.color;
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      const speedBob = Math.sin(time * 0.008) * 3;
      ctx.fillText('âš¡', px, py - 35 + speedBob);
      break;
      
    case 'MULTICARRY':
      // Orbiting book icons
      const bookCount = 3;
      for (let i = 0; i < bookCount; i++) {
        const angle = (i / bookCount) * Math.PI * 2 + time * 0.003;
        const orbitRadius = 30;
        const bx = px + Math.cos(angle) * orbitRadius;
        const by = py + Math.sin(angle) * orbitRadius;
        
        ctx.fillStyle = powerup.color;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(bx - 3, by - 4, 6, 8);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(bx - 3, by - 4, 1, 8);
      }
      ctx.globalAlpha = 1;
      
      // Icon above
      ctx.fillStyle = powerup.color;
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      const carryBob = Math.sin(time * 0.008) * 3;
      ctx.fillText('ğŸ“š', px, py - 35 + carryBob);
      break;
      
    case 'REPEL':
      // Pulsing shield bubble
      const shieldPulse = Math.sin(time * 0.01) * 0.2 + 0.8;
      const shieldRadius = 35 * shieldPulse;
      
      // Outer glow
      ctx.globalAlpha = 0.2 * shieldPulse;
      ctx.fillStyle = powerup.color;
      ctx.beginPath();
      ctx.arc(px, py, shieldRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Shield ring
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = powerup.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(px, py, shieldRadius - 5, 0, Math.PI * 2);
      ctx.stroke();
      
      // Hexagon pattern
      ctx.globalAlpha = 0.3;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 + time * 0.002;
        const hx = px + Math.cos(angle) * (shieldRadius - 10);
        const hy = py + Math.sin(angle) * (shieldRadius - 10);
        
        ctx.beginPath();
        for (let j = 0; j < 6; j++) {
          const hexAngle = (j / 6) * Math.PI * 2;
          const hexX = hx + Math.cos(hexAngle) * 5;
          const hexY = hy + Math.sin(hexAngle) * 5;
          if (j === 0) ctx.moveTo(hexX, hexY);
          else ctx.lineTo(hexX, hexY);
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
      
      // Icon above
      ctx.fillStyle = powerup.color;
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ›¡ï¸', px, py - 45);
      break;
      
    case 'TIMEFREEZE':
      // Frozen time effect - clock particles
      const clockCount = 12;
      for (let i = 0; i < clockCount; i++) {
        const angle = (i / clockCount) * Math.PI * 2;
        const dist = 25;
        const cx = px + Math.cos(angle) * dist;
        const cy = py + Math.sin(angle) * dist;
        
        // Clock face
        ctx.fillStyle = powerup.color;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Clock hands
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx, cy - 3);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      
      // Freeze waves
      const freezeWave1 = (time * 0.005) % 1;
      const freezeWave2 = ((time * 0.005) + 0.5) % 1;
      
      ctx.strokeStyle = powerup.color;
      ctx.globalAlpha = 1 - freezeWave1;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px, py, freezeWave1 * 40, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1 - freezeWave2;
      ctx.beginPath();
      ctx.arc(px, py, freezeWave2 * 40, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // Icon above
      ctx.fillStyle = powerup.color;
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('â¸ï¸', px, py - 35);
      break;
      
    case 'AUTOSORT':
      // Targeting arrows pointing to nearest shelf
      const arrowCount = 4;
      for (let i = 0; i < arrowCount; i++) {
        const rotation = (time * 0.005 + i * (Math.PI * 2 / arrowCount)) % (Math.PI * 2);
        const arrowDist = 28 + Math.sin(time * 0.01 + i) * 3;
        const arrowX = px + Math.cos(rotation) * arrowDist;
        const arrowY = py + Math.sin(rotation) * arrowDist;
        
        ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(rotation);
        
        ctx.fillStyle = powerup.color;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.lineTo(-3, -4);
        ctx.lineTo(-3, 4);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      
      // Icon above
      ctx.fillStyle = powerup.color;
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      const targetBob = Math.sin(time * 0.008) * 3;
      ctx.fillText('ğŸ¯', px, py - 35 + targetBob);
      break;
      
    case 'DOUBLEPOINTS':
      // Golden sparkles orbiting
      const sparkleCount = 8;
      for (let i = 0; i < sparkleCount; i++) {
        const angle = (i / sparkleCount) * Math.PI * 2 + time * 0.004;
        const dist = 25 + Math.sin(time * 0.006 + i) * 5;
        const sx = px + Math.cos(angle) * dist;
        const sy = py + Math.sin(angle) * dist;
        
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(angle);
        
        // 4-pointed star
        ctx.fillStyle = powerup.color;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        for (let j = 0; j < 4; j++) {
          const starAngle = (j / 4) * Math.PI * 2;
          const r = j % 2 === 0 ? 4 : 2;
          const starX = Math.cos(starAngle) * r;
          const starY = Math.sin(starAngle) * r;
          if (j === 0) ctx.moveTo(starX, starY);
          else ctx.lineTo(starX, starY);
        }
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      
      // Dollar signs
      ctx.fillStyle = powerup.color;
      ctx.font = 'bold 10px "Press Start 2P"';
      ctx.textAlign = 'center';
      const coin1Y = py - 35 + Math.sin(time * 0.01) * 3;
      const coin2Y = py - 35 + Math.sin(time * 0.01 + Math.PI) * 3;
      ctx.fillText('$', px - 8, coin1Y);
      ctx.fillText('$', px + 8, coin2Y);
      
      // Icon
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText('ğŸ’°', px, py - 50);
      break;
  }
  
  ctx.globalAlpha = 1;
}

function renderGhost(g) {
  if (!g || !g.typeData) return;
  
  const x = g.x;
  const y = g.y + Math.sin(g.phase) * 3;
  
  // Mini-ghosts from swarm splits are smaller
  const size = g.isMiniGhost ? g.miniGhostSize : g.typeData.size;
  
  // Spawn animation (fade in)
  if (g.spawnAnimation > 0) {
    ctx.globalAlpha = 1 - g.spawnAnimation;
  }
  
  // Damage flash
  if (g.damageFlash > 0) {
    ctx.globalAlpha = Math.sin(g.damageFlash * 0.05) > 0 ? 0.3 : 1;
  }
  
  // Attack telegraph (boss charging)
  if (g.attackTelegraph > 0 && g.attackTelegraph < 1) {
    const pulse = Math.sin(Date.now() * 0.02);
    ctx.globalAlpha = 0.5 + pulse * 0.3;
    
    // Warning indicator
    ctx.fillStyle = '#ff2222';
    ctx.beginPath();
    ctx.arc(x, y, size + 10, 0, Math.PI * 2 * g.attackTelegraph);
    ctx.stroke();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#ff2222';
    ctx.globalAlpha = g.attackTelegraph;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Ethereal trail effect
  if (g.type === 'FAST') {
    for (let i = 0; i < 3; i++) {
      ctx.globalAlpha = 0.2 - i * 0.06;
      ctx.fillStyle = g.typeData.color;
      const trailX = x - (Math.cos(Math.atan2(player.y - y, player.x - x)) * i * 8);
      const trailY = y - (Math.sin(Math.atan2(player.y - y, player.x - x)) * i * 8);
      ctx.beginPath();
      ctx.arc(trailX, trailY, size - i * 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  
  // Main ghost body
  ctx.fillStyle = g.typeData.color;
  ctx.globalAlpha = 0.85;
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI * 2);
  ctx.fill();
  
  // Inner glow
  const gradient = ctx.createRadialGradient(x, y - size/3, 0, x, y, size);
  gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(x - size, y - size, size * 2, size * 2);
  
  // Type-specific details
  switch(g.type) {
    case 'MIMIC':
      // Render as book when disguised!
      if (g.disguised) {
        ctx.globalAlpha = 1;
        ctx.save();
        ctx.translate(x, y);
        
        // Render fake book
        const bookColor = BOOK_COLORS[g.disguiseType];
        ctx.fillStyle = bookColor;
        ctx.fillRect(-8, -11, 16, 22);
        
        // Spine
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(-9, -11, 1, 22);
        ctx.fillRect(8, -11, 1, 22);
        
        // Pages
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(-7, -10, 14, 20);
        
        // Text lines on cover
        ctx.fillStyle = '#1a1a1a';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(-6, -6 + i * 5, 12, 1);
        }
        
        ctx.restore();
        return; // Don't render ghost body
      }
      // If revealed, show with purple glow
      ctx.strokeStyle = '#aa44aa';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(x, y, size + 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      break;
      
    case 'BOMBER':
      // Flashing fuse when close to player
      if (g.fuseFlash) {
        const flashRate = Math.min(20, g.fuseFlash * 0.02);
        const flash = Math.sin(Date.now() * flashRate) > 0;
        
        if (flash) {
          ctx.fillStyle = '#ff6666';
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.arc(x, y, size + 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        // Fuse spark on top
        ctx.fillStyle = flash ? '#ffff00' : '#ff6666';
        ctx.globalAlpha = flash ? 1 : 0.6;
        ctx.beginPath();
        ctx.arc(x, y - size - 4, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      break;
      
    case 'POSSESSOR':
      // Ethereal floating effect
      if (g.possessing) {
        // Pulsing possession indicator
        const pulse = Math.sin(Date.now() * 0.005);
        ctx.strokeStyle = '#aa44aa';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + pulse * 0.3;
        ctx.beginPath();
        ctx.arc(x, y, size + 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Energy tendrils to shelf
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2 + Date.now() * 0.001;
          const dist = size + 5;
          const px = x + Math.cos(angle) * dist;
          const py = y + Math.sin(angle) * dist;
          ctx.fillStyle = '#aa44aa';
          ctx.globalAlpha = 0.4;
          ctx.fillRect(px - 1, py - 1, 2, 2);
        }
        ctx.globalAlpha = 1;
      }
      break;
      
    case 'SHIELD':
      // Rotating shield arc
      if (g.shieldActive) {
        ctx.strokeStyle = '#aaaaff';
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(
          x, y, size + 5,
          g.shieldRotation - g.typeData.shieldArc / 2,
          g.shieldRotation + g.typeData.shieldArc / 2
        );
        ctx.stroke();
        
        // Shield shine
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(
          x, y, size + 6,
          g.shieldRotation - g.typeData.shieldArc / 4,
          g.shieldRotation + g.typeData.shieldArc / 4
        );
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      break;
      
    case 'CHAIN':
      // Draw chain to partner
      if (g.chainPartner && g.chainPartner.health > 0) {
        ctx.strokeStyle = '#cc88ff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(g.chainPartner.x, g.chainPartner.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Energy pulses along chain
        const chainDist = dist(x, y, g.chainPartner.x, g.chainPartner.y);
        const pulsePos = (Date.now() * 0.001) % 1;
        const pulseX = x + (g.chainPartner.x - x) * pulsePos;
        const pulseY = y + (g.chainPartner.y - y) * pulsePos;
        
        ctx.fillStyle = '#cc88ff';
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(pulseX, pulseY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      break;
      
    case 'SWARM':
      // Swarm indicator - multiple ghost silhouettes
      for (let i = 0; i < 3; i++) {
        const offset = (i - 1) * 4;
        ctx.fillStyle = g.typeData.color;
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.arc(x + offset, y + offset, size - 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      break;
    
    case 'BOSS':
      // Crown
      ctx.fillStyle = '#f0e840';
      ctx.globalAlpha = 1;
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
        const crownX = x + Math.cos(angle) * (size - 2);
        const crownY = y + Math.sin(angle) * (size - 2) - 4;
        ctx.fillRect(crownX - 2, crownY, 4, 6);
      }
      
      // Health bar
      if (g.health < g.maxHealth) {
        const barW = size * 2;
        const barH = 4;
        const barX = x - barW / 2;
        const barY = y - size - 10;
        
        ctx.fillStyle = '#2a2a3a';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(barX, barY, barW, barH);
        
        const healthPct = g.health / g.maxHealth;
        ctx.fillStyle = healthPct > 0.5 ? '#2aaa5c' : healthPct > 0.25 ? '#f0e840' : '#ff2222';
        ctx.fillRect(barX, barY, barW * healthPct, barH);
      }
      break;
      
    case 'TANK':
      // Armor plating
      ctx.strokeStyle = '#8a8a9a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(x, y, size - 2, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y, size - 5, 0, Math.PI * 2);
      ctx.stroke();
      break;
      
    case 'TELEPORTER':
      // Teleport particles
      if (g.teleportCooldown > 2500) {
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + g.phase;
          const dist = size + 8;
          const px = x + Math.cos(angle) * dist;
          const py = y + Math.sin(angle) * dist;
          ctx.fillStyle = g.typeData.color;
          ctx.globalAlpha = 0.6;
          ctx.fillRect(px - 2, py - 2, 4, 4);
        }
      }
      break;
      
    case 'RANGED':
      // Show targeting line when ready to shoot
      if (g.shootCooldown <= 500) { // Last 500ms before shot
        const angleToPlayer = Math.atan2(player.y - y, player.x - x);
        const lineLength = dist(x, y, player.x, player.y);
        const pulse = Math.sin(Date.now() * 0.02) * 0.3 + 0.5;
        
        ctx.strokeStyle = g.typeData.color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = pulse * 0.4;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angleToPlayer) * lineLength, y + Math.sin(angleToPlayer) * lineLength);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }
      
      // Charging indicator
      if (g.shootCooldown <= 0) {
        const chargeSize = size + 5 + Math.sin(Date.now() * 0.01) * 3;
        ctx.strokeStyle = g.typeData.color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(x, y, chargeSize, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      break;
  }
  
  ctx.globalAlpha = 0.85;
  
  // Wispy bottom (animated tendrils)
  ctx.fillStyle = g.typeData.color;
  ctx.globalAlpha = 0.6;
  const wave = Math.sin(g.phase);
  const wave2 = Math.sin(g.phase + Math.PI / 2);
  const tendrilCount = g.type === 'BOSS' ? 5 : 3;
  
  for (let i = 0; i < tendrilCount; i++) {
    const offset = (i - tendrilCount / 2) * 8;
    const wavePhase = wave * (i % 2 === 0 ? 1 : -1);
    const tendrilX = x + offset + wavePhase * 2;
    const tendrilY = y + size;
    const tendrilH = 6 + Math.abs(wavePhase) * 2;
    
    ctx.fillRect(tendrilX - 2, tendrilY, 4, tendrilH);
  }
  
  ctx.globalAlpha = 1;
  
  // Eyes (change based on type)
  const eyeColor = g.type === 'BOSS' ? '#ff2222' : g.type === 'FAST' ? '#4a8cff' : '#3a1a6e';
  ctx.fillStyle = eyeColor;
  
  // Blinking animation
  const shouldBlink = Math.floor(g.phase / (Math.PI * 2)) % 8 === 0 && (g.phase % (Math.PI * 2)) < 0.2;
  const eyeH = shouldBlink ? 1 : 3;
  
  ctx.fillRect(x - size/2, y - 2, 3, eyeH);
  ctx.fillRect(x + size/2 - 3, y - 2, 3, eyeH);
  
  // Angry eyebrows for boss
  if (g.type === 'BOSS') {
    ctx.strokeStyle = eyeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - size/2 - 2, y - 5);
    ctx.lineTo(x - size/2 + 4, y - 3);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + size/2 + 2, y - 5);
    ctx.lineTo(x + size/2 - 4, y - 3);
    ctx.stroke();
  }
  
  ctx.globalAlpha = 1;
}

function renderParticle(p) {
  // Safety check
  if (!p) return;
  
  const alpha = p.fadeIn && p.life > p.maxLife * 0.8 
    ? (p.maxLife - p.life) / (p.maxLife * 0.2)
    : p.life / p.maxLife;
  
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rotation || 0);
  
  // Default to 'square' if no type specified
  const particleType = p.type || 'square';
  
  switch(particleType) {
    case 'star':
      // 5-pointed star
      ctx.fillStyle = p.color;
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
        const r = i % 2 === 0 ? p.size : p.size * 0.4;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      
      // Glow effect
      if (p.trail) {
        ctx.globalAlpha = alpha * 0.3;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(0, 0, p.size * 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
      break;
      
    case 'page':
      // Book page with flutter
      const flutter = p.flutter ? Math.sin(p.flutter) * 0.3 : 0;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.moveTo(-p.size/2, -p.size);
      ctx.lineTo(p.size/2 + flutter * p.size, -p.size);
      ctx.lineTo(p.size/2 - flutter * p.size, p.size);
      ctx.lineTo(-p.size/2, p.size);
      ctx.closePath();
      ctx.fill();
      
      // Lines on page
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.lineWidth = 0.5;
      for (let i = -p.size/2; i < p.size; i += p.size/3) {
        ctx.beginPath();
        ctx.moveTo(-p.size/2, i);
        ctx.lineTo(p.size/2, i);
        ctx.stroke();
      }
      break;
      
    case 'circle':
      // Soft circle
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(0, 0, p.size, 0, Math.PI * 2);
      ctx.fill();
      break;
      
    case 'ring':
      // Expanding ring
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, p.size, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner glow
      ctx.globalAlpha = alpha * 0.2;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(0, 0, p.size, 0, Math.PI * 2);
      ctx.fill();
      break;
      
    case 'glow':
      // Soft glowing orb
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 2);
      gradient.addColorStop(0, p.color);
      gradient.addColorStop(0.5, p.color.replace(')', ', 0.5)').replace('rgb', 'rgba'));
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(-p.size * 2, -p.size * 2, p.size * 4, p.size * 4);
      break;
      
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SHELF-SPECIFIC PARTICLE TYPES (Nintendo Magic!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    case 'heart':
      // Floating heart (Romance shelf)
      ctx.fillStyle = p.color;
      ctx.globalAlpha = (p.alpha || 1) * alpha;
      ctx.beginPath();
      // Left half of heart
      ctx.arc(-p.size/4, -p.size/4, p.size/2, 0, Math.PI, true);
      // Right half of heart
      ctx.arc(p.size/4, -p.size/4, p.size/2, 0, Math.PI, true);
      // Bottom point
      ctx.lineTo(0, p.size/2);
      ctx.closePath();
      ctx.fill();
      
      // Heart outline
      ctx.strokeStyle = '#ff4a7a';
      ctx.lineWidth = 1;
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.5;
      ctx.stroke();
      break;
      
    case 'code':
      // Matrix-style code symbols (Tablets shelf)
      ctx.fillStyle = p.color;
      ctx.globalAlpha = (p.alpha || 1) * alpha;
      ctx.font = `${p.size}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.char || 'âŠ•', 0, 0);
      
      // Glow effect
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.3;
      ctx.font = `${p.size + 2}px monospace`;
      ctx.fillText(p.char || 'âŠ•', 0, 0);
      break;
      
    case 'petal':
      // Cherry blossom petal (Manga shelf)
      ctx.fillStyle = p.color;
      ctx.globalAlpha = (p.alpha || 1) * alpha;
      
      // Petal shape (ellipse)
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size * 0.6, p.size, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner detail
      ctx.strokeStyle = '#ffcce0';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.5;
      ctx.beginPath();
      ctx.moveTo(0, -p.size);
      ctx.lineTo(0, p.size);
      ctx.stroke();
      break;
      
    case 'bubble':
      // Science beaker bubble
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.6;
      
      // Bubble outline
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, 0, p.size, 0, Math.PI * 2);
      ctx.stroke();
      
      // Highlight glint
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.8;
      ctx.beginPath();
      ctx.arc(-p.size/3, -p.size/3, p.size/3, 0, Math.PI * 2);
      ctx.fill();
      break;
      
    case 'wisp':
      // Ominous purple wisp (Forbidden shelf)
      ctx.globalAlpha = (p.alpha || 1) * alpha;
      
      // Wisp glow gradient
      const wispGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size * 1.5);
      wispGradient.addColorStop(0, p.color);
      wispGradient.addColorStop(0.5, 'rgba(170, 68, 170, 0.3)');
      wispGradient.addColorStop(1, 'rgba(170, 68, 170, 0)');
      ctx.fillStyle = wispGradient;
      ctx.fillRect(-p.size * 1.5, -p.size * 1.5, p.size * 3, p.size * 3);
      
      // Wisp core
      ctx.globalAlpha = (p.alpha || 1) * alpha * 0.8;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size * 0.8, p.size, p.rotation || 0, 0, Math.PI * 2);
      ctx.fill();
      break;
      
    case 'square':
    default:
      // Default square
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      break;
  }
  
  ctx.restore();
}

function renderHUD() {
  const hh = 32; // Slightly taller HUD
  
  // HUD Background with gradient
  const hudGradient = ctx.createLinearGradient(0, 0, 0, hh);
  hudGradient.addColorStop(0, 'rgba(26, 26, 46, 0.98)');
  hudGradient.addColorStop(1, 'rgba(20, 20, 36, 0.98)');
  ctx.fillStyle = hudGradient;
  ctx.fillRect(0, 0, W, hh);
  
  // HUD border
  ctx.strokeStyle = 'rgba(200, 168, 74, 0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(0, hh - 1, W, 1);
  
  // === LEFT SIDE: Score with animation ===
  ctx.fillStyle = '#c8a84a';
  ctx.font = 'bold 11px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillText('SCORE', 10, 12);
  
  // Animated score counter
  ctx.fillStyle = '#f0e840';
  ctx.font = 'bold 13px "Press Start 2P"';
  ctx.fillText(`${Math.floor(scoreDisplay)}`, 10, 26);
  
  // Score increase sparkle
  if (score > scoreDisplay) {
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '#ffffff';
    ctx.fillText('â†‘', 80, 26);
    ctx.globalAlpha = 1;
  }
  
  // === CENTER LEFT: Health Bar with pulse ===
  const hx = 120;
  const hp = Math.max(0, player.health);
  const hpPct = hp / player.maxHealth;
  const dangerFlash = hp <= 15 && (Math.sin(Date.now() * 0.018) > 0);
  
  // Heart icon with pulse
  const heartSize = hp < 30 ? 11 + Math.sin(Date.now() * 0.01) * 1 : 11;
  ctx.fillStyle = dangerFlash ? '#ff2222' : (hpPct > 0.7 ? '#2aaa5c' : hpPct > 0.4 ? '#f0e840' : '#ff2222');
  ctx.font = `${heartSize}px "Press Start 2P"`;
  ctx.fillText('â¤', hx, 20);
  
  // Health label
  ctx.fillStyle = dangerFlash ? 'rgba(255, 255, 255, 0.7)' : '#8a8a9a';
  ctx.font = '7px "Press Start 2P"';
  ctx.fillText('HP', hx + 14, 12);
  
  // Enhanced health bar with gradient
  const barX = hx + 14;
  const barY = 15;
  const barW = 100;
  const barH = 12;
  
  // Bar background
  ctx.fillStyle = '#2a2a3a';
  ctx.fillRect(barX, barY, barW, barH);
  
  // Bar fill with gradient
  const barGradient = ctx.createLinearGradient(barX, barY, barX + barW * hpPct, barY);
  if (hpPct > 0.7) {
    barGradient.addColorStop(0, '#2aaa5c');
    barGradient.addColorStop(1, '#4acc7c');
  } else if (hpPct > 0.4) {
    barGradient.addColorStop(0, '#f0a840');
    barGradient.addColorStop(1, '#f0e840');
  } else {
    barGradient.addColorStop(0, '#ff2222');
    barGradient.addColorStop(1, '#ff6666');
  }
  ctx.fillStyle = barGradient;
  ctx.fillRect(barX + 1, barY + 1, (barW - 2) * hpPct, barH - 2);
  
  // Health bar shine effect
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(barX + 1, barY + 1, (barW - 2) * hpPct, 2);
  ctx.globalAlpha = 1;
  
  // HP percentage
  ctx.fillStyle = dangerFlash ? '#ffffff' : '#ffffff';
  ctx.font = 'bold 8px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.floor(hp)}`, barX + barW / 2, barY + 9);
  
  // === CENTER: Combo Meter ===
  if (combo > 0) {
    const meterX = W / 2 - 60;
    const meterY = 8;
    const meterSize = 16;
    
    // Circular combo meter
    ctx.save();
    ctx.translate(meterX, meterY);
    
    // Background circle
    ctx.strokeStyle = '#3a3a5a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, meterSize, 0, Math.PI * 2);
    ctx.stroke();
    
    // Fill arc based on combo
    const comboColor = combo >= 15 ? '#f0e840' : combo >= 10 ? '#ff6aaa' : combo >= 5 ? '#aa4aff' : '#4a8cff';
    ctx.strokeStyle = comboColor;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, meterSize, -Math.PI / 2, -Math.PI / 2 + (comboMeterFill * Math.PI * 2));
    ctx.stroke();
    
    // Combo number in center
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 10px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${combo}`, 0, 0);
    
    ctx.restore();
    
    // "COMBO" label
    ctx.fillStyle = comboColor;
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('COMBO', meterX + 20, 16);
    
    // Combo multiplier
    ctx.fillStyle = '#8a8a9a';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText(`x${Math.pow(COMBO_MULT, Math.min(combo, 10)).toFixed(1)}`, meterX + 20, 24);
  }
  
  // === RIGHT SIDE: Timer/Wave with visual flair ===
  ctx.textAlign = 'right';
  
  if (currentDifficulty.gameTime !== Infinity) {
    const timeColor = timeLeft < 10 ? '#ff2222' : timeLeft < 30 ? '#ff8840' : '#4a8cff';
    const timeWarning = timeLeft < 10;
    
    // Timer icon
    ctx.fillStyle = timeColor;
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText('â±', W - 80, 18);
    
    // Timer label
    ctx.fillStyle = '#8a8a9a';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('TIME', W - 10, 12);
    
    // Timer value with pulse on warning
    const timerSize = timeWarning ? 12 + Math.sin(Date.now() * 0.02) * 1 : 12;
    ctx.fillStyle = timeColor;
    ctx.font = `bold ${timerSize}px "Press Start 2P"`;
    ctx.fillText(`${Math.ceil(timeLeft)}s`, W - 10, 26);
  } else {
    // Endless mode - wave counter
    ctx.fillStyle = '#aa4aff';
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText('ğŸŒŠ', W - 80, 18);
    
    ctx.fillStyle = '#8a8a9a';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('WAVE', W - 10, 12);
    
    ctx.fillStyle = '#aa4aff';
    ctx.font = 'bold 12px "Press Start 2P"';
    ctx.fillText(`${wave}`, W - 10, 26);
  }
  
  // === Books Filed Counter (below HUD) ===
  ctx.fillStyle = 'rgba(42, 42, 74, 0.7)';
  ctx.fillRect(10, hh + 5, 100, 18);
  ctx.strokeStyle = 'rgba(200, 168, 74, 0.4)';
  ctx.lineWidth = 1;
  ctx.strokeRect(10, hh + 5, 100, 18);
  
  ctx.fillStyle = '#c8a84a';
  ctx.font = '7px "Press Start 2P"';
  ctx.textAlign = 'left';
  ctx.fillText(`ğŸ“š FILED: ${booksFiledThisGame}`, 15, hh + 16);
  
  // === Carry Limit Indicator ===
  const carryX = 120;
  const carryY = hh + 5;
  const carryLimit = currentDifficulty.carryLimit + player.carryBonus;
  
  ctx.fillStyle = 'rgba(42, 42, 74, 0.7)';
  ctx.fillRect(carryX, carryY, 80, 18);
  ctx.strokeStyle = 'rgba(200, 168, 74, 0.4)';
  ctx.lineWidth = 1;
  ctx.strokeRect(carryX, carryY, 80, 18);
  
  // Book slots
  for (let i = 0; i < carryLimit; i++) {
    const slotX = carryX + 8 + i * 16;
    const slotY = carryY + 4;
    
    if (i < player.carrying.length) {
      // Filled slot
      const book = player.carrying[i];
      if (book) {
        ctx.fillStyle = BOOK_COLORS[book.type] || '#ffffff';
        ctx.fillRect(slotX, slotY, 10, 10);
      }
    } else {
      // Empty slot
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 1;
      ctx.strokeRect(slotX, slotY, 10, 10);
    }
  }
  
  // === Active Powerup Display ===
  if (activePowerup && activePowerup.type) {
    const p = POWERUP_TYPES[activePowerup.type];
    if (p) {
      const remaining = Math.ceil(activePowerup.remaining / 1000);
      const warning = remaining <= 3;
      
      const boxX = W / 2 - 90;
      const boxY = hh + 5;
      const boxW = 180;
      const boxH = 24;
      
      // Box with powerup color
      ctx.fillStyle = 'rgba(42, 42, 74, 0.95)';
      ctx.fillRect(boxX, boxY, boxW, boxH);
      
      // Animated border
      const pulse = warning ? Math.sin(Date.now() * 0.02) * 0.3 + 0.7 : 1;
      ctx.strokeStyle = p.color;
      ctx.globalAlpha = pulse;
      ctx.lineWidth = 2;
      ctx.strokeRect(boxX, boxY, boxW, boxH);
      ctx.globalAlpha = 1;
      
      // Progress bar
      const progressPct = activePowerup.remaining / p.duration;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(boxX + 2, boxY + boxH - 4, boxW - 4, 2);
      ctx.fillStyle = p.color;
      ctx.fillRect(boxX + 2, boxY + boxH - 4, (boxW - 4) * progressPct, 2);
      
      // Powerup info
      ctx.font = '9px "Press Start 2P"';
      ctx.fillStyle = p.color;
      ctx.textAlign = 'center';
      ctx.fillText(`${p.icon} ${p.label}`, W / 2, boxY + 12);
      
      ctx.font = '7px "Press Start 2P"';
      ctx.fillStyle = warning ? '#ff2222' : '#8a8a9a';
      ctx.fillText(`${remaining}s`, W / 2, boxY + 20);
    }
  }
  
  // === Achievement Notifications (Top Right) ===
  for (let i = 0; i < achievementQueue.length; i++) {
    const ach = achievementQueue[i];
    const achX = W - 260;
    const achY = hh + 10 + i * 35;
    const achW = 250;
    const achH = 30;
    
    // Animation - slide in from right
    const slideProgress = Math.min(1, (ach.maxLife - ach.life) / 300);
    const slideX = achX + (1 - slideProgress) * achW;
    
    // Fade out at end
    const fadeProgress = ach.life < 500 ? ach.life / 500 : 1;
    ctx.globalAlpha = fadeProgress;
    
    // Background
    ctx.fillStyle = 'rgba(42, 42, 74, 0.95)';
    ctx.fillRect(slideX, achY, achW, achH);
    
    // Gold border
    ctx.strokeStyle = '#c8a84a';
    ctx.lineWidth = 2;
    ctx.strokeRect(slideX, achY, achW, achH);
    
    // Icon
    ctx.fillStyle = '#f0e840';
    ctx.font = '14px "Press Start 2P"';
    ctx.textAlign = 'left';
    ctx.fillText('ğŸ†', slideX + 8, achY + 20);
    
    // Text
    ctx.fillStyle = '#f0e840';
    ctx.font = 'bold 8px "Press Start 2P"';
    ctx.fillText(ach.title, slideX + 30, achY + 12);
    
    ctx.fillStyle = '#d4d4e4';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText(ach.description, slideX + 30, achY + 22);
    
    ctx.globalAlpha = 1;
  }
  
  // === Mini-Map (Bottom Right) ===
  if (miniMapVisible) {
    const mapSize = 120;
    const mapX = W - mapSize - 10;
    const mapY = H - mapSize - 35;
    
    // Map background
    ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
    ctx.fillRect(mapX, mapY, mapSize, mapSize);
    ctx.strokeStyle = 'rgba(200, 168, 74, 0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(mapX, mapY, mapSize, mapSize);
    
    // Map title
    ctx.fillStyle = '#8a8a9a';
    ctx.font = '6px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('MAP', mapX + mapSize / 2, mapY - 4);
    
    // Scale factor
    const scaleX = mapSize / W;
    const scaleY = mapSize / H;
    
    // Shelves on map
    for (const shelf of shelves) {
      if (!shelf) continue;
      const sx = mapX + shelf.x * scaleX;
      const sy = mapY + shelf.y * scaleY;
      ctx.fillStyle = SHELF_GLOW[shelf.type] || '#ffffff';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(sx - 2, sy - 2, 4, 4);
      ctx.globalAlpha = 1;
    }
    
    // Trash can on map
    const tx = mapX + trashCan.x * scaleX;
    const ty = mapY + trashCan.y * scaleY;
    ctx.fillStyle = '#e87a2e';
    ctx.globalAlpha = 0.6;
    ctx.fillRect(tx - 2, ty - 2, 4, 4);
    ctx.globalAlpha = 1;
    
    // Books on map
    for (const book of books) {
      if (!book || book.state !== 'floor') continue;
      const bx = mapX + book.x * scaleX;
      const by = mapY + book.y * scaleY;
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.4;
      ctx.fillRect(bx - 1, by - 1, 2, 2);
      ctx.globalAlpha = 1;
    }
    
    // Ghosts on map
    for (const ghost of ghosts) {
      if (!ghost) continue;
      const gx = mapX + ghost.x * scaleX;
      const gy = mapY + ghost.y * scaleY;
      ctx.fillStyle = '#e8e8f0';
      ctx.globalAlpha = 0.7;
      ctx.fillRect(gx - 2, gy - 2, 4, 4);
      ctx.globalAlpha = 1;
    }
    
    // Player on map (pulsing)
    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
    const px = mapX + player.x * scaleX;
    const py = mapY + player.y * scaleY;
    ctx.fillStyle = '#f0e840';
    ctx.globalAlpha = pulse;
    ctx.beginPath();
    ctx.arc(px, py, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  
  // === Controls hint at bottom ===
  ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
  ctx.fillRect(0, H - 25, W, 25);
  ctx.font = `${Math.min(8, W * 0.01)}px "Press Start 2P"`;
  ctx.fillStyle = '#6a6a8a';
  ctx.textAlign = 'center';
  ctx.fillText('WASD: Move | SPACE: Dash (Parry!) | Q: Throw Book | E: Charge Attack (3 books) | M: Map', W / 2, H - 10);
}

function renderPauseOverlay() {
  // Darken
  ctx.fillStyle = 'rgba(0, 0, 0, 0.72)';
  ctx.fillRect(0, 0, W, H);
  
  // Panel
  const pw = 280, ph = 160;
  const px = W/2 - pw/2, py = H/2 - ph/2;
  
  ctx.fillStyle = 'rgba(42, 42, 74, 0.95)';
  ctx.fillRect(px, py, pw, ph);
  ctx.strokeStyle = '#c8a84a';
  ctx.lineWidth = 3;
  ctx.strokeRect(px, py, pw, ph);
  
  // Title
  ctx.fillStyle = '#c8a84a';
  ctx.font = 'bold 20px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('PAUSED', W/2, py + 40);
  
  // Stats
  ctx.font = '9px "Press Start 2P"';
  ctx.fillStyle = '#d4d4e4';
  ctx.fillText(`Score: ${score}`, W/2, py + 70);
  ctx.fillText(`Books Filed: ${booksFiledThisGame}`, W/2, py + 90);
  
  // Controls
  const blink = Math.sin(Date.now() * 0.006) > 0;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillStyle = blink ? '#ffffff' : '#8a8a9a';
  ctx.fillText('ESC â€” Resume', W/2, py + 120);
  
  ctx.fillStyle = blink ? '#ff6a6a' : '#8a8a9a';
  ctx.fillText('ENTER â€” Quit', W/2, py + 145);
}

function renderGameOver() {
  // Darken
  ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
  ctx.fillRect(0, 0, W, H);
  
  // Title
  ctx.fillStyle = '#c8a84a';
  ctx.font = 'bold 28px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', W/2, 120);
  
  // Score
  ctx.font = 'bold 20px "Press Start 2P"';
  ctx.fillStyle = '#f0e840';
  ctx.fillText(`SCORE: ${score}`, W/2, 180);
  
  // Stats
  ctx.font = '10px "Press Start 2P"';
  ctx.fillStyle = '#d4d4e4';
  ctx.fillText(`Books Filed: ${booksFiledThisGame}`, W/2, 230);
  ctx.fillText(`Max Combo: ${combo}x`, W/2, 255);
  
  // Continue
  const blink = Math.sin(Date.now() * 0.006) > 0;
  ctx.font = '10px "Press Start 2P"';
  ctx.fillStyle = blink ? '#ffffff' : '#6a6a8a';
  ctx.fillText('Press any key to continue', W/2, H - 60);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = 0;
function gameLoop(time) {
  const dt = Math.min(time - lastTime, 50);
  lastTime = time;
  
  update(dt);
  render();
  
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
